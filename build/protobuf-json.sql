-- Code generated by scripts/common.mk; DO NOT EDIT.

DELIMITER $$


DROP PROCEDURE IF EXISTS _pb_wire_json_get_primitive_field_as_json $$
CREATE PROCEDURE _pb_wire_json_get_primitive_field_as_json(IN wire_json JSON, IN field_number INT, IN field_type INT, IN is_repeated BOOLEAN, IN has_field_presence BOOLEAN, IN emit_64bit_integers_as_numbers BOOLEAN, IN emit_floats_as_hex_strings BOOLEAN, OUT field_json_value JSON)
BEGIN
	DECLARE message_text TEXT;
	DECLARE boolean_value BOOLEAN;
	DECLARE uint_value BIGINT UNSIGNED;
	DECLARE int_value BIGINT;

	CASE field_type
	WHEN 1 THEN -- double
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_double_field_as_json_array(wire_json, field_number);
		ELSE
			IF emit_floats_as_hex_strings THEN -- IEEE 754 binary format
				-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
				SET uint_value = pb_wire_json_get_fixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
				IF uint_value IS NULL THEN
					SET field_json_value = NULL;
				ELSE
					SET field_json_value = _pb_convert_double_uint64_to_number_json(uint_value);
				END IF;
			ELSE -- Standard JSON format
				SET field_json_value = CAST(pb_wire_json_get_double_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			END IF;
		END IF;
	WHEN 2 THEN -- float
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_float_field_as_json_array(wire_json, field_number);
		ELSE
			IF emit_floats_as_hex_strings THEN -- IEEE 754 binary format
				-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
				SET uint_value = pb_wire_json_get_fixed32_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
				IF uint_value IS NULL THEN
					SET field_json_value = NULL;
				ELSE
					SET field_json_value = _pb_convert_float_uint32_to_number_json(uint_value);
				END IF;
			ELSE -- Standard JSON format
				SET field_json_value = CAST(pb_wire_json_get_float_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			END IF;
		END IF;
	WHEN 3 THEN -- int64
		IF is_repeated THEN
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = pb_wire_json_get_repeated_int64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_int64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			SET int_value = pb_wire_json_get_int64_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = CAST(int_value AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(int_value AS CHAR));
			END IF;
		END IF;
	WHEN 4 THEN -- uint64
		IF is_repeated THEN
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = pb_wire_json_get_repeated_uint64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_uint64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			SET uint_value = pb_wire_json_get_uint64_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = CAST(uint_value AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(uint_value AS CHAR));
			END IF;
		END IF;
	WHEN 5 THEN -- int32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_int32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_int32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 6 THEN -- fixed64
		IF is_repeated THEN
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = pb_wire_json_get_repeated_fixed64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_fixed64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			SET uint_value = pb_wire_json_get_fixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = CAST(uint_value AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(uint_value AS CHAR));
			END IF;
		END IF;
	WHEN 7 THEN -- fixed32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_fixed32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_fixed32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 8 THEN -- bool
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_bool_field_as_json_array(wire_json, field_number);
		ELSE
			SET boolean_value = pb_wire_json_get_bool_field(wire_json, field_number, IF(has_field_presence, NULL, FALSE));
			IF boolean_value IS NULL THEN
				SET field_json_value = NULL;
			ELSE
				-- See https://bugs.mysql.com/bug.php?id=79813
				SET field_json_value = CAST((boolean_value IS TRUE) AS JSON);
			END IF;
		END IF;
	WHEN 9 THEN -- string
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_string_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = JSON_QUOTE(pb_wire_json_get_string_field(wire_json, field_number, IF(has_field_presence, NULL, '')));
		END IF;
	WHEN 12 THEN -- bytes
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_bytes_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = JSON_QUOTE(TO_BASE64(pb_wire_json_get_bytes_field(wire_json, field_number, IF(has_field_presence, NULL, _binary X''))));
		END IF;
	WHEN 13 THEN -- uint32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_uint32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_uint32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 15 THEN -- sfixed32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_sfixed32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_sfixed32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 16 THEN -- sfixed64
		IF is_repeated THEN
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = pb_wire_json_get_repeated_sfixed64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_sfixed64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			SET int_value = pb_wire_json_get_sfixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = CAST(int_value AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(int_value AS CHAR));
			END IF;
		END IF;
	WHEN 17 THEN -- sint32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_sint32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_sint32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 18 THEN -- sint64
		IF is_repeated THEN
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = pb_wire_json_get_repeated_sint64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_sint64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			SET int_value = pb_wire_json_get_sint64_field(wire_json, field_number, IF(has_field_presence, NULL, 0));
			IF emit_64bit_integers_as_numbers THEN
				SET field_json_value = CAST(int_value AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(int_value AS CHAR));
			END IF;
		END IF;
	ELSE
		SET message_text = CONCAT('_pb_message_to_json: unknown field_type `', field_type, '` for field `', field_name, '` (', field_number, ').');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

DELIMITER $$

-- Main procedure for converting protobuf message to JSON using descriptor set
DROP PROCEDURE IF EXISTS _pb_wire_json_to_json_proc $$
CREATE PROCEDURE _pb_wire_json_to_json_proc(IN descriptor_set_json JSON, IN full_type_name TEXT, IN wire_json JSON, IN as_number_json BOOLEAN, IN emit_default_values BOOLEAN, OUT result JSON)
proc: BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';

	DECLARE message_text TEXT;
	DECLARE message_descriptor JSON;
	DECLARE file_descriptor JSON;
	DECLARE syntax TEXT;
	DECLARE fields JSON;
	DECLARE field_count INT;
	DECLARE field_index INT;
	DECLARE field_descriptor JSON;

	-- Field properties
	DECLARE field_number INT;
	DECLARE field_name TEXT;
	DECLARE field_label INT;
	DECLARE field_type INT;
	DECLARE field_type_name TEXT;
	DECLARE json_name TEXT;
	DECLARE proto3_optional BOOLEAN;
	DECLARE oneof_index INT;
	DECLARE default_value TEXT;

	-- Processing variables
	DECLARE is_repeated BOOLEAN;
	DECLARE has_field_presence BOOLEAN;
	DECLARE field_json_value JSON;
	DECLARE json_field_name TEXT;
	DECLARE bytes_value LONGBLOB;
	DECLARE nested_json_value JSON;
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE field_enum_value INT;

	-- Map handling
	DECLARE is_map BOOLEAN;
	DECLARE map_entry_descriptor JSON;
	DECLARE map_key_field JSON;
	DECLARE map_value_field JSON;
	DECLARE map_key_type INT;
	DECLARE map_value_type INT;
	DECLARE map_value_type_name TEXT;
	DECLARE map_key JSON;
	DECLARE map_value JSON;

	-- Oneof handling
	DECLARE oneofs JSON;
	DECLARE oneof_priority INT;
	DECLARE oneof_priority_prev INT;

	DECLARE wkt_descriptor_set JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Handle well-known types first (only for regular JSON, not number JSON)
	IF full_type_name LIKE '.google.protobuf.%' THEN
		IF as_number_json THEN -- For ProtoNumberJSON, no special WKT handling is performed.
			SET wkt_descriptor_set = _pb_wkt_get_descriptor_set(full_type_name);
			IF wkt_descriptor_set IS NOT NULL THEN
				SET descriptor_set_json = wkt_descriptor_set;
			END IF;
		ELSE -- For ProtoJSON, we use special WKT decoders.
			SET result = _pb_wire_json_decode_wkt_as_json(wire_json, full_type_name);
			IF result IS NOT NULL THEN
				LEAVE proc;
			END IF;
		END IF;
	END IF;

	-- Get message descriptor
	SET message_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, full_type_name);

	IF message_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_wire_json_to_json: message type `', full_type_name, '` not found in descriptor set');
		SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get file descriptor to determine syntax
	SET file_descriptor = _pb_descriptor_set_get_file_descriptor(descriptor_set_json, full_type_name);
	IF file_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_wire_json_to_json: file descriptor not found for type `', full_type_name, '`');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;
	SET syntax = JSON_UNQUOTE(JSON_EXTRACT(file_descriptor, '$."12"')); -- syntax field
	IF syntax IS NULL THEN
		SET syntax = 'proto2'; -- default
	END IF;

	SET result = JSON_OBJECT();
	SET oneofs = JSON_OBJECT();

	-- Get fields array (field 2 in DescriptorProto)
	SET fields = JSON_EXTRACT(message_descriptor, '$."2"');

	IF fields IS NOT NULL THEN
		SET field_count = JSON_LENGTH(fields);
		SET field_index = 0;

		WHILE field_index < field_count DO
			SET field_descriptor = JSON_EXTRACT(fields, CONCAT('$[', field_index, ']'));

			-- Extract field properties from FieldDescriptorProto
			SET field_number = JSON_EXTRACT(field_descriptor, '$."3"'); -- number
			SET field_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."1"')); -- name
			SET field_label = JSON_EXTRACT(field_descriptor, '$."4"'); -- label
			SET field_type = JSON_EXTRACT(field_descriptor, '$."5"'); -- type
			SET field_type_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."6"')); -- type_name
			SET json_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."10"')); -- json_name
			SET proto3_optional = COALESCE(CAST(JSON_EXTRACT(field_descriptor, '$."17"') AS UNSIGNED), FALSE); -- proto3_optional
			SET oneof_index = JSON_EXTRACT(field_descriptor, '$."9"'); -- oneof_index
			SET default_value = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."7"')); -- default_value

			SET is_repeated = (field_label = 3); -- LABEL_REPEATED

			-- Check if this is a map field
			SET is_map = FALSE;
			IF field_type = 11 AND field_type_name IS NOT NULL THEN -- TYPE_MESSAGE
				SET map_entry_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, field_type_name);
				SET is_map = COALESCE(CAST(JSON_EXTRACT(map_entry_descriptor, '$."7"."7"') AS UNSIGNED), FALSE); -- map_entry
			END IF;

			-- Determine field presence
			SET has_field_presence =
				(syntax = 'proto2' AND field_label <> 3) -- proto2: all non-repeated fields
				OR (syntax = 'proto3'
					AND (
						(field_label = 1 AND proto3_optional) -- proto3 optional
						OR (field_label <> 3 AND field_type = 11) -- message fields
						OR (oneof_index IS NOT NULL) -- oneof fields
					));

			CASE field_type
			WHEN 10 THEN -- TYPE_GROUP (unsupported)
				SET message_text = CONCAT('_pb_wire_json_to_json: unsupported field_type `', field_type, '` for field `', field_name, '` (', field_number, ').');
				SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;

			WHEN 11 THEN -- TYPE_MESSAGE
				IF is_map THEN
					-- Handle map fields
					SET elements = pb_wire_json_get_repeated_message_field_as_json_array(wire_json, field_number);
					SET element_count = COALESCE(JSON_LENGTH(elements), 0);
					SET element_index = 0;
					SET field_json_value = JSON_OBJECT();

					-- Get map key/value field descriptors
					SET map_key_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[0]'); -- first field (key)
					SET map_value_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[1]'); -- second field (value)
					SET map_key_type = JSON_EXTRACT(map_key_field, '$."5"');
					SET map_value_type = JSON_EXTRACT(map_value_field, '$."5"');
					SET map_value_type_name = JSON_UNQUOTE(JSON_EXTRACT(map_value_field, '$."6"'));

					WHILE element_index < element_count DO
						SET element = pb_message_to_wire_json(FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(elements, CONCAT('$[', element_index, ']')))));
						CALL _pb_wire_json_get_primitive_field_as_json(element, 1, map_key_type, FALSE, FALSE, as_number_json, as_number_json, map_key);

						IF map_value_type = 11 THEN -- message
							CALL _pb_message_to_json(descriptor_set_json, map_value_type_name, pb_wire_json_get_message_field(element, 2, NULL), as_number_json, emit_default_values, map_value);
						ELSEIF map_value_type = 14 THEN -- enum
							IF as_number_json THEN
								SET map_value = CAST(pb_wire_json_get_enum_field(element, 2, 0) AS JSON);
							ELSE
								SET map_value = _pb_convert_number_enum_to_json(descriptor_set_json, map_value_type_name, pb_wire_json_get_enum_field(element, 2, 0));
							END IF;
						ELSE
							CALL _pb_wire_json_get_primitive_field_as_json(element, 2, map_value_type, FALSE, FALSE, as_number_json, as_number_json, map_value);
						END IF;

						IF JSON_TYPE(map_key) = 'STRING' THEN
							SET field_json_value = JSON_SET(field_json_value, CONCAT('$.', map_key), map_value);
						ELSE
							SET field_json_value = JSON_SET(field_json_value, CONCAT('$."', map_key, '"'), map_value);
						END IF;

						SET element_index = element_index + 1;
					END WHILE;

					IF NOT emit_default_values AND element_count = 0 THEN
						SET field_json_value = NULL;
					END IF;

				ELSEIF is_repeated THEN
					-- Handle repeated message fields
					SET element_count = COALESCE(pb_wire_json_get_repeated_message_field_count(wire_json, field_number), 0);
					SET element_index = 0;
					SET field_json_value = JSON_ARRAY();

					WHILE element_index < element_count DO
						SET bytes_value = pb_wire_json_get_repeated_message_field_element(wire_json, field_number, element_index);
						CALL _pb_message_to_json(descriptor_set_json, field_type_name, bytes_value, as_number_json, emit_default_values, nested_json_value);
						SET field_json_value = JSON_ARRAY_APPEND(field_json_value, '$', nested_json_value);
						SET element_index = element_index + 1;
					END WHILE;

					IF NOT emit_default_values AND element_count = 0 THEN
						SET field_json_value = NULL;
					END IF;
				ELSE
					-- Handle singular message fields
					SET bytes_value = pb_wire_json_get_message_field(wire_json, field_number, NULL);
					CALL _pb_message_to_json(descriptor_set_json, field_type_name, bytes_value, as_number_json, emit_default_values, field_json_value);
				END IF;

			WHEN 14 THEN -- TYPE_ENUM
				IF is_repeated THEN
					SET elements = pb_wire_json_get_repeated_enum_field_as_json_array(wire_json, field_number);
					SET element_count = COALESCE(JSON_LENGTH(elements), 0);
					SET element_index = 0;
					SET field_json_value = JSON_ARRAY();

					WHILE element_index < element_count DO
						SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
						IF as_number_json THEN
							SET field_json_value = JSON_ARRAY_APPEND(field_json_value, '$', CAST(element AS JSON));
						ELSE
							SET nested_json_value = _pb_convert_number_enum_to_json(descriptor_set_json, field_type_name, element);
							SET field_json_value = JSON_ARRAY_APPEND(field_json_value, '$', nested_json_value);
						END IF;
						SET element_index = element_index + 1;
					END WHILE;

					IF NOT emit_default_values AND element_count = 0 THEN
						SET field_json_value = NULL;
					END IF;
				ELSE
					-- Handle singular enum fields
					SET field_enum_value = pb_wire_json_get_enum_field(wire_json, field_number, NULL);
					IF syntax = 'proto3' AND NOT has_field_presence AND field_enum_value = 0 THEN
						SET field_enum_value = NULL;
					END IF;

					SET field_json_value = NULL;
					IF as_number_json THEN -- ProtoNumberJSON: always omit default values
						IF field_enum_value IS NOT NULL THEN
							SET field_json_value = CAST(field_enum_value AS JSON);
						END IF;
					ELSE -- ProtoJSON:
						IF field_enum_value IS NOT NULL OR (emit_default_values AND NOT has_field_presence) THEN
							IF field_enum_value IS NULL THEN
								SET field_enum_value = 0;
							END IF;
							SET field_json_value = _pb_convert_number_enum_to_json(descriptor_set_json, field_type_name, field_enum_value);
						END IF;
					END IF;
				END IF;
			ELSE
				-- Handle primitive types using existing function
				CALL _pb_wire_json_get_primitive_field_as_json(wire_json, field_number, field_type, is_repeated, has_field_presence, as_number_json, as_number_json, field_json_value);
				IF is_repeated THEN
					IF NOT emit_default_values AND JSON_LENGTH(field_json_value) = 0 THEN
						SET field_json_value = NULL;
					END IF;
				ELSE
					IF NOT has_field_presence THEN
						IF syntax = 'proto3' AND _pb_is_proto3_default_value(field_type, field_json_value) THEN
							SET field_json_value = NULL;
						END IF;
						IF emit_default_values AND field_json_value IS NULL THEN
							SET field_json_value = _pb_get_proto3_default_value(field_type, as_number_json);
						END IF;
					END IF;
				END IF;
			END CASE;

			-- Add field to result if it has a value
			IF field_json_value IS NOT NULL THEN
				IF as_number_json THEN
					SET json_field_name = CAST(field_number AS CHAR);
				ELSE
					SET json_field_name = IF(json_name IS NOT NULL, json_name, _pb_util_snake_to_camel(field_name));
				END IF;

				IF oneof_index IS NOT NULL AND NOT proto3_optional THEN
					-- Handle oneof fields
					SET elements = JSON_EXTRACT(wire_json, CONCAT('$."', field_number, '"'));
					SET oneof_priority = JSON_EXTRACT(elements, CONCAT('$[', JSON_LENGTH(elements)-1, '].i'));
					SET oneof_priority_prev = JSON_EXTRACT(oneofs, CONCAT('$."', oneof_index, '".i'));

					IF oneof_priority_prev IS NULL OR oneof_priority_prev < oneof_priority THEN
						SET oneofs = JSON_SET(oneofs, CONCAT('$."', oneof_index, '"'), JSON_OBJECT('i', oneof_priority, 'v', JSON_OBJECT(json_field_name, field_json_value)));
					END IF;
				ELSE
					-- Regular field
					IF as_number_json THEN
						-- For number JSON format, field names are numeric and need to be quoted in JSON paths
						SET result = JSON_SET(result, CONCAT('$."', json_field_name, '"'), field_json_value);
					ELSE
						SET result = JSON_SET(result, CONCAT('$.', json_field_name), field_json_value);
					END IF;
				END IF;
			END IF;

			SET field_index = field_index + 1;
		END WHILE;
	END IF;

	-- Add oneof fields to result
	SET elements = JSON_EXTRACT(oneofs, '$.*.v');
	SET element_count = JSON_LENGTH(elements);
	SET element_index = 0;

	WHILE element_index < element_count DO
		SET field_json_value = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET result = JSON_MERGE(result, field_json_value);
		SET element_index = element_index + 1;
	END WHILE;
END $$

-- Wrapper procedure that converts LONGBLOB to wire_json and delegates
DROP PROCEDURE IF EXISTS _pb_message_to_json $$
CREATE PROCEDURE _pb_message_to_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN message LONGBLOB, IN as_number_json BOOLEAN, IN emit_default_values BOOLEAN, OUT result JSON)
BEGIN
	DECLARE message_text TEXT;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_message_to_json: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF message IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_wire_json_to_json_proc(descriptor_set_json, full_type_name, pb_message_to_wire_json(message), as_number_json, emit_default_values, result);
	END IF;
END $$

DROP PROCEDURE IF EXISTS _pb_wire_json_to_json $$
CREATE PROCEDURE _pb_wire_json_to_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN wire_json JSON, IN as_number_json BOOLEAN, IN emit_default_values BOOLEAN, OUT result JSON)
BEGIN
	DECLARE message_text TEXT;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_wire_json_to_json: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF wire_json IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_wire_json_to_json_proc(descriptor_set_json, full_type_name, wire_json, as_number_json, emit_default_values, result);
	END IF;
END $$

-- Public function interface
DROP FUNCTION IF EXISTS pb_message_to_json $$
CREATE FUNCTION pb_message_to_json(descriptor_set_json JSON, type_name TEXT, message LONGBLOB, unmarshal_options JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	-- For now, options are accepted but not yet used - keeping current behavior
	CALL _pb_message_to_json(descriptor_set_json, type_name, message, FALSE, TRUE, result);
	RETURN result;
END $$

-- Private function interface for protonumberjson format
DROP FUNCTION IF EXISTS _pb_message_to_number_json $$
CREATE FUNCTION _pb_message_to_number_json(descriptor_set_json JSON, type_name TEXT, message LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	-- For now, unmarshal_options is accepted but not yet used - keeping current behavior
	CALL _pb_message_to_json(descriptor_set_json, type_name, message, TRUE, FALSE, result);
	RETURN result;
END $$

-- Public function interface for wire_json input
DROP FUNCTION IF EXISTS pb_wire_json_to_json $$
CREATE FUNCTION pb_wire_json_to_json(descriptor_set_json JSON, type_name TEXT, wire_json JSON, unmarshal_options JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	-- For now, options are accepted but not yet used - keeping current behavior
	CALL _pb_wire_json_to_json(descriptor_set_json, type_name, wire_json, FALSE, TRUE, result);
	RETURN result;
END $$

-- Private function interface for wire_json input with number JSON format
DROP FUNCTION IF EXISTS _pb_wire_json_to_number_json $$
CREATE FUNCTION _pb_wire_json_to_number_json(descriptor_set_json JSON, type_name TEXT, wire_json JSON, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	-- For now, unmarshal_options is accepted but not yet used - keeping current behavior
	CALL _pb_wire_json_to_json(descriptor_set_json, type_name, wire_json, TRUE, FALSE, result);
	RETURN result;
END $$

DELIMITER $$

-- Helper function to convert JSON value to BIGINT SIGNED, handling both numbers and strings
DROP FUNCTION IF EXISTS _pb_json_to_signed_int $$
CREATE FUNCTION _pb_json_to_signed_int(json_value JSON) RETURNS BIGINT DETERMINISTIC
BEGIN
	IF JSON_TYPE(json_value) = 'STRING' THEN
		RETURN CAST(JSON_UNQUOTE(json_value) AS SIGNED);
	ELSE
		RETURN CAST(json_value AS SIGNED);
	END IF;
END $$

-- Helper function to convert JSON value to BIGINT UNSIGNED, handling both numbers and strings
DROP FUNCTION IF EXISTS _pb_json_to_unsigned_int $$
CREATE FUNCTION _pb_json_to_unsigned_int(json_value JSON) RETURNS BIGINT UNSIGNED DETERMINISTIC
BEGIN
	IF JSON_TYPE(json_value) = 'STRING' THEN
		RETURN CAST(JSON_UNQUOTE(json_value) AS UNSIGNED);
	ELSE
		RETURN CAST(json_value AS UNSIGNED);
	END IF;
END $$


-- Helper function to check if a value is a proto3 default value
DROP FUNCTION IF EXISTS _pb_is_proto3_default_value $$
CREATE FUNCTION _pb_is_proto3_default_value(field_type INT, json_value JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	CASE field_type
	WHEN 1 THEN -- TYPE_DOUBLE
		RETURN CAST(json_value AS DOUBLE) = 0.0;
	WHEN 2 THEN -- TYPE_FLOAT
		RETURN CAST(json_value AS FLOAT) = 0.0;
	WHEN 3 THEN -- TYPE_INT64
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 4 THEN -- TYPE_UINT64
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 5 THEN -- TYPE_INT32
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 6 THEN -- TYPE_FIXED64
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 7 THEN -- TYPE_FIXED32
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 8 THEN -- TYPE_BOOL
		RETURN json_value = CAST(false AS JSON);
	WHEN 9 THEN -- TYPE_STRING
		RETURN JSON_UNQUOTE(json_value) = '';
	WHEN 11 THEN -- TYPE_MESSAGE
		RETURN JSON_LENGTH(json_value) = 0;
	WHEN 12 THEN -- TYPE_BYTES
		RETURN JSON_UNQUOTE(json_value) = '';
	WHEN 13 THEN -- TYPE_UINT32
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 15 THEN -- TYPE_SFIXED32
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 16 THEN -- TYPE_SFIXED64
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 17 THEN -- TYPE_SINT32
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 18 THEN -- TYPE_SINT64
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 14 THEN -- TYPE_ENUM
		-- Expects numeric enum value (conversion should be done elsewhere)
		RETURN CAST(json_value AS SIGNED) = 0;
	ELSE
		-- For unknown types, raise error
		SET message_text = CONCAT('_pb_is_proto3_default_value: unsupported field_type ', field_type);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

-- Helper function to get proto3 default value for a field type
DROP FUNCTION IF EXISTS _pb_get_proto3_default_value $$
CREATE FUNCTION _pb_get_proto3_default_value(field_type INT, emit_64bit_integers_as_numbers BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	CASE field_type
	WHEN 1 THEN -- TYPE_DOUBLE
		RETURN CAST(0.0 AS JSON);
	WHEN 2 THEN -- TYPE_FLOAT
		RETURN CAST(0.0 AS JSON);
	WHEN 3 THEN -- TYPE_INT64
		IF emit_64bit_integers_as_numbers THEN
			RETURN CAST(0 AS JSON);
		ELSE
			RETURN JSON_QUOTE('0');
		END IF;
	WHEN 4 THEN -- TYPE_UINT64
		IF emit_64bit_integers_as_numbers THEN
			RETURN CAST(0 AS JSON);
		ELSE
			RETURN JSON_QUOTE('0');
		END IF;
	WHEN 5 THEN -- TYPE_INT32
		RETURN CAST(0 AS JSON);
	WHEN 6 THEN -- TYPE_FIXED64
		IF emit_64bit_integers_as_numbers THEN
			RETURN CAST(0 AS JSON);
		ELSE
			RETURN JSON_QUOTE('0');
		END IF;
	WHEN 7 THEN -- TYPE_FIXED32
		RETURN CAST(0 AS JSON);
	WHEN 8 THEN -- TYPE_BOOL
		RETURN CAST(false AS JSON);
	WHEN 9 THEN -- TYPE_STRING
		RETURN JSON_QUOTE('');
	WHEN 11 THEN -- TYPE_MESSAGE
		RETURN JSON_OBJECT();
	WHEN 12 THEN -- TYPE_BYTES
		RETURN JSON_QUOTE('');
	WHEN 13 THEN -- TYPE_UINT32
		RETURN CAST(0 AS JSON);
	WHEN 15 THEN -- TYPE_SFIXED32
		RETURN CAST(0 AS JSON);
	WHEN 16 THEN -- TYPE_SFIXED64
		IF emit_64bit_integers_as_numbers THEN
			RETURN CAST(0 AS JSON);
		ELSE
			RETURN JSON_QUOTE('0');
		END IF;
	WHEN 17 THEN -- TYPE_SINT32
		RETURN CAST(0 AS JSON);
	WHEN 18 THEN -- TYPE_SINT64
		IF emit_64bit_integers_as_numbers THEN
			RETURN CAST(0 AS JSON);
		ELSE
			RETURN JSON_QUOTE('0');
		END IF;
	WHEN 14 THEN -- TYPE_ENUM
		RETURN CAST(0 AS JSON);
	ELSE
		-- For unknown types, raise error
		SET message_text = CONCAT('_pb_get_proto3_default_value: unsupported field_type ', field_type);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

-- Helper procedure to set primitive field values in wire_json format
DROP PROCEDURE IF EXISTS _pb_json_set_primitive_field_as_wire_json $$
CREATE PROCEDURE _pb_json_set_primitive_field_as_wire_json(IN wire_json JSON, IN field_number INT, IN field_type INT, IN is_repeated BOOLEAN, IN json_value JSON, IN use_packed BOOLEAN, IN syntax TEXT, IN has_field_presence BOOLEAN, IN from_number_json BOOLEAN, OUT result JSON)
proc: BEGIN
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE element JSON;
	DECLARE temp_wire_json JSON;
	DECLARE str_value TEXT;
	DECLARE hex_value TEXT;
	DECLARE uint32_bits INT UNSIGNED;
	DECLARE uint64_bits BIGINT UNSIGNED;

	SET result = wire_json;

	-- Skip encoding proto3 default values for fields without explicit presence
	IF NOT is_repeated AND syntax = 'proto3' AND NOT has_field_presence AND _pb_is_proto3_default_value(field_type, json_value) THEN
		-- Do not encode default values in proto3 for fields without explicit presence
		LEAVE proc;
	END IF;

	IF is_repeated THEN
		-- Handle repeated primitive fields
		SET element_count = JSON_LENGTH(json_value);
		SET element_index = 0;

		WHILE element_index < element_count DO
			SET element = JSON_EXTRACT(json_value, CONCAT('$[', element_index, ']'));

			CASE field_type
			WHEN 1 THEN -- TYPE_DOUBLE
				SET uint64_bits = _pb_json_parse_double_as_uint64(element, from_number_json);
				-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
				SET result = pb_wire_json_add_repeated_fixed64_field_element(result, field_number, uint64_bits, use_packed);
			WHEN 2 THEN -- TYPE_FLOAT
				SET uint32_bits = _pb_json_parse_float_as_uint32(element, from_number_json);
				-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
				SET result = pb_wire_json_add_repeated_fixed32_field_element(result, field_number, uint32_bits, use_packed);
			WHEN 3 THEN -- TYPE_INT64
				SET result = pb_wire_json_add_repeated_int64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 4 THEN -- TYPE_UINT64
				SET result = pb_wire_json_add_repeated_uint64_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 5 THEN -- TYPE_INT32
				SET result = pb_wire_json_add_repeated_int32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 6 THEN -- TYPE_FIXED64
				SET result = pb_wire_json_add_repeated_fixed64_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 7 THEN -- TYPE_FIXED32
				SET result = pb_wire_json_add_repeated_fixed32_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 8 THEN -- TYPE_BOOL
				SET result = pb_wire_json_add_repeated_bool_field_element(result, field_number, IF(element, TRUE, FALSE), use_packed);
			WHEN 9 THEN -- TYPE_STRING
				SET result = pb_wire_json_add_repeated_string_field_element(result, field_number, JSON_UNQUOTE(element));
			WHEN 10 THEN -- TYPE_SFIXED64
				SET result = pb_wire_json_add_repeated_sfixed64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 11 THEN -- TYPE_SFIXED32
				SET result = pb_wire_json_add_repeated_sfixed32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 12 THEN -- TYPE_BYTES
				SET result = pb_wire_json_add_repeated_bytes_field_element(result, field_number, _pb_util_from_base64_url(JSON_UNQUOTE(element)));
			WHEN 13 THEN -- TYPE_UINT32
				SET result = pb_wire_json_add_repeated_uint32_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 15 THEN -- TYPE_SFIXED32 (duplicate, but keeping for completeness)
				SET result = pb_wire_json_add_repeated_sfixed32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 16 THEN -- TYPE_SFIXED64 (duplicate, but keeping for completeness)
				SET result = pb_wire_json_add_repeated_sfixed64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 17 THEN -- TYPE_SINT32
				SET result = pb_wire_json_add_repeated_sint32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 18 THEN -- TYPE_SINT64
				SET result = pb_wire_json_add_repeated_sint64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			END CASE;

			SET element_index = element_index + 1;
		END WHILE;
	ELSE
		-- Handle singular primitive fields
		CASE field_type
		WHEN 1 THEN -- TYPE_DOUBLE
			SET uint64_bits = _pb_json_parse_double_as_uint64(json_value, from_number_json);
			-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
			SET result = pb_wire_json_set_fixed64_field(result, field_number, uint64_bits);
		WHEN 2 THEN -- TYPE_FLOAT
			SET uint32_bits = _pb_json_parse_float_as_uint32(json_value, from_number_json);
			-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
			SET result = pb_wire_json_set_fixed32_field(result, field_number, uint32_bits);
		WHEN 3 THEN -- TYPE_INT64
			SET result = pb_wire_json_set_int64_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 4 THEN -- TYPE_UINT64
			SET result = pb_wire_json_set_uint64_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 5 THEN -- TYPE_INT32
			SET result = pb_wire_json_set_int32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 6 THEN -- TYPE_FIXED64
			SET result = pb_wire_json_set_fixed64_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 7 THEN -- TYPE_FIXED32
			SET result = pb_wire_json_set_fixed32_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 8 THEN -- TYPE_BOOL
			SET result = pb_wire_json_set_bool_field(result, field_number, IF(json_value, TRUE, FALSE));
		WHEN 9 THEN -- TYPE_STRING
			SET result = pb_wire_json_set_string_field(result, field_number, JSON_UNQUOTE(json_value));
		WHEN 10 THEN -- TYPE_SFIXED64
			SET result = pb_wire_json_set_sfixed64_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 11 THEN -- TYPE_SFIXED32
			SET result = pb_wire_json_set_sfixed32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 12 THEN -- TYPE_BYTES
			SET result = pb_wire_json_set_bytes_field(result, field_number, _pb_util_from_base64_url(JSON_UNQUOTE(json_value)));
		WHEN 13 THEN -- TYPE_UINT32
			SET result = pb_wire_json_set_uint32_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 15 THEN -- TYPE_SFIXED32 (duplicate, but keeping for completeness)
			SET result = pb_wire_json_set_sfixed32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 16 THEN -- TYPE_SFIXED64 (duplicate, but keeping for completeness)
			SET result = pb_wire_json_set_sfixed64_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 17 THEN -- TYPE_SINT32
			SET result = pb_wire_json_set_sint32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 18 THEN -- TYPE_SINT64
			SET result = pb_wire_json_set_sint64_field(result, field_number, _pb_json_to_signed_int(json_value));
		END CASE;
	END IF;
END $$

-- Main procedure for converting JSON to protobuf wire_json using descriptor set
DROP PROCEDURE IF EXISTS _pb_json_to_wire_json_proc $$
CREATE PROCEDURE _pb_json_to_wire_json_proc(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
proc: BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';

	DECLARE message_text TEXT;
	DECLARE message_descriptor JSON;
	DECLARE file_descriptor JSON;
	DECLARE syntax TEXT;
	DECLARE fields JSON;
	DECLARE field_count INT;
	DECLARE field_index INT;
	DECLARE field_descriptor JSON;

	-- Field properties
	DECLARE field_number INT;
	DECLARE field_name TEXT;
	DECLARE field_label INT;
	DECLARE field_type INT;
	DECLARE field_type_name TEXT;
	DECLARE json_name TEXT;
	DECLARE proto3_optional BOOLEAN;
	DECLARE oneof_index INT;
	DECLARE default_value TEXT;

	-- Processing variables
	DECLARE is_repeated BOOLEAN;
	DECLARE has_field_presence BOOLEAN;
	DECLARE use_packed BOOLEAN;
	DECLARE field_json_value JSON;
	DECLARE json_field_name TEXT;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE nested_wire_json JSON;
	DECLARE enum_number INT;

	-- Map handling
	DECLARE is_map BOOLEAN;
	DECLARE map_entry_descriptor JSON;
	DECLARE map_key_field JSON;
	DECLARE map_value_field JSON;
	DECLARE map_key_type INT;
	DECLARE map_value_type INT;
	DECLARE map_value_type_name TEXT;
	DECLARE map_keys JSON;
	DECLARE map_key_count INT;
	DECLARE map_key_index INT;
	DECLARE map_key_name TEXT;
	DECLARE map_entry_wire_json JSON;
	DECLARE map_value_json JSON;
	DECLARE map_value_wire_json JSON;
	-- Well-known type handling
	DECLARE wkt_descriptor_set JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Handle well-known types first
	IF full_type_name LIKE '.google.protobuf.%' THEN
		SET result = _pb_json_encode_wkt_as_wire_json(json_value, full_type_name, from_number_json);
		IF result IS NOT NULL THEN
			LEAVE proc;
		END IF;
	END IF;

	IF JSON_TYPE(json_value) = 'NULL' THEN
		-- Null value should not produce any field in protobuf
		SET result = NULL;
		LEAVE proc;
	END IF;

	-- Get message descriptor
	SET message_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, full_type_name);

	IF message_descriptor IS NULL AND full_type_name LIKE '.google.protobuf.%' THEN
		-- Try to get well-known type descriptor set
		SET wkt_descriptor_set = _pb_wkt_get_descriptor_set(full_type_name);
		IF wkt_descriptor_set IS NOT NULL THEN
			SET descriptor_set_json = wkt_descriptor_set;
			SET message_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, full_type_name);
		END IF;
	END IF;

	IF message_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_json_to_wire_json: message type `', full_type_name, '` not found in descriptor set');
		SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get file descriptor to determine syntax
	SET file_descriptor = _pb_descriptor_set_get_file_descriptor(descriptor_set_json, full_type_name);
	SET syntax = JSON_UNQUOTE(JSON_EXTRACT(file_descriptor, '$."12"')); -- syntax field
	IF syntax IS NULL THEN
		SET syntax = 'proto2'; -- default
	END IF;

	SET result = JSON_OBJECT();

	-- Get fields array (field 2 in DescriptorProto)
	SET fields = JSON_EXTRACT(message_descriptor, '$."2"');

	IF fields IS NOT NULL THEN
		SET field_count = JSON_LENGTH(fields);
		SET field_index = 0;

		WHILE field_index < field_count DO
			SET field_descriptor = JSON_EXTRACT(fields, CONCAT('$[', field_index, ']'));

			-- Extract field properties from FieldDescriptorProto
			SET field_number = JSON_EXTRACT(field_descriptor, '$."3"'); -- number
			SET field_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."1"')); -- name
			SET field_label = JSON_EXTRACT(field_descriptor, '$."4"'); -- label
			SET field_type = JSON_EXTRACT(field_descriptor, '$."5"'); -- type
			SET field_type_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."6"')); -- type_name
			SET json_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."10"')); -- json_name
			SET proto3_optional = COALESCE(CAST(JSON_EXTRACT(field_descriptor, '$."17"') AS UNSIGNED), FALSE); -- proto3_optional
			SET oneof_index = JSON_EXTRACT(field_descriptor, '$."9"'); -- oneof_index
			SET default_value = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."7"')); -- default_value

			SET is_repeated = (field_label = 3); -- LABEL_REPEATED

			-- Check if this is a map field
			SET is_map = FALSE;
			IF field_type = 11 AND field_type_name IS NOT NULL THEN -- TYPE_MESSAGE
				SET map_entry_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, field_type_name);
				SET is_map = COALESCE(CAST(JSON_EXTRACT(map_entry_descriptor, '$."7"."7"') AS UNSIGNED), FALSE); -- map_entry
			END IF;

			-- Determine field presence
			SET has_field_presence =
				(syntax = 'proto2' AND field_label <> 3) -- proto2: all non-repeated fields
				OR (syntax = 'proto3'
					AND (
						(field_label = 1 AND proto3_optional) -- proto3 optional
						OR (field_label <> 3 AND field_type = 11) -- message fields
						OR (oneof_index IS NOT NULL) -- oneof fields
					));

			-- Determine packed encoding for repeated fields
			-- Check field options for explicit packed setting (field 8.2 in FieldDescriptorProto)
			SET use_packed = CAST(JSON_EXTRACT(field_descriptor, '$."8"."2"') AS UNSIGNED);

			-- Use syntax default if field option not set
			IF use_packed IS NULL THEN
				-- Proto3: packed by default, Proto2: unpacked by default
				SET use_packed = (syntax = 'proto3');
			END IF;

			-- Extract field value from JSON
			IF from_number_json THEN
				-- In number JSON mode, use field number
				SET field_json_value = JSON_EXTRACT(json_value, CONCAT('$."', field_number, '"'));
			ELSE
				-- Try multiple field name variations:
				-- 1. json_name if specified in proto
				-- 2. camelCase version of field name
				-- 3. original proto field name
				SET field_json_value = NULL;

				-- First try json_name if specified
				IF json_name IS NOT NULL THEN
					SET field_json_value = JSON_EXTRACT(json_value, CONCAT('$."', json_name, '"'));
				END IF;

				-- If not found and json_name is different from camelCase version, try camelCase
				IF field_json_value IS NULL THEN
					SET json_field_name = _pb_util_snake_to_camel(field_name);
					IF json_name IS NULL OR json_name != json_field_name THEN
						SET field_json_value = JSON_EXTRACT(json_value, CONCAT('$."', json_field_name, '"'));
					END IF;
				END IF;

				-- If still not found, try original proto field name
				IF field_json_value IS NULL THEN
					SET field_json_value = JSON_EXTRACT(json_value, CONCAT('$."', field_name, '"'));
				END IF;
			END IF;

			-- Process field if it exists in JSON
			IF field_json_value IS NOT NULL THEN
				CASE field_type
				WHEN 10 THEN -- TYPE_GROUP (unsupported)
					SET message_text = CONCAT('_pb_json_to_wire_json: unsupported field_type `', field_type, '` for field `', field_name, '` (', field_number, ').');
					SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;

				WHEN 11 THEN -- TYPE_MESSAGE
					IF is_map THEN
						-- Handle map fields - convert JSON object to repeated message entries
						SET map_keys = JSON_KEYS(field_json_value);
						SET map_key_count = JSON_LENGTH(map_keys);
						SET map_key_index = 0;

						-- Get map key/value field descriptors
						SET map_key_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[0]'); -- first field (key)
						SET map_value_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[1]'); -- second field (value)
						SET map_key_type = JSON_EXTRACT(map_key_field, '$."5"');
						SET map_value_type = JSON_EXTRACT(map_value_field, '$."5"');
						SET map_value_type_name = JSON_UNQUOTE(JSON_EXTRACT(map_value_field, '$."6"'));

						WHILE map_key_index < map_key_count DO
							SET map_key_name = JSON_UNQUOTE(JSON_EXTRACT(map_keys, CONCAT('$[', map_key_index, ']')));
							SET map_value_json = JSON_EXTRACT(field_json_value, CONCAT('$."', map_key_name, '"'));

							-- Create map entry with key=1, value=2
							SET map_entry_wire_json = JSON_OBJECT();

							-- Add key field (always field 1)
							-- Convert map key to proper JSON type based on key type
							-- Map keys always have presence and should always be encoded
							CASE map_key_type
							WHEN 8 THEN -- bool
								CALL _pb_json_set_primitive_field_as_wire_json(map_entry_wire_json, 1, map_key_type, FALSE, CAST((map_key_name = 'true') AS JSON), FALSE, syntax, TRUE, from_number_json, map_entry_wire_json);
							ELSE
								CALL _pb_json_set_primitive_field_as_wire_json(map_entry_wire_json, 1, map_key_type, FALSE, JSON_QUOTE(map_key_name), FALSE, syntax, TRUE, from_number_json, map_entry_wire_json);
							END CASE;

							-- Add value field (always field 2)
							IF map_value_type = 11 THEN -- message
								CALL _pb_json_to_wire_json_proc(descriptor_set_json, map_value_type_name, map_value_json, from_number_json, map_value_wire_json);
								SET map_entry_wire_json = pb_wire_json_set_message_field(map_entry_wire_json, 2, pb_wire_json_to_message(map_value_wire_json));
							ELSEIF map_value_type = 14 THEN -- enum
								SET enum_number = _pb_convert_json_enum_to_number(descriptor_set_json, map_value_type_name, map_value_json, FALSE);
								SET map_entry_wire_json = pb_wire_json_set_enum_field(map_entry_wire_json, 2, enum_number);
							ELSE
								-- Map values also always have presence in map entries
								CALL _pb_json_set_primitive_field_as_wire_json(map_entry_wire_json, 2, map_value_type, FALSE, map_value_json, FALSE, syntax, TRUE, from_number_json, map_entry_wire_json);
							END IF;

							-- Add map entry to result
							SET result = pb_wire_json_add_repeated_message_field_element(result, field_number, pb_wire_json_to_message(map_entry_wire_json));
							SET map_key_index = map_key_index + 1;
						END WHILE;

					ELSEIF is_repeated THEN
						-- Handle repeated message fields
						SET element_count = JSON_LENGTH(field_json_value);
						SET element_index = 0;

						WHILE element_index < element_count DO
							SET element = JSON_EXTRACT(field_json_value, CONCAT('$[', element_index, ']'));
							CALL _pb_json_to_wire_json_proc(descriptor_set_json, field_type_name, element, from_number_json, nested_wire_json);
							SET result = pb_wire_json_add_repeated_message_field_element(result, field_number, pb_wire_json_to_message(nested_wire_json));
							SET element_index = element_index + 1;
						END WHILE;
					ELSE
						-- Handle singular message fields
						CALL _pb_json_to_wire_json_proc(descriptor_set_json, field_type_name, field_json_value, from_number_json, nested_wire_json);
						IF nested_wire_json IS NOT NULL THEN
							SET result = pb_wire_json_set_message_field(result, field_number, pb_wire_json_to_message(nested_wire_json));
						END IF;
					END IF;

				WHEN 14 THEN -- TYPE_ENUM
					IF is_repeated THEN
						SET element_count = JSON_LENGTH(field_json_value);
						SET element_index = 0;

						WHILE element_index < element_count DO
							SET element = JSON_EXTRACT(field_json_value, CONCAT('$[', element_index, ']'));
							SET enum_number = _pb_convert_json_enum_to_number(descriptor_set_json, field_type_name, element, FALSE);
							SET result = pb_wire_json_add_repeated_enum_field_element(result, field_number, enum_number, use_packed);
							SET element_index = element_index + 1;
						END WHILE;
					ELSE
						SET enum_number = _pb_convert_json_enum_to_number(descriptor_set_json, field_type_name, field_json_value, FALSE);
						-- Skip encoding proto3 default values for fields without explicit presence
						IF NOT (syntax = 'proto3' AND NOT has_field_presence AND enum_number = 0) THEN
							SET result = pb_wire_json_set_enum_field(result, field_number, enum_number);
						END IF;
					END IF;

				ELSE
					-- Handle primitive types
					CALL _pb_json_set_primitive_field_as_wire_json(result, field_number, field_type, is_repeated, field_json_value, use_packed, syntax, has_field_presence, from_number_json, result);
				END CASE;
			END IF;

			SET field_index = field_index + 1;
		END WHILE;
	END IF;
END $$

-- Wrapper procedure for JSON to wire_json conversion
DROP PROCEDURE IF EXISTS _pb_json_to_wire_json $$
CREATE PROCEDURE _pb_json_to_wire_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE message_text TEXT;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_json_to_wire_json: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF json_value IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_json_to_wire_json_proc(descriptor_set_json, full_type_name, json_value, from_number_json, result);
	END IF;
END $$

-- Wrapper procedure for number JSON to wire_json conversion
DROP PROCEDURE IF EXISTS _pb_number_json_to_wire_json $$
CREATE PROCEDURE _pb_number_json_to_wire_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, OUT result JSON)
BEGIN
	CALL _pb_json_to_wire_json(descriptor_set_json, full_type_name, json_value, TRUE, result);
END $$

-- Wrapper procedure for JSON to message conversion
DROP PROCEDURE IF EXISTS _pb_json_to_message $$
CREATE PROCEDURE _pb_json_to_message(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, IN from_number_json BOOLEAN, OUT result LONGBLOB)
BEGIN
	DECLARE message_text TEXT;
	DECLARE wire_json JSON;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_json_to_message: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF json_value IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_json_to_wire_json_proc(descriptor_set_json, full_type_name, json_value, from_number_json, wire_json);
		SET result = pb_wire_json_to_message(wire_json);
	END IF;
END $$

-- Wrapper procedure for number JSON to message conversion
DROP PROCEDURE IF EXISTS _pb_number_json_to_message $$
CREATE PROCEDURE _pb_number_json_to_message(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, OUT result LONGBLOB)
BEGIN
	CALL _pb_json_to_message(descriptor_set_json, full_type_name, json_value, TRUE, result);
END $$

-- Public function interface for JSON to wire_json conversion
DROP FUNCTION IF EXISTS pb_json_to_wire_json $$
CREATE FUNCTION pb_json_to_wire_json(descriptor_set_json JSON, type_name TEXT, json_value JSON, json_unmarshal_options JSON, marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	-- For now, options are accepted but not yet used - keeping current behavior
	CALL _pb_json_to_wire_json(descriptor_set_json, type_name, json_value, FALSE, result);
	RETURN result;
END $$

-- Private function interface for number JSON to wire_json conversion
DROP FUNCTION IF EXISTS _pb_number_json_to_wire_json $$
CREATE FUNCTION _pb_number_json_to_wire_json(descriptor_set_json JSON, type_name TEXT, json_value JSON, marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	-- For now, marshal_options is accepted but not yet used - keeping current behavior
	CALL _pb_number_json_to_wire_json(descriptor_set_json, type_name, json_value, result);
	RETURN result;
END $$

-- Public function interface for JSON to message conversion
DROP FUNCTION IF EXISTS pb_json_to_message $$
CREATE FUNCTION pb_json_to_message(descriptor_set_json JSON, type_name TEXT, json_value JSON, json_unmarshal_options JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
	DECLARE result LONGBLOB;
	-- For now, options are accepted but not yet used - keeping current behavior
	CALL _pb_json_to_message(descriptor_set_json, type_name, json_value, FALSE, result);
	RETURN result;
END $$

-- Private function interface for number JSON to message conversion
DROP FUNCTION IF EXISTS _pb_number_json_to_message $$
CREATE FUNCTION _pb_number_json_to_message(descriptor_set_json JSON, type_name TEXT, json_value JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
	DECLARE result LONGBLOB;
	-- For now, marshal_options is accepted but not yet used - keeping current behavior
	CALL _pb_number_json_to_message(descriptor_set_json, type_name, json_value, result);
	RETURN result;
END $$

DELIMITER $$

-- Helper procedure to check if a type is a well-known type
-- TODO: Wrong and deprecated. Don't use this.
DROP PROCEDURE IF EXISTS _pb_is_well_known_type $$
CREATE PROCEDURE _pb_is_well_known_type(IN full_type_name TEXT, OUT is_wkt BOOLEAN)
BEGIN
	IF full_type_name LIKE '.google.protobuf.%' THEN
		SET is_wkt = TRUE;
	ELSE
		SET is_wkt = FALSE;
	END IF;
END $$

-- Helper function to convert JSON enum value to numeric value
-- Returns NULL for unknown values when ignore_unknown_enums is TRUE
DROP FUNCTION IF EXISTS _pb_convert_json_enum_to_number $$
CREATE FUNCTION _pb_convert_json_enum_to_number(
	descriptor_set_json JSON,
	full_enum_type_name TEXT,
	enum_value_json JSON,
	ignore_unknown_enums BOOLEAN
) RETURNS INT DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	DECLARE enum_type_index JSON;
	DECLARE type_paths JSON;
	DECLARE enum_name_index JSON;
	DECLARE enum_number_index JSON;
	DECLARE enum_descriptor JSON;
	DECLARE values_array JSON;
	DECLARE found_index INT;
	DECLARE value_descriptor JSON;
	DECLARE input_as_number INT;
	DECLARE enum_string_value TEXT;
	DECLARE is_numeric BOOLEAN DEFAULT FALSE;

	-- Handle number inputs directly
	IF JSON_TYPE(enum_value_json) = 'INTEGER' THEN
		RETURN CAST(enum_value_json AS SIGNED);
	END IF;

	-- Handle non-string inputs - this preserves the original TEXT input behavior
	IF JSON_TYPE(enum_value_json) != 'STRING' THEN
		SET message_text = CONCAT('_pb_convert_json_enum_to_number: invalid JSON type for enum field: ', JSON_TYPE(enum_value_json));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	SET enum_string_value = JSON_UNQUOTE(enum_value_json);

	-- Get enum type index (field 3 from DescriptorSet) - always signal error if missing
	SET enum_type_index = JSON_EXTRACT(descriptor_set_json, '$.\"3\"');
	IF enum_type_index IS NULL THEN
		SET message_text = '_pb_convert_json_enum_to_number: enum type index not found in descriptor set';
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get paths for the enum type - always signal error if missing
	SET type_paths = JSON_EXTRACT(enum_type_index, CONCAT('$.\"', full_enum_type_name, '\"'));
	IF type_paths IS NULL THEN
		SET message_text = CONCAT('_pb_convert_json_enum_to_number: enum type not found: ', full_enum_type_name);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Extract enum value indexes from EnumTypeIndex message
	SET enum_name_index = JSON_EXTRACT(type_paths, '$.\"3\"');
	SET enum_number_index = JSON_EXTRACT(type_paths, '$.\"4\"');

	-- Check if the input is a numeric value (protobuf JSON allows both string names and numeric values)
	SET is_numeric = (enum_string_value REGEXP '^-?[0-9]+$');
	IF is_numeric THEN
		SET input_as_number = CAST(enum_string_value AS SIGNED);
		-- Use number index for O(1) lookup
		SET found_index = JSON_EXTRACT(enum_number_index, CONCAT('$.\"', input_as_number, '\"'));
	ELSE
		-- Use name index for O(1) lookup
		SET found_index = JSON_EXTRACT(enum_name_index, CONCAT('$.\"', enum_string_value, '\"'));
	END IF;

	IF found_index IS NOT NULL THEN
		-- Get enum descriptor and values array to extract the number
		SET enum_descriptor = _pb_descriptor_set_get_enum_descriptor(descriptor_set_json, full_enum_type_name);
		SET values_array = JSON_EXTRACT(enum_descriptor, '$."2"');
		SET value_descriptor = JSON_EXTRACT(values_array, CONCAT('$[', found_index, ']'));
		RETURN JSON_EXTRACT(value_descriptor, '$."2"'); -- number field
	ELSE
		-- Not found, handle based on ignore_unknown_enums flag and numeric input
		-- ignore_unknown_enums only affects unknown VALUES, not missing type definitions
		IF is_numeric THEN
			-- For Proto3, unknown numeric enum values should be accepted as-is
			RETURN input_as_number;
		ELSEIF ignore_unknown_enums THEN
			RETURN NULL;  -- Return NULL to indicate unknown value should be ignored
		ELSE
			SET message_text = CONCAT('_pb_convert_json_enum_to_number: enum value not found: ', enum_string_value, ' in enum ', full_enum_type_name);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
	END IF;
END $$

-- Helper procedure to convert singular field value to ProtoNumberJSON
DROP PROCEDURE IF EXISTS _pb_convert_singular_field_to_number_json $$
CREATE PROCEDURE _pb_convert_singular_field_to_number_json(
	IN descriptor_set_json JSON,
	IN field_type INT,
	IN field_type_name TEXT,
	IN field_json_value JSON,
	IN ignore_unknown_fields BOOLEAN,
	IN ignore_unknown_enums BOOLEAN,
	OUT converted_value JSON,
	OUT is_default BOOLEAN
)
BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';
	DECLARE message_text TEXT;
	-- Type-specific variables
	DECLARE enum_string_value TEXT;
	DECLARE enum_numeric_value INT;
	DECLARE int64_value BIGINT;
	DECLARE uint64_value BIGINT UNSIGNED;
	DECLARE int32_value INT;
	DECLARE uint32_value INT UNSIGNED;
	DECLARE double_json_value JSON;
	DECLARE float_json_value JSON;
	DECLARE str_value TEXT;
	DECLARE bool_value BOOLEAN;
	DECLARE nested_json JSON;

	CASE field_type
	WHEN 14 THEN -- enum
		SET converted_value = _pb_convert_json_wkt_to_number_json(field_type, field_type_name, field_json_value);
		IF converted_value IS NULL THEN -- Not handled by well-known type parser
			SET enum_numeric_value = _pb_convert_json_enum_to_number(descriptor_set_json, field_type_name, field_json_value, ignore_unknown_enums);
			SET converted_value = CAST(enum_numeric_value AS JSON);
			SET is_default = (enum_numeric_value = 0);
		ELSE
			SET enum_numeric_value = converted_value;
			SET is_default = (enum_numeric_value = 0);
		END IF;

	WHEN 11 THEN -- message
		IF field_json_value IS NULL THEN
			SET is_default = TRUE;
			SET converted_value = NULL;
		ELSE
			SET is_default = FALSE;
			SET converted_value = _pb_convert_json_wkt_to_number_json(field_type, field_type_name, field_json_value);
			IF converted_value IS NULL THEN -- Not handled by well-known type parser
				-- For regular (non-WKT) messages, validate that the JSON value is an object
				IF JSON_TYPE(field_json_value) != 'OBJECT' THEN
					SET message_text = CONCAT('Invalid JSON type for message field: expected OBJECT, got ', JSON_TYPE(field_json_value));
					SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
				END IF;
				CALL _pb_json_to_number_json_proc(descriptor_set_json, field_type_name, field_json_value, ignore_unknown_fields, ignore_unknown_enums, converted_value);
			END IF;
		END IF;

	WHEN 3 THEN -- int64 (convert string to number)
		SET int64_value = _pb_json_parse_signed_int(field_json_value);
		SET converted_value = CAST(int64_value AS JSON);
		SET is_default = (int64_value = 0);

	WHEN 4 THEN -- uint64 (convert string to number)
		SET uint64_value = _pb_json_parse_unsigned_int(field_json_value);
		SET converted_value = CAST(uint64_value AS JSON);
		SET is_default = (uint64_value = 0);

	WHEN 6 THEN -- fixed64 (convert string to number)
		SET uint64_value = _pb_json_parse_unsigned_int(field_json_value);
		SET converted_value = CAST(uint64_value AS JSON);
		SET is_default = (uint64_value = 0);

	WHEN 16 THEN -- sfixed64 (convert string to number)
		SET int64_value = _pb_json_parse_signed_int(field_json_value);
		SET converted_value = CAST(int64_value AS JSON);
		SET is_default = (int64_value = 0);

	WHEN 18 THEN -- sint64 (convert string to number)
		SET int64_value = _pb_json_parse_signed_int(field_json_value);
		SET converted_value = CAST(int64_value AS JSON);
		SET is_default = (int64_value = 0);

	WHEN 5 THEN -- int32 (handle string numbers including exponential notation)
		SET int32_value = _pb_json_parse_signed_int(field_json_value);
		SET converted_value = CAST(int32_value AS JSON);
		SET is_default = (int32_value = 0);

	WHEN 13 THEN -- uint32 (handle string numbers including exponential notation)
		SET uint32_value = _pb_json_parse_unsigned_int(field_json_value);
		SET converted_value = CAST(uint32_value AS JSON);
		SET is_default = (uint32_value = 0);

	WHEN 7 THEN -- fixed32 (handle with range validation)
		SET uint32_value = _pb_json_parse_unsigned_int(field_json_value);
		SET converted_value = CAST(uint32_value AS JSON);
		SET is_default = (uint32_value = 0);

	WHEN 15 THEN -- sfixed32 (handle with range validation)
		SET int32_value = _pb_json_parse_signed_int(field_json_value);
		SET converted_value = CAST(int32_value AS JSON);
		SET is_default = (int32_value = 0);

	WHEN 17 THEN -- sint32 (handle with range validation)
		SET int32_value = _pb_json_parse_signed_int(field_json_value);
		SET converted_value = CAST(int32_value AS JSON);
		SET is_default = (int32_value = 0);

	WHEN 1 THEN -- double (handle with validation)
		SET uint64_value = _pb_json_parse_double_as_uint64(field_json_value, FALSE);
		SET converted_value = _pb_convert_double_uint64_to_number_json(uint64_value);
		SET is_default = (uint64_value = 0);

	WHEN 2 THEN -- float (handle with validation)
		SET uint32_value = _pb_json_parse_float_as_uint32(field_json_value, FALSE);
		SET converted_value = _pb_convert_float_uint32_to_number_json(uint32_value);
		SET is_default = (uint32_value = 0);

	WHEN 12 THEN -- bytes
		-- Decode from JSON Base64/Base64URL and re-encode as standard Base64
		SET str_value = JSON_UNQUOTE(field_json_value);
		SET converted_value = JSON_QUOTE(TO_BASE64(_pb_json_parse_bytes(field_json_value)));
		SET is_default = (str_value = '');

	WHEN 8 THEN -- bool
		SET bool_value = CAST(_pb_json_parse_bool(field_json_value) AS JSON);
		SET converted_value = IF(bool_value, CAST('true' AS JSON), CAST('false' AS JSON));
		SET is_default = NOT bool_value;

	WHEN 9 THEN -- string
		SET str_value = _pb_json_parse_string(field_json_value);
		SET converted_value = JSON_QUOTE(str_value);
		SET is_default = (str_value = '');

	ELSE
		-- Unknown field type
		SET message_text = CONCAT('_pb_convert_singular_field_to_number_json: unknown field type: ', field_type);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

-- Main conversion procedure from ProtoJSON to ProtoNumberJSON
DROP PROCEDURE IF EXISTS _pb_json_to_number_json_proc $$
CREATE PROCEDURE _pb_json_to_number_json_proc(
	IN descriptor_set_json JSON,
	IN full_type_name TEXT,
	IN proto_json JSON,
	IN ignore_unknown_fields BOOLEAN,
	IN ignore_unknown_enums BOOLEAN,
	OUT result JSON
)
proc: BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';
	DECLARE message_text TEXT;
	DECLARE message_descriptor JSON;
	DECLARE file_descriptor JSON;
	DECLARE syntax TEXT;
	DECLARE fields JSON;
	DECLARE field_count INT;
	DECLARE field_index INT;
	DECLARE field_descriptor JSON;
	-- Field properties
	DECLARE field_number INT;
	DECLARE field_name TEXT;
	DECLARE field_label INT;
	DECLARE field_type INT;
	DECLARE field_type_name TEXT;
	DECLARE json_name TEXT;
	DECLARE proto3_optional BOOLEAN;
	DECLARE oneof_index INT;
	-- Processing variables
	DECLARE is_repeated BOOLEAN;
	DECLARE has_presence BOOLEAN;
	DECLARE is_default BOOLEAN;
	DECLARE field_json_value JSON;
	DECLARE source_field_name TEXT;
	DECLARE converted_value JSON;
	-- Array processing
	DECLARE array_value JSON;
	DECLARE array_length INT;
	DECLARE array_index INT;
	DECLARE array_element JSON;
	DECLARE converted_array JSON;
	-- Nested message processing
	DECLARE nested_json JSON;
	-- Map processing
	DECLARE is_map BOOLEAN DEFAULT FALSE;
	DECLARE map_entry_descriptor JSON;
	DECLARE map_value_field JSON;
	DECLARE map_value_type INT;
	DECLARE map_value_type_name TEXT;
	DECLARE map_keys JSON;
	DECLARE map_key_count INT;
	DECLARE map_key_index INT;
	DECLARE map_key_name TEXT;
	DECLARE map_value_json JSON;
	DECLARE converted_map JSON;
	-- WKT handling
	DECLARE wkt_result JSON;

	-- Set recursion limit for nested message processing
	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Check if this is a well-known type and handle it specially
	SET wkt_result = _pb_convert_json_wkt_to_number_json(11, full_type_name, proto_json);
	IF wkt_result IS NOT NULL THEN
		SET result = wkt_result;
		LEAVE proc;
	END IF;

	-- Initialize result as empty object
	SET result = JSON_OBJECT();

	-- Get message descriptor
	SET message_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, full_type_name);

	IF message_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_json_to_number_json_proc: message type not found: ', full_type_name);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get fields array (field 2 in DescriptorProto)
	SET fields = JSON_EXTRACT(message_descriptor, '$."2"');
	SET field_count = JSON_LENGTH(fields);
	SET field_index = 0;

	-- Get file descriptor to determine syntax
	SET file_descriptor = _pb_descriptor_set_get_file_descriptor(descriptor_set_json, full_type_name);
	SET syntax = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(file_descriptor, '$."12"')), 'proto2');

	-- Process each field in the message descriptor
	field_loop: WHILE field_index < field_count DO
		SET field_descriptor = JSON_EXTRACT(fields, CONCAT('$[', field_index, ']'));

		-- Extract field metadata using protobuf field numbers
		SET field_number = JSON_EXTRACT(field_descriptor, '$."3"'); -- number
		SET field_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."1"')); -- name
		SET field_label = COALESCE(JSON_EXTRACT(field_descriptor, '$."4"'), 1); -- label
		SET field_type = JSON_EXTRACT(field_descriptor, '$."5"'); -- type
		SET field_type_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."6"')); -- type_name
		SET json_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."10"')); -- json_name
		SET proto3_optional = JSON_EXTRACT(field_descriptor, '$."17"'); -- proto3_optional
		SET oneof_index = JSON_EXTRACT(field_descriptor, '$."9"'); -- oneof_index

		SET is_repeated = (field_label = 3);
		-- Determine field presence
		SET has_presence = (syntax = 'proto2' AND field_label <> 3) -- proto2: all non-repeated fields
			OR (syntax = 'proto3'
				AND (
					(field_label = 1 AND proto3_optional) -- proto3 optional
					OR (field_label <> 3 AND field_type = 11) -- message fields
					OR (oneof_index IS NOT NULL) -- oneof fields
			));

		-- Check if this is a map field
		SET is_map = FALSE;
		IF is_repeated AND field_type = 11 AND field_type_name IS NOT NULL THEN -- TYPE_MESSAGE
			SET map_entry_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, field_type_name);
			SET is_map = COALESCE(CAST(JSON_EXTRACT(map_entry_descriptor, '$."7"."7"') AS UNSIGNED), FALSE); -- map_entry
		END IF;

		-- Try multiple field name variations:
		-- 1. json_name if specified in proto
		-- 2. camelCase version of field name
		-- 3. original proto field name
		SET field_json_value = NULL;

		-- First try json_name if specified
		IF json_name IS NOT NULL THEN
			IF JSON_CONTAINS_PATH(proto_json, 'one', CONCAT('$.', json_name)) THEN
				SET field_json_value = JSON_EXTRACT(proto_json, CONCAT('$.', json_name));
			END IF;
		END IF;

		-- If not found and json_name is different from camelCase version, try camelCase
		IF field_json_value IS NULL THEN
			SET source_field_name = _pb_util_snake_to_camel(field_name);
			IF json_name IS NULL OR json_name != source_field_name THEN
				IF JSON_CONTAINS_PATH(proto_json, 'one', CONCAT('$.', source_field_name)) THEN
					SET field_json_value = JSON_EXTRACT(proto_json, CONCAT('$.', source_field_name));
				END IF;
			END IF;
		END IF;

		-- If still not found, try original proto field name
		IF field_json_value IS NULL THEN
			IF JSON_CONTAINS_PATH(proto_json, 'one', CONCAT('$.', field_name)) THEN
				SET field_json_value = JSON_EXTRACT(proto_json, CONCAT('$.', field_name));
			END IF;
		END IF;

		-- If field is not found, skip to the next field processing.
		IF field_json_value IS NULL THEN
			SET field_index = field_index + 1;
			ITERATE field_loop;
		END IF;

		IF is_map THEN
			-- Explicit JSON null for a map field means the map is empty. This seems weird, but required by AllFieldAcceptNull.
			IF JSON_TYPE(field_json_value) = 'NULL' THEN
				SET field_index = field_index + 1;
				ITERATE field_loop;
			END IF;

			-- Handle map fields - convert JSON object to ProtoNumberJSON format
			-- Maps in ProtoJSON are objects like {"key1": "value1", "key2": "value2"}
			-- In ProtoNumberJSON, values may need conversion based on their types
			-- Get map value field type for conversion
			SET map_value_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[1]'); -- second field (value)
			SET map_value_type = JSON_EXTRACT(map_value_field, '$."5"');
			SET map_value_type_name = JSON_UNQUOTE(JSON_EXTRACT(map_value_field, '$."6"'));

			-- Convert map values if necessary
			SET map_keys = JSON_KEYS(field_json_value);
			SET map_key_count = JSON_LENGTH(map_keys);
			SET converted_map = JSON_OBJECT();
			SET map_key_index = 0;

			-- TODO: validate map_key
			WHILE map_key_index < map_key_count DO
				SET map_key_name = JSON_UNQUOTE(JSON_EXTRACT(map_keys, CONCAT('$[', map_key_index, ']')));
				SET map_value_json = JSON_EXTRACT(field_json_value, CONCAT('$."', map_key_name, '"'));

				-- Use singular field conversion procedure
				CALL _pb_convert_singular_field_to_number_json(descriptor_set_json, map_value_type, map_value_type_name, map_value_json, ignore_unknown_fields, ignore_unknown_enums, converted_value, is_default);

				-- Add converted value to map
				-- converted_value can be NULL if ignore_unknown_enums is set and enum name value is unknown.
				IF converted_value IS NOT NULL THEN
					SET converted_map = JSON_SET(converted_map, CONCAT('$."', map_key_name, '"'), converted_value);
				END IF;

				SET map_key_index = map_key_index + 1;
			END WHILE;

			-- In proto3, skip empty maps unless proto3_optional is true or it's a oneof field
			IF map_key_count > 0 THEN
				SET result = JSON_SET(result, CONCAT('$."', field_number, '"'), converted_map);
			END IF;
		ELSEIF is_repeated THEN
			-- Explicit JSON null for a repeated field means the list is empty. This seems weird, but required by AllFieldAcceptNull.
			IF JSON_TYPE(field_json_value) = 'NULL' THEN
				SET field_index = field_index + 1;
				ITERATE field_loop;
			END IF;

			-- Handle repeated fields (arrays)
			SET array_value = field_json_value;
			SET array_length = JSON_LENGTH(array_value);
			SET converted_array = JSON_ARRAY();
			SET array_index = 0;

			WHILE array_index < array_length DO
				SET array_element = JSON_EXTRACT(array_value, CONCAT('$[', array_index, ']'));

				-- Convert element using singular field conversion procedure
				CALL _pb_convert_singular_field_to_number_json(descriptor_set_json, field_type, field_type_name, array_element, ignore_unknown_fields, ignore_unknown_enums, converted_value, is_default);

				-- converted_value can be NULL if ignore_unknown_enums is set and enum name value is unknown.
				IF converted_value IS NOT NULL THEN
					SET converted_array = JSON_ARRAY_APPEND(converted_array, '$', converted_value);
				END IF;

				SET array_index = array_index + 1;
			END WHILE;

			IF array_length > 0 THEN
				SET result = JSON_SET(result, CONCAT('$."', field_number, '"'), converted_array);
			END IF;
		ELSE
			-- Explicit JSON null for a field that has field presence tracking means the field is not set, except
			-- if the field is .google.protobuf.Value. Explicit JSON null for a Value field, should be recognized
			-- as a non-null Value message with kind.null_value set to NULL_VALUE.
			-- Explicit JSON null for a field that doesn't have a field presence tracking (>=proto3) means a zero
			-- value is set (and zero values are omitted in ProtoNumberJSON or on wire).
			IF JSON_TYPE(field_json_value) = 'NULL' AND (field_type_name IS NULL OR (field_type_name <> '.google.protobuf.Value' AND field_type_name <> '.google.protobuf.NullValue')) THEN
				SET field_index = field_index + 1;
				ITERATE field_loop;
			END IF;

			-- Handle singular fields
			CALL _pb_convert_singular_field_to_number_json(descriptor_set_json, field_type, field_type_name, field_json_value, ignore_unknown_fields, ignore_unknown_enums, converted_value, is_default);

			-- Include field unless it's a default value in proto3 without explicit presence
			-- converted_value can be NULL if ignore_unknown_enums is set and enum name value is unknown.
			IF converted_value IS NOT NULL AND has_presence OR NOT is_default THEN
				SET result = JSON_SET(result, CONCAT('$."', field_number, '"'), converted_value);
			END IF;
		END IF;

		SET field_index = field_index + 1;
	END WHILE field_loop;
END $$

-- Public function interface
DROP FUNCTION IF EXISTS _pb_json_to_number_json $$
CREATE FUNCTION _pb_json_to_number_json(descriptor_set_json JSON, type_name TEXT, proto_json JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	DECLARE result JSON;
	DECLARE ignore_unknown_fields BOOLEAN DEFAULT FALSE;
	DECLARE ignore_unknown_enums BOOLEAN DEFAULT FALSE;

	-- Extract options using the generated accessor functions
	IF json_unmarshal_options IS NOT NULL THEN
		SET ignore_unknown_fields = pb_json_unmarshal_options_get_ignore_unknown_fields(json_unmarshal_options);
		SET ignore_unknown_enums = pb_json_unmarshal_options_get_ignore_unknown_enums(json_unmarshal_options);
	END IF;

	-- Validate type name starts with dot
	IF type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_json_to_number_json: type name `', type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF proto_json IS NULL THEN
		RETURN NULL;
	END IF;

	CALL _pb_json_to_number_json_proc(descriptor_set_json, type_name, proto_json, ignore_unknown_fields, ignore_unknown_enums, result);
	RETURN result;
END $$

DELIMITER $$

-- Helper function to convert enum numeric value to JSON (string name for known values, number for unknown values)
DROP FUNCTION IF EXISTS _pb_convert_number_enum_to_json $$
CREATE FUNCTION _pb_convert_number_enum_to_json(
	descriptor_set_json JSON,
	full_enum_type_name TEXT,
	enum_numeric_value INT
) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	DECLARE enum_type_index JSON;
	DECLARE type_paths JSON;
	DECLARE enum_number_index JSON;
	DECLARE enum_descriptor JSON;
	DECLARE values_array JSON;
	DECLARE found_index INT;
	DECLARE value_descriptor JSON;
	DECLARE value_name TEXT;

	-- Get enum type index (field 3 from DescriptorSet)
	SET enum_type_index = JSON_EXTRACT(descriptor_set_json, '$.\"3\"');
	IF enum_type_index IS NULL THEN
		SET message_text = CONCAT('_pb_convert_number_enum_to_json: enum type index not found in descriptor set');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get paths for the enum type
	SET type_paths = JSON_EXTRACT(enum_type_index, CONCAT('$.\"', full_enum_type_name, '\"'));
	IF type_paths IS NULL THEN
		SET message_text = CONCAT('_pb_convert_number_enum_to_json: enum type not found: ', full_enum_type_name);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Extract enum number index from EnumTypeIndex message
	SET enum_number_index = JSON_EXTRACT(type_paths, '$.\"4\"');

	-- Use number index for O(1) lookup
	SET found_index = JSON_EXTRACT(enum_number_index, CONCAT('$.\"', enum_numeric_value, '\"'));

	IF found_index IS NOT NULL THEN
		-- Get enum descriptor and values array to extract the name
		SET enum_descriptor = _pb_descriptor_set_get_enum_descriptor(descriptor_set_json, full_enum_type_name);
		SET values_array = JSON_EXTRACT(enum_descriptor, '$."2"');
		SET value_descriptor = JSON_EXTRACT(values_array, CONCAT('$[', found_index, ']'));
		SET value_name = JSON_UNQUOTE(JSON_EXTRACT(value_descriptor, '$."1"')); -- name field
		RETURN JSON_QUOTE(value_name);
	ELSE
		-- If not found, return the numeric value as JSON number for Proto3 unknown enum values
		-- For Proto3, unknown enum values should be serialized as their numeric values
		RETURN CAST(enum_numeric_value AS JSON);
	END IF;
END $$

-- Helper procedure to convert singular field value from ProtoNumberJSON to ProtoJSON
DROP PROCEDURE IF EXISTS _pb_convert_singular_field_from_number_json $$
CREATE PROCEDURE _pb_convert_singular_field_from_number_json(
	IN descriptor_set_json JSON,
	IN field_type INT,
	IN field_type_name TEXT,
	IN field_number_json_value JSON,
	IN emit_default_values BOOLEAN,
	OUT converted_value JSON
)
BEGIN
	DECLARE enum_numeric_value INT;
	DECLARE nested_json JSON;
	DECLARE str_value TEXT;

	CASE field_type
	WHEN 14 THEN -- enum
		-- Check if it's a well-known type
		CALL _pb_is_well_known_type(field_type_name, @is_wkt);
		IF @is_wkt THEN
			SET converted_value = _pb_convert_number_json_to_wkt(field_type, field_type_name, field_number_json_value);
		ELSE
			SET enum_numeric_value = JSON_EXTRACT(field_number_json_value, '$');
			SET converted_value = _pb_convert_number_enum_to_json(descriptor_set_json, field_type_name, enum_numeric_value);
		END IF;
	WHEN 11 THEN -- message
		-- Check if it's a well-known type
		CALL _pb_is_well_known_type(field_type_name, @is_wkt);
		IF @is_wkt THEN
			SET converted_value = _pb_convert_number_json_to_wkt(field_type, field_type_name, field_number_json_value);
		ELSE
			-- Recursively convert nested message
			CALL _pb_number_json_to_json_proc(descriptor_set_json, field_type_name, field_number_json_value, emit_default_values, nested_json);
			SET converted_value = nested_json;
		END IF;
	WHEN 3 THEN -- int64 (convert number to string)
		SET converted_value = JSON_QUOTE(CAST(field_number_json_value AS CHAR));
	WHEN 4 THEN -- uint64 (convert number to string)
		SET converted_value = JSON_QUOTE(CAST(field_number_json_value AS CHAR));
	WHEN 6 THEN -- fixed64 (convert number to string)
		SET converted_value = JSON_QUOTE(CAST(field_number_json_value AS CHAR));
	WHEN 16 THEN -- sfixed64 (convert number to string)
		SET converted_value = JSON_QUOTE(CAST(field_number_json_value AS CHAR));
	WHEN 18 THEN -- sint64 (convert number to string)
		SET converted_value = JSON_QUOTE(CAST(field_number_json_value AS CHAR));
	WHEN 1 THEN -- double (check for IEEE 754 binary format)
		SET converted_value = _pb_convert_double_uint64_to_json(_pb_json_parse_double_as_uint64(field_number_json_value, TRUE));
	WHEN 2 THEN -- float (check for IEEE 754 binary format)
		SET converted_value = _pb_convert_float_uint32_to_json(_pb_json_parse_float_as_uint32(field_number_json_value, TRUE));
	ELSE
		-- Other primitive types stay the same
		SET converted_value = field_number_json_value;
	END CASE;
END $$

-- Helper procedure to convert map fields from ProtoNumberJSON to ProtoJSON
DROP PROCEDURE IF EXISTS _pb_convert_map_number_json_to_proto_json $$
CREATE PROCEDURE _pb_convert_map_number_json_to_proto_json(
	IN descriptor_set_json JSON,
	IN map_entry_type_name TEXT,
	IN map_number_json JSON,
	IN emit_default_values BOOLEAN,
	OUT map_proto_json JSON
)
BEGIN
	DECLARE map_entry_descriptor JSON;
	DECLARE key_field_descriptor JSON;
	DECLARE value_field_descriptor JSON;
	DECLARE value_field_type INT;
	DECLARE value_field_type_name TEXT;
	DECLARE map_keys JSON;
	DECLARE key_count INT;
	DECLARE key_index INT;
	DECLARE current_key TEXT;
	DECLARE current_value JSON;
	DECLARE converted_value JSON;
	DECLARE result JSON;

	-- Get the map entry descriptor
	SET map_entry_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, map_entry_type_name);

	-- Get key and value field descriptors (map entries always have field 1 = key, field 2 = value)
	SET key_field_descriptor = JSON_EXTRACT(map_entry_descriptor, '$."2"[0]'); -- field 1 (key)
	SET value_field_descriptor = JSON_EXTRACT(map_entry_descriptor, '$."2"[1]'); -- field 2 (value)

	-- Get value field type information
	SET value_field_type = JSON_EXTRACT(value_field_descriptor, '$."5"'); -- type
	SET value_field_type_name = JSON_UNQUOTE(JSON_EXTRACT(value_field_descriptor, '$."6"')); -- type_name

	-- Initialize result object
	SET result = JSON_OBJECT();

	-- Get all keys from the input map
	SET map_keys = JSON_KEYS(map_number_json);
	SET key_count = JSON_LENGTH(map_keys);
	SET key_index = 0;

	-- Process each key-value pair
	WHILE key_index < key_count DO
		SET current_key = JSON_UNQUOTE(JSON_EXTRACT(map_keys, CONCAT('$[', key_index, ']')));
		SET current_value = JSON_EXTRACT(map_number_json, CONCAT('$."', current_key, '"'));

		-- Convert the value based on its type, handling null values with appropriate defaults
		IF current_value IS NULL THEN
			-- Handle null values with appropriate defaults based on type
			CASE value_field_type
			WHEN 14 THEN -- enum
				-- Default enum value is first enum value (typically 0)
				SET converted_value = JSON_QUOTE('');
			WHEN 11 THEN -- message
				-- Default message value is empty object
				SET converted_value = JSON_OBJECT();
			WHEN 3 THEN -- int64
				SET converted_value = JSON_QUOTE('0');
			WHEN 4 THEN -- uint64
				SET converted_value = JSON_QUOTE('0');
			WHEN 6 THEN -- fixed64
				SET converted_value = JSON_QUOTE('0');
			WHEN 16 THEN -- sfixed64
				SET converted_value = JSON_QUOTE('0');
			WHEN 18 THEN -- sint64
				SET converted_value = JSON_QUOTE('0');
			WHEN 1 THEN -- double
				SET converted_value = CAST(0.0 AS JSON);
			WHEN 2 THEN -- float
				SET converted_value = CAST(0.0 AS JSON);
			WHEN 5 THEN -- int32
				SET converted_value = CAST(0 AS JSON);
			WHEN 7 THEN -- fixed32
				SET converted_value = CAST(0 AS JSON);
			WHEN 8 THEN -- bool
				SET converted_value = CAST(FALSE AS JSON);
			WHEN 9 THEN -- string
				SET converted_value = JSON_QUOTE('');
			WHEN 12 THEN -- bytes
				SET converted_value = JSON_QUOTE('');
			WHEN 13 THEN -- uint32
				SET converted_value = CAST(0 AS JSON);
			WHEN 15 THEN -- sfixed32
				SET converted_value = CAST(0 AS JSON);
			WHEN 17 THEN -- sint32
				SET converted_value = CAST(0 AS JSON);
			ELSE
				-- Unknown type, use appropriate default
				SET converted_value = JSON_QUOTE('');
			END CASE;
		ELSE
			-- Value is not null, convert using unified singular field conversion
			CALL _pb_convert_singular_field_from_number_json(descriptor_set_json, value_field_type, value_field_type_name, current_value, emit_default_values, converted_value);
		END IF;

		-- Add to result object
		SET result = JSON_SET(result, CONCAT('$."', current_key, '"'), converted_value);

		SET key_index = key_index + 1;
	END WHILE;

	SET map_proto_json = result;
END $$

-- Main conversion procedure from ProtoNumberJSON to ProtoJSON
DROP PROCEDURE IF EXISTS _pb_number_json_to_json_proc $$
CREATE PROCEDURE _pb_number_json_to_json_proc(
	IN descriptor_set_json JSON,
	IN full_type_name TEXT,
	IN number_json JSON,
	IN emit_default_values BOOLEAN,
	OUT result JSON
)
proc: BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';
	DECLARE message_text TEXT;
	DECLARE message_descriptor JSON;
	DECLARE file_descriptor JSON;
	DECLARE syntax TEXT;
	DECLARE fields JSON;
	DECLARE field_count INT;
	DECLARE field_index INT;
	DECLARE field_descriptor JSON;
	-- Field properties
	DECLARE field_number INT;
	DECLARE field_name TEXT;
	DECLARE field_label INT;
	DECLARE field_type INT;
	DECLARE field_type_name TEXT;
	DECLARE json_name TEXT;
	DECLARE proto3_optional BOOLEAN;
	-- Processing variables
	DECLARE is_repeated BOOLEAN;
	DECLARE field_json_value JSON;
	DECLARE target_field_name TEXT;
	DECLARE converted_value JSON;
	-- Array processing
	DECLARE array_value JSON;
	DECLARE array_length INT;
	DECLARE array_index INT;
	DECLARE array_element JSON;
	DECLARE converted_array JSON;
	-- Nested message processing
	DECLARE nested_json JSON;
	-- Field presence detection
	DECLARE has_presence BOOLEAN;
	-- Map handling
	DECLARE is_map BOOLEAN;
	DECLARE map_entry_descriptor JSON;
	-- WKT handling
	DECLARE wkt_result JSON;

	-- Set recursion limit for nested message processing
	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Check if this is a well-known type and handle it specially
	SET wkt_result = _pb_convert_number_json_to_wkt(11, full_type_name, number_json);
	IF wkt_result IS NOT NULL THEN
		SET result = wkt_result;
		LEAVE proc;
	END IF;

	-- Initialize result as empty object
	SET result = JSON_OBJECT();

	-- Get message descriptor
	SET message_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, full_type_name);

	IF message_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_number_json_to_json_proc: message type not found: ', full_type_name);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get fields array (field 2 in DescriptorProto)
	SET fields = JSON_EXTRACT(message_descriptor, '$."2"');
	SET field_count = JSON_LENGTH(fields);
	SET field_index = 0;

	-- Process each field in the message descriptor
	field_loop: WHILE field_index < field_count DO
		SET field_descriptor = JSON_EXTRACT(fields, CONCAT('$[', field_index, ']'));

		-- Extract field metadata using protobuf field numbers
		SET field_number = JSON_EXTRACT(field_descriptor, '$."3"'); -- number
		SET field_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."1"')); -- name
		SET field_label = COALESCE(JSON_EXTRACT(field_descriptor, '$."4"'), 1); -- label
		SET field_type = JSON_EXTRACT(field_descriptor, '$."5"'); -- type
		SET field_type_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."6"')); -- type_name
		SET json_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."10"')); -- json_name
		SET proto3_optional = COALESCE(JSON_EXTRACT(field_descriptor, '$."17"'), 0) = 1; -- proto3_optional

		-- Determine target field name (json_name takes precedence over field_name)
		SET target_field_name = COALESCE(json_name, field_name);
		SET is_repeated = (field_label = 3);

		-- Check if this is a map field
		SET is_map = FALSE;
		IF field_type = 11 AND field_type_name IS NOT NULL THEN -- TYPE_MESSAGE
			SET map_entry_descriptor = _pb_descriptor_set_get_message_descriptor(descriptor_set_json, field_type_name);
			SET is_map = COALESCE(CAST(JSON_EXTRACT(map_entry_descriptor, '$."7"."7"') AS UNSIGNED), FALSE); -- map_entry
		END IF;

		-- Check if field exists in source JSON (by field number)
		IF JSON_CONTAINS_PATH(number_json, 'one', CONCAT('$."', CAST(field_number AS CHAR), '"')) THEN
			SET field_json_value = JSON_EXTRACT(number_json, CONCAT('$."', CAST(field_number AS CHAR), '"'));

			IF is_map THEN
				-- Handle map fields: convert object keys/values properly
				-- For maps, field_json_value is an object like {"key1": value1, "key2": value2}
				-- We need to convert the values based on the map value type
				CALL _pb_convert_map_number_json_to_proto_json(descriptor_set_json, field_type_name, field_json_value, emit_default_values, nested_json);
				SET result = JSON_SET(result, CONCAT('$.', target_field_name), nested_json);
			ELSEIF is_repeated THEN
				-- Handle repeated fields (arrays)
				SET array_value = field_json_value;
				SET array_length = JSON_LENGTH(array_value);
				SET converted_array = JSON_ARRAY();
				SET array_index = 0;

				array_loop: WHILE array_index < array_length DO
					SET array_element = JSON_EXTRACT(array_value, CONCAT('$[', array_index, ']'));

					-- Convert element using unified singular field conversion
					CALL _pb_convert_singular_field_from_number_json(descriptor_set_json, field_type, field_type_name, array_element, emit_default_values, converted_value);
					SET converted_array = JSON_ARRAY_APPEND(converted_array, '$', converted_value);

					SET array_index = array_index + 1;
				END WHILE array_loop;

				SET result = JSON_SET(result, CONCAT('$.', target_field_name), converted_array);
			ELSE
				-- Handle singular fields using unified conversion
				CALL _pb_convert_singular_field_from_number_json(descriptor_set_json, field_type, field_type_name, field_json_value, emit_default_values, converted_value);
				SET result = JSON_SET(result, CONCAT('$.', target_field_name), converted_value);
			END IF;
		ELSE
			-- Field is missing from number JSON - emit default value if requested for non-optional fields
			IF emit_default_values THEN
				-- Determine if field has presence-sensing
				-- In proto3: message fields always have presence, optional fields have presence, oneof fields have presence
				-- Exception: map fields and repeated fields should always emit default values regardless of presence
				-- Only non-optional singular primitive fields lack presence
				IF is_map OR is_repeated THEN
					SET has_presence = FALSE; -- Maps and repeated fields always emit defaults
				ELSE
					SET has_presence = proto3_optional OR (JSON_EXTRACT(field_descriptor, '$.\"9\"') IS NOT NULL) OR (field_type = 11); -- oneof_index or message type
				END IF;

				-- Only emit defaults for non-presence-sensing fields
				IF NOT has_presence THEN
					IF is_map THEN
						-- Empty object for map fields
						SET result = JSON_SET(result, CONCAT('$.', target_field_name), JSON_OBJECT());
					ELSEIF is_repeated THEN
						-- Empty array for repeated fields
						SET result = JSON_SET(result, CONCAT('$.', target_field_name), JSON_ARRAY());
					ELSE
						-- Default values for singular fields
						CASE field_type
						WHEN 14 THEN -- enum
							-- Get the first (zero) enum value
							SET converted_value = _pb_convert_number_enum_to_json(descriptor_set_json, field_type_name, 0);
							SET result = JSON_SET(result, CONCAT('$.', target_field_name), converted_value);
						WHEN 11 THEN -- message
							IF is_map THEN
								-- For map fields, default is empty object
								SET result = JSON_SET(result, CONCAT('$.', target_field_name), JSON_OBJECT());
							ELSE
								-- Check if it's a well-known type
								CALL _pb_is_well_known_type(field_type_name, @is_wkt);
								IF @is_wkt THEN
									-- For WKTs, use empty object as default (could be improved)
									SET result = JSON_SET(result, CONCAT('$.', target_field_name), JSON_OBJECT());
								ELSE
									-- Recursively convert empty nested message
									CALL _pb_number_json_to_json_proc(descriptor_set_json, field_type_name, JSON_OBJECT(), emit_default_values, nested_json);
									SET result = JSON_SET(result, CONCAT('$.', target_field_name), nested_json);
								END IF;
							END IF;
						ELSE
							-- Use the existing function for primitive types (false = don't emit 64bit as numbers, use strings)
							SET converted_value = _pb_get_proto3_default_value(field_type, false);
							SET result = JSON_SET(result, CONCAT('$.', target_field_name), converted_value);
						END CASE;
					END IF;
				END IF;
			END IF;
		END IF;

		SET field_index = field_index + 1;
	END WHILE field_loop;
END $$

-- Public function interface
DROP FUNCTION IF EXISTS _pb_number_json_to_json $$
CREATE FUNCTION _pb_number_json_to_json(descriptor_set_json JSON, type_name TEXT, number_json JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	DECLARE result JSON;
	DECLARE emit_default_values BOOLEAN DEFAULT FALSE;

	-- Extract emit_default_values from json_marshal_options
	IF json_marshal_options IS NOT NULL THEN
		SET emit_default_values = pb_json_marshal_options_get_emit_default_values(json_marshal_options);
	END IF;

	-- Validate type name starts with dot
	IF type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_number_json_to_json: type name `', type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF number_json IS NULL THEN
		RETURN NULL;
	END IF;

	CALL _pb_number_json_to_json_proc(descriptor_set_json, type_name, number_json, emit_default_values, result);
	RETURN result;
END $$

DELIMITER $$

-- Helper function to convert datetime with timezone offset to UTC datetime
DROP FUNCTION IF EXISTS _pb_wkt_timestamp_convert_to_utc $$
CREATE FUNCTION _pb_wkt_timestamp_convert_to_utc(local_datetime DATETIME, timezone_offset TEXT) RETURNS DATETIME DETERMINISTIC
BEGIN
	DECLARE offset_hours INT;
	DECLARE offset_minutes INT;
	DECLARE offset_seconds_total INT;
	DECLARE offset_sign INT;

	-- Parse timezone offset manually (+/-HH:MM)
	SET offset_sign = IF(LEFT(timezone_offset, 1) = '+', 1, -1);
	SET offset_hours = CAST(SUBSTRING(timezone_offset, 2, 2) AS SIGNED);
	SET offset_minutes = CAST(SUBSTRING(timezone_offset, 5, 2) AS SIGNED);
	SET offset_seconds_total = offset_sign * (offset_hours * 3600 + offset_minutes * 60);

	-- Convert to UTC: subtract the timezone offset from the local time
	-- For example: 16:00 -08:00 means local time is 8 hours behind UTC
	-- So UTC time = local time + 8 hours = 16:00 + 8:00 = 24:00 = 00:00 next day
	RETURN TIMESTAMPADD(SECOND, -offset_seconds_total, local_datetime);
END $$

-- Helper procedure to normalize timestamp seconds and nanoseconds
-- Ensures nanos is non-negative and within [0, 999999999] range
-- Even for negative seconds, nanos must be non-negative and count forward in time
DROP PROCEDURE IF EXISTS _pb_wkt_timestamp_normalize_fields $$
CREATE PROCEDURE _pb_wkt_timestamp_normalize_fields(INOUT seconds BIGINT, INOUT nanos INT)
BEGIN
	-- Handle case where nanos is outside [0, 999999999] range
	-- For negative seconds with fractional part, nanos should still be positive
	-- Example: -1.5 seconds = seconds=-2, nanos=500000000 (not seconds=-1, nanos=-500000000)

	DECLARE extra_seconds BIGINT;

	-- Handle nanos overflow/underflow
	-- Calculate how many whole seconds are represented by nanos
	SET extra_seconds = nanos DIV 1000000000;
	SET nanos = nanos % 1000000000;

	-- Handle negative modulo result (MySQL modulo can return negative values)
	IF nanos < 0 THEN
		SET extra_seconds = extra_seconds - 1;
		SET nanos = nanos + 1000000000;
	END IF;

	-- Add the extra seconds to the original seconds
	SET seconds = seconds + extra_seconds;
END $$

-- Helper function to format timestamp from seconds and nanos to RFC 3339 string
DROP FUNCTION IF EXISTS _pb_wkt_timestamp_format_rfc3339 $$
CREATE FUNCTION _pb_wkt_timestamp_format_rfc3339(seconds BIGINT, nanos INT) RETURNS TEXT DETERMINISTIC
BEGIN
	DECLARE datetime_part TEXT;

	-- Normalize seconds and nanos using helper procedure
	CALL _pb_wkt_timestamp_normalize_fields(seconds, nanos);

	-- Validate timestamp range: [0001-01-01T00:00:00Z, 9999-12-31T23:59:59.999999999Z]
	-- This corresponds to seconds range: [-62135596800, 253402300799]
	-- Allow for 1 second tolerance in case of nanosecond normalization
	IF seconds < -62135596800 OR seconds > 253402300800 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Timestamp out of range';
	END IF;

	-- Convert seconds since Unix epoch to datetime string using TIMESTAMPADD
	SET datetime_part = TIMESTAMPADD(SECOND, seconds, '1970-01-01 00:00:00');

	-- Format as RFC 3339: replace space with T, add fractional seconds, add Z
	RETURN CONCAT(REPLACE(datetime_part, " ", "T"), _pb_wkt_time_common_format_fractional_seconds(nanos), "Z");
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_timestamp_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_timestamp_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE seconds BIGINT;
	DECLARE nanos INT;

	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE uint_value BIGINT UNSIGNED;
	DECLARE datetime_part TEXT;

	SET seconds = 0;
	SET nanos = 0;

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 0 THEN
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 1 THEN
				SET seconds = _pb_util_reinterpret_uint64_as_int64(uint_value);
			WHEN 2 THEN
				SET nanos = _pb_util_reinterpret_uint64_as_int64(uint_value);
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN JSON_QUOTE(_pb_wkt_timestamp_format_rfc3339(seconds, nanos));
END $$

-- Helper procedure to parse RFC 3339 timestamp string into seconds and nanos
DROP PROCEDURE IF EXISTS _pb_wkt_timestamp_parse_rfc3339 $$
CREATE PROCEDURE _pb_wkt_timestamp_parse_rfc3339(
	IN timestamp_str TEXT,
	OUT seconds BIGINT,
	OUT nanos INT
)
BEGIN
	DECLARE dot_pos INT;
	DECLARE nanos_str TEXT;
	DECLARE target_datetime DATETIME;
	DECLARE timezone_offset TEXT;

	-- Validate RFC 3339 format - must end with uppercase 'Z'
	IF timestamp_str IS NULL OR timestamp_str = '' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid timestamp format - empty timestamp';
	END IF;

	-- Validate RFC 3339 format (supports uppercase Z suffix or timezone offsets)
	IF timestamp_str NOT REGEXP '^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]{1,9})?(Z|[+-][0-9]{2}:[0-9]{2})$' COLLATE utf8mb4_bin THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid timestamp format - must follow RFC 3339 format';
	END IF;

	-- Convert timestamp string to seconds since Unix epoch, handling timezone offsets
	-- Extract timezone from the input string and convert to UTC
	IF timestamp_str LIKE '%Z' THEN
		-- UTC timezone, parse directly
		SET target_datetime = STR_TO_DATE(LEFT(timestamp_str, 19), '%Y-%m-%dT%H:%i:%s');
	ELSEIF timestamp_str REGEXP '[+-][0-9]{2}:[0-9]{2}$' THEN
		-- Handle timezone offset (+08:00, -08:00) using helper function
		SET timezone_offset = RIGHT(timestamp_str, 6);
		SET target_datetime = STR_TO_DATE(LEFT(timestamp_str, 19), '%Y-%m-%dT%H:%i:%s');
		SET target_datetime = _pb_wkt_timestamp_convert_to_utc(target_datetime, timezone_offset);
	ELSE
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid timestamp format - must end with Z or timezone offset';
	END IF;
	SET seconds = TIMESTAMPDIFF(SECOND, '1970-01-01 00:00:00', target_datetime);

	-- Extract nanoseconds if present
	SET nanos = 0;
	SET dot_pos = LOCATE('.', timestamp_str);
	IF dot_pos > 0 THEN
		SET nanos_str = SUBSTRING(timestamp_str, dot_pos + 1);
		-- Remove timezone suffix (Z or +/-HH:MM)
		IF nanos_str LIKE '%Z' THEN
			SET nanos_str = LEFT(nanos_str, LENGTH(nanos_str) - 1);
		ELSEIF nanos_str REGEXP '[+-][0-9]{2}:[0-9]{2}$' THEN
			SET nanos_str = LEFT(nanos_str, LENGTH(nanos_str) - 6);
		END IF;
		-- Pad or truncate to 9 digits for nanoseconds
		WHILE LENGTH(nanos_str) < 9 DO
			SET nanos_str = CONCAT(nanos_str, '0');
		END WHILE;
		SET nanos_str = LEFT(nanos_str, 9);
		SET nanos = CAST(nanos_str AS UNSIGNED);
	END IF;

	-- Normalize seconds and nanos using helper procedure
	CALL _pb_wkt_timestamp_normalize_fields(seconds, nanos);

	-- Validate timestamp range: [0001-01-01T00:00:00Z, 9999-12-31T23:59:59.999999999Z]
	-- This corresponds to seconds range: [-62135596800, 253402300799]
	IF seconds < -62135596800 OR seconds > 253402300799 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Timestamp out of range';
	END IF;
END $$

-- Helper function to convert Timestamp string to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_timestamp_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_timestamp_as_wire_json(timestamp_str TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE seconds BIGINT;
	DECLARE nanos INT;

	SET result = JSON_OBJECT();

	-- Parse timestamp string using helper procedure
	CALL _pb_wkt_timestamp_parse_rfc3339(timestamp_str, seconds, nanos);

	-- Add non-default values (proto3 semantics)
	IF seconds <> 0 THEN
		SET result = pb_wire_json_set_int64_field(result, 1, seconds);
	END IF;

	IF nanos <> 0 THEN
		SET result = pb_wire_json_set_int32_field(result, 2, nanos);
	END IF;

	RETURN result;
END $$

-- Helper function to convert Timestamp from ProtoJSON to ProtoNumberJSON
DROP FUNCTION IF EXISTS _pb_wkt_timestamp_json_to_number_json $$
CREATE FUNCTION _pb_wkt_timestamp_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE timestamp_str TEXT;
	DECLARE seconds_part BIGINT;
	DECLARE nanos_part INT;
	DECLARE dot_pos INT;
	DECLARE nanos_str TEXT;
	DECLARE number_json_value JSON;

	-- Handle JSON null input
	IF proto_json_value IS NULL OR JSON_TYPE(proto_json_value) = 'NULL' THEN
		RETURN NULL;
	END IF;

	-- Convert ISO 8601 timestamp to {seconds, nanos}
	SET timestamp_str = JSON_UNQUOTE(proto_json_value);

	-- Parse timestamp string using helper procedure
	CALL _pb_wkt_timestamp_parse_rfc3339(timestamp_str, seconds_part, nanos_part);

	-- Build result with proto3 zero-value omission
	SET number_json_value = JSON_OBJECT();
	IF seconds_part != 0 THEN
		SET number_json_value = JSON_SET(number_json_value, '$."1"', seconds_part);
	END IF;
	IF nanos_part != 0 THEN
		SET number_json_value = JSON_SET(number_json_value, '$."2"', nanos_part);
	END IF;

	RETURN number_json_value;
END $$

-- Helper function to convert Timestamp from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_timestamp_number_json_to_json $$
CREATE FUNCTION _pb_wkt_timestamp_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE seconds_part BIGINT;
	DECLARE nanos_part INT;

	IF number_json_value IS NULL THEN
		RETURN NULL;
	END IF;

	-- Convert {seconds, nanos} to ISO 8601 timestamp
	SET seconds_part = COALESCE(JSON_EXTRACT(number_json_value, '$."1"'), 0);
	SET nanos_part = COALESCE(JSON_EXTRACT(number_json_value, '$."2"'), 0);

	RETURN JSON_QUOTE(_pb_wkt_timestamp_format_rfc3339(seconds_part, nanos_part));
END $$

DELIMITER $$

-- Helper procedure to normalize duration seconds and nanoseconds
-- Follows protobuf Duration specification:
-- - nanos range: -999,999,999 to +999,999,999
-- - For durations >= 1 second: nanos must have same sign as seconds
-- - For durations < 1 second: seconds = 0, nanos can be positive or negative
DROP PROCEDURE IF EXISTS _pb_wkt_duration_normalize_fields $$
CREATE PROCEDURE _pb_wkt_duration_normalize_fields(INOUT seconds BIGINT, INOUT nanos INT)
BEGIN
	DECLARE extra_seconds BIGINT;
	DECLARE abs_nanos INT;

	-- Handle nanos overflow/underflow (outside [-999999999, 999999999])
	IF ABS(nanos) > 999999999 THEN
		-- Calculate how many whole seconds are represented by nanos
		SET extra_seconds = nanos DIV 1000000000;
		SET nanos = nanos % 1000000000;

		-- Handle negative modulo result (MySQL modulo can return negative values)
		IF nanos < 0 THEN
			SET extra_seconds = extra_seconds - 1;
			SET nanos = nanos + 1000000000;
		END IF;

		-- Add the extra seconds to the original seconds
		SET seconds = seconds + extra_seconds;
	END IF;

	-- Apply Duration-specific sign rules:
	-- For durations >= 1 second: nanos must have same sign as seconds
	-- For durations < 1 second: seconds = 0
	IF seconds > 0 AND nanos < 0 THEN
		-- Positive duration with negative nanos: adjust to maintain same sign
		SET seconds = seconds - 1;
		SET nanos = 1000000000 + nanos;
	ELSEIF seconds < 0 AND nanos > 0 THEN
		-- Negative duration with positive nanos: adjust to maintain same sign
		SET seconds = seconds + 1;
		SET nanos = nanos - 1000000000;
	END IF;

	-- Validate final ranges
	-- seconds: -315,576,000,000 to +315,576,000,000
	-- nanos: -999,999,999 to +999,999,999
	IF seconds < -315576000000 OR seconds > 315576000000 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Duration seconds out of range';
	END IF;

	IF ABS(nanos) > 999999999 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Duration nanos out of range';
	END IF;
END $$

-- Helper function to format duration from seconds and nanos to duration string
DROP FUNCTION IF EXISTS _pb_wkt_duration_format_string $$
CREATE FUNCTION _pb_wkt_duration_format_string(seconds BIGINT, nanos INT) RETURNS TEXT DETERMINISTIC
BEGIN
	-- Normalize seconds and nanos using duration-specific helper procedure
	CALL _pb_wkt_duration_normalize_fields(seconds, nanos);

	-- Validate duration range: [-315576000000, +315576000000] seconds
	IF seconds < -315576000000 OR seconds > 315576000000 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Duration out of range';
	END IF;

	-- Handle case where seconds=0 but nanos<0 (e.g., -0.5s)
	IF seconds = 0 AND nanos < 0 THEN
		RETURN CONCAT('-0', _pb_wkt_time_common_format_fractional_seconds(ABS(nanos)), 's');
	ELSE
		RETURN CONCAT(CAST(seconds AS CHAR), _pb_wkt_time_common_format_fractional_seconds(ABS(nanos)), 's');
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_duration_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_duration_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE seconds BIGINT;
	DECLARE nanos INT;

	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE uint_value BIGINT UNSIGNED;

	SET seconds = 0;
	SET nanos = 0;

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 0 THEN
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 1 THEN
				SET seconds = _pb_util_reinterpret_uint64_as_int64(uint_value);
			WHEN 2 THEN
				SET nanos = _pb_util_reinterpret_uint64_as_int64(uint_value);
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN JSON_QUOTE(_pb_wkt_duration_format_string(seconds, nanos));
END $$

-- Helper procedure to parse duration string into seconds and nanos
DROP PROCEDURE IF EXISTS _pb_wkt_duration_parse_string $$
CREATE PROCEDURE _pb_wkt_duration_parse_string(
	IN duration_str TEXT,
	OUT seconds BIGINT,
	OUT nanos INT
)
BEGIN
	DECLARE dot_pos INT;
	DECLARE s_pos INT;
	DECLARE nanos_str TEXT;
	DECLARE is_negative BOOLEAN DEFAULT FALSE;
	DECLARE duration_without_s TEXT;

	-- Validate duration format - must end with 's'
	IF duration_str IS NULL OR duration_str = '' THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid duration format - empty duration';
	END IF;

	-- Find 's' suffix
	SET s_pos = LOCATE('s', duration_str);
	IF s_pos = 0 OR s_pos <> LENGTH(duration_str) THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Invalid duration format - must end with s';
	END IF;

	-- Remove 's' suffix and check for negative sign
	SET duration_without_s = LEFT(duration_str, s_pos - 1);
	SET is_negative = LEFT(TRIM(duration_without_s), 1) = '-';

	SET dot_pos = LOCATE('.', duration_without_s);

	IF dot_pos > 0 THEN
		-- Has fractional seconds
		SET seconds = CAST(LEFT(duration_without_s, dot_pos - 1) AS SIGNED);
		SET nanos_str = SUBSTRING(duration_without_s, dot_pos + 1);
		-- Pad to 9 digits for nanoseconds
		WHILE LENGTH(nanos_str) < 9 DO
			SET nanos_str = CONCAT(nanos_str, '0');
		END WHILE;
		SET nanos_str = LEFT(nanos_str, 9);
		SET nanos = CAST(nanos_str AS SIGNED);

		-- Handle negative durations: if seconds is negative or zero but original had minus, nanos should be negative
		IF seconds < 0 OR (seconds = 0 AND is_negative) THEN
			SET nanos = -nanos;
		END IF;
	ELSE
		-- Whole seconds only
		SET seconds = CAST(duration_without_s AS SIGNED);
		SET nanos = 0;
	END IF;

	-- Validate duration range: [-315576000000, +315576000000] seconds
	IF seconds < -315576000000 OR seconds > 315576000000 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'Duration out of range';
	END IF;
END $$

-- Helper function to convert Duration string to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_duration_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_duration_as_wire_json(duration_str TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE seconds BIGINT;
	DECLARE nanos INT;

	SET result = JSON_OBJECT();

	-- Parse duration string using helper procedure
	CALL _pb_wkt_duration_parse_string(duration_str, seconds, nanos);

	-- For proto3 semantics, omit default values (seconds=0 and nanos=0)
	IF seconds = 0 AND nanos = 0 THEN
		RETURN result; -- Return empty wire_json
	END IF;

	-- Add non-default values
	IF seconds <> 0 THEN
		SET result = pb_wire_json_set_int64_field(result, 1, seconds);
	END IF;

	IF nanos <> 0 THEN
		SET result = pb_wire_json_set_int32_field(result, 2, nanos);
	END IF;

	RETURN result;
END $$

-- Helper function to convert Duration from ProtoJSON to ProtoNumberJSON
DROP FUNCTION IF EXISTS _pb_wkt_duration_json_to_number_json $$
CREATE FUNCTION _pb_wkt_duration_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE duration_str TEXT;
	DECLARE seconds_part BIGINT;
	DECLARE nanos_part INT;
	DECLARE number_json_value JSON;

	-- Handle JSON null input
	IF proto_json_value IS NULL OR JSON_TYPE(proto_json_value) = 'NULL' THEN
		RETURN NULL;
	END IF;

	-- Convert duration string like "3.5s" to {seconds, nanos}
	SET duration_str = JSON_UNQUOTE(proto_json_value);

	-- Parse duration string using helper procedure
	CALL _pb_wkt_duration_parse_string(duration_str, seconds_part, nanos_part);

	-- Build result with proto3 zero-value omission
	SET number_json_value = JSON_OBJECT();
	IF seconds_part != 0 THEN
		SET number_json_value = JSON_SET(number_json_value, '$."1"', seconds_part);
	END IF;
	IF nanos_part != 0 THEN
		SET number_json_value = JSON_SET(number_json_value, '$."2"', nanos_part);
	END IF;

	RETURN number_json_value;
END $$

-- Helper function to convert Duration from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_duration_number_json_to_json $$
CREATE FUNCTION _pb_wkt_duration_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE seconds_part BIGINT;
	DECLARE nanos_part INT;

	IF number_json_value IS NULL THEN
		RETURN NULL;
	END IF;

	-- Convert {seconds, nanos} to duration string like "3.5s"
	SET seconds_part = COALESCE(JSON_EXTRACT(number_json_value, '$."1"'), 0);
	SET nanos_part = COALESCE(JSON_EXTRACT(number_json_value, '$."2"'), 0);

	RETURN JSON_QUOTE(_pb_wkt_duration_format_string(seconds_part, nanos_part));
END $$

DELIMITER $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_struct_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_struct_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE object_key TEXT;
	DECLARE object_value JSON;
	DECLARE result JSON;

	SET result = JSON_OBJECT();

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 2 THEN
			SET element = pb_message_to_wire_json(FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v'))));
			CASE field_number
			WHEN 1 THEN
				SET object_key = pb_wire_json_get_string_field(element, 1, '');
				SET object_value = _pb_wire_json_decode_wkt_value_as_json(pb_message_to_wire_json(pb_wire_json_get_message_field(element, 2, _binary X'')));
				SET result = JSON_MERGE(result, JSON_OBJECT(object_key, object_value));
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN result;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_value_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_value_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE result JSON;
	DECLARE uint_value BIGINT UNSIGNED;
	DECLARE bytes_value LONGBLOB;

	SET result = JSON_OBJECT();

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 0 THEN -- VARINT
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 1 THEN -- null_value
				SET result = NULL;
			WHEN 4 THEN -- bool_value
				SET result = CAST(((uint_value <> 0) IS TRUE) AS JSON);
			END CASE;
		WHEN 2 THEN -- LEN
			SET bytes_value = FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v')));
			CASE field_number
			WHEN 3 THEN -- string_value
				SET result = JSON_QUOTE(CONVERT(bytes_value USING utf8mb4));
			WHEN 5 THEN -- struct_value
				SET result = _pb_wire_json_decode_wkt_struct_as_json(pb_message_to_wire_json(bytes_value));
			WHEN 6 THEN -- list_value
				SET result = _pb_wire_json_decode_wkt_list_value_as_json(pb_message_to_wire_json(bytes_value));
			END CASE;
		WHEN 1 THEN -- I64
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 2 THEN -- double_value
				SET result = CAST(_pb_util_reinterpret_uint64_as_double(uint_value) AS JSON);
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN result;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_list_value_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_list_value_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE result JSON;
	DECLARE bytes_value LONGBLOB;

	SET result = JSON_ARRAY();

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 2 THEN -- LEN
			SET bytes_value = FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v')));
			CASE field_number
			WHEN 1 THEN -- values
				SET result = JSON_ARRAY_APPEND(result, '$', _pb_wire_json_decode_wkt_value_as_json(pb_message_to_wire_json(bytes_value)));
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN result;
END $$

-- Helper procedure to convert JSON object to Struct wire_json (allows recursion)
DROP PROCEDURE IF EXISTS _pb_json_encode_wkt_struct_as_wire_json $$
CREATE PROCEDURE _pb_json_encode_wkt_struct_as_wire_json(IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE struct_keys JSON;
	DECLARE struct_key_count INT;
	DECLARE struct_key_index INT;
	DECLARE struct_key_name TEXT;
	DECLARE struct_value_json JSON;
	DECLARE struct_value_wire_json JSON;
	DECLARE struct_entry_wire_json JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;
	SET result = JSON_OBJECT();

	IF JSON_TYPE(json_value) = 'OBJECT' THEN
		SET struct_keys = JSON_KEYS(json_value);
		SET struct_key_count = JSON_LENGTH(struct_keys);
		SET struct_key_index = 0;

		WHILE struct_key_index < struct_key_count DO
			SET struct_key_name = JSON_UNQUOTE(JSON_EXTRACT(struct_keys, CONCAT('$[', struct_key_index, ']')));
			SET struct_value_json = JSON_EXTRACT(json_value, CONCAT('$."', struct_key_name, '"'));

			-- Create map entry with key=1, value=2
			SET struct_entry_wire_json = JSON_OBJECT();
			SET struct_entry_wire_json = pb_wire_json_set_string_field(struct_entry_wire_json, 1, struct_key_name);

			-- Convert value to Value type (recursive call)
			CALL _pb_json_encode_wkt_value_as_wire_json(struct_value_json, from_number_json, struct_value_wire_json);
			IF struct_value_wire_json IS NOT NULL THEN
				SET struct_entry_wire_json = pb_wire_json_set_message_field(struct_entry_wire_json, 2, pb_wire_json_to_message(struct_value_wire_json));
				SET result = pb_wire_json_add_repeated_message_field_element(result, 1, pb_wire_json_to_message(struct_entry_wire_json));
			END IF;

			SET struct_key_index = struct_key_index + 1;
		END WHILE;
	END IF;
END $$

-- Helper procedure to convert JSON array to ListValue wire_json (allows recursion)
DROP PROCEDURE IF EXISTS _pb_json_encode_wkt_list_value_as_wire_json $$
CREATE PROCEDURE _pb_json_encode_wkt_list_value_as_wire_json(IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE list_element_count INT;
	DECLARE list_element_index INT;
	DECLARE list_element JSON;
	DECLARE list_value_wire_json JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;
	SET result = JSON_OBJECT();

	IF JSON_TYPE(json_value) = 'ARRAY' THEN
		SET list_element_count = JSON_LENGTH(json_value);
		SET list_element_index = 0;

		WHILE list_element_index < list_element_count DO
			SET list_element = JSON_EXTRACT(json_value, CONCAT('$[', list_element_index, ']'));

			-- Convert element to Value type (recursive call)
			CALL _pb_json_encode_wkt_value_as_wire_json(list_element, from_number_json, list_value_wire_json);
			IF list_value_wire_json IS NOT NULL THEN
				SET result = pb_wire_json_add_repeated_message_field_element(result, 1, pb_wire_json_to_message(list_value_wire_json));
			END IF;

			SET list_element_index = list_element_index + 1;
		END WHILE;
	END IF;
END $$

-- Helper procedure to convert JSON to google.protobuf.Value wire_json (allows recursion)
DROP PROCEDURE IF EXISTS _pb_json_encode_wkt_value_as_wire_json $$
CREATE PROCEDURE _pb_json_encode_wkt_value_as_wire_json(IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE struct_wire_json JSON;
	DECLARE list_wire_json JSON;
	DECLARE uint64_bits BIGINT UNSIGNED;

	SET @@SESSION.max_sp_recursion_depth = 255;
	SET result = JSON_OBJECT();

	CASE JSON_TYPE(json_value)
	WHEN 'NULL' THEN
		-- null_value = 0 (field 1, enum)
		SET result = pb_wire_json_set_enum_field(result, 1, 0);
	WHEN 'BOOLEAN' THEN
		-- bool_value (field 4)
		SET result = pb_wire_json_set_bool_field(result, 4, IF(json_value, TRUE, FALSE));
	WHEN 'INTEGER' THEN
		-- number_value (field 2)
		IF from_number_json THEN
			SET uint64_bits = _pb_json_parse_double_as_uint64(json_value, TRUE);
			-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
			SET result = pb_wire_json_set_fixed64_field(result, 2, uint64_bits);
		ELSE
			SET result = pb_wire_json_set_double_field(result, 2, CAST(json_value AS DOUBLE));
		END IF;
	WHEN 'DECIMAL' THEN
		-- number_value (field 2)
		IF from_number_json THEN
			SET uint64_bits = _pb_json_parse_double_as_uint64(json_value, TRUE);
			-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
			SET result = pb_wire_json_set_fixed64_field(result, 2, uint64_bits);
		ELSE
			SET result = pb_wire_json_set_double_field(result, 2, CAST(json_value AS DOUBLE));
		END IF;
	WHEN 'DOUBLE' THEN
		-- number_value (field 2)
		IF from_number_json THEN
			SET uint64_bits = _pb_json_parse_double_as_uint64(json_value, TRUE);
			-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
			SET result = pb_wire_json_set_fixed64_field(result, 2, uint64_bits);
		ELSE
			SET result = pb_wire_json_set_double_field(result, 2, CAST(json_value AS DOUBLE));
		END IF;
	WHEN 'STRING' THEN
		-- string_value (field 3)
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	WHEN 'DATETIME' THEN
		-- string_value (field 3) - convert datetime to string
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	WHEN 'DATE' THEN
		-- string_value (field 3) - convert date to string
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	WHEN 'TIME' THEN
		-- string_value (field 3) - convert time to string
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	WHEN 'OBJECT' THEN
		-- struct_value (field 5) - convert to Struct
		CALL _pb_json_encode_wkt_struct_as_wire_json(json_value, from_number_json, struct_wire_json);
		IF struct_wire_json IS NOT NULL THEN
			SET result = pb_wire_json_set_message_field(result, 5, pb_wire_json_to_message(struct_wire_json));
		END IF;
	WHEN 'ARRAY' THEN
		-- list_value (field 6) - convert to ListValue
		CALL _pb_json_encode_wkt_list_value_as_wire_json(json_value, from_number_json, list_wire_json);
		IF list_wire_json IS NOT NULL THEN
			SET result = pb_wire_json_set_message_field(result, 6, pb_wire_json_to_message(list_wire_json));
		END IF;
	WHEN 'BLOB' THEN
		-- string_value (field 3) - treat binary as string
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	WHEN 'OPAQUE' THEN
		-- string_value (field 3) - treat opaque as string
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	END CASE;
END $$

-- Convert Struct JSON to number JSON format (stored procedure)
DROP PROCEDURE IF EXISTS _pb_wkt_struct_json_to_number_json $$
CREATE PROCEDURE _pb_wkt_struct_json_to_number_json(IN proto_json_value JSON, OUT result JSON)
BEGIN
	DECLARE struct_keys JSON;
	DECLARE struct_key_count INT;
	DECLARE struct_key_index INT;
	DECLARE struct_key_name TEXT;
	DECLARE struct_value_json JSON;
	DECLARE struct_converted_value JSON;
	DECLARE struct_result JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Convert Struct {key: value, key: value} to {"1": {field_map}}
	SET struct_keys = JSON_KEYS(proto_json_value);
	SET struct_key_count = JSON_LENGTH(struct_keys);
	SET struct_key_index = 0;
	SET struct_result = JSON_OBJECT();

	WHILE struct_key_index < struct_key_count DO
		SET struct_key_name = JSON_UNQUOTE(JSON_EXTRACT(struct_keys, CONCAT('$[', struct_key_index, ']')));
		SET struct_value_json = JSON_EXTRACT(proto_json_value, CONCAT('$."', struct_key_name, '"'));
		-- Recursively convert the value as Value
		CALL _pb_wkt_value_json_to_number_json(struct_value_json, struct_converted_value);
		SET struct_result = JSON_SET(struct_result, CONCAT('$."', struct_key_name, '"'), struct_converted_value);
		SET struct_key_index = struct_key_index + 1;
	END WHILE;

	-- Empty struct should result in empty object, not {"1": {}}, because default values (empty map field) are omitted in ProtoNumberJSON.
	IF struct_key_count = 0 THEN
		SET result = JSON_OBJECT();
	ELSE
		SET result = JSON_OBJECT('1', struct_result);
	END IF;
END $$

-- Convert Struct JSON to number JSON format (function wrapper)
DROP FUNCTION IF EXISTS _pb_wkt_struct_json_to_number_json $$
CREATE FUNCTION _pb_wkt_struct_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wkt_struct_json_to_number_json(proto_json_value, result);
	RETURN result;
END $$

-- Convert ListValue JSON to number JSON format (stored procedure)
DROP PROCEDURE IF EXISTS _pb_wkt_list_value_json_to_number_json $$
CREATE PROCEDURE _pb_wkt_list_value_json_to_number_json(IN proto_json_value JSON, OUT result JSON)
BEGIN
	DECLARE list_length INT;
	DECLARE list_index INT;
	DECLARE list_element_json JSON;
	DECLARE list_converted_value JSON;
	DECLARE list_result JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Convert ListValue [value, value, value] to {"1": [values]}
	SET list_length = JSON_LENGTH(proto_json_value);
	SET list_index = 0;
	SET list_result = JSON_ARRAY();

	WHILE list_index < list_length DO
		SET list_element_json = JSON_EXTRACT(proto_json_value, CONCAT('$[', list_index, ']'));
		-- Recursively convert the element as Value
		CALL _pb_wkt_value_json_to_number_json(list_element_json, list_converted_value);
		SET list_result = JSON_ARRAY_APPEND(list_result, '$', list_converted_value);
		SET list_index = list_index + 1;
	END WHILE;

	-- Empty array should result in empty object, not {"1": []}, because default values (empty repeated field) are omitted in ProtoNumberJSON.
	IF list_length = 0 THEN
		SET result = JSON_OBJECT();
	ELSE
		SET result = JSON_OBJECT('1', list_result);
	END IF;
END $$

-- Convert ListValue JSON to number JSON format (function wrapper)
DROP FUNCTION IF EXISTS _pb_wkt_list_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_list_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wkt_list_value_json_to_number_json(proto_json_value, result);
	RETURN result;
END $$

-- Convert Value JSON to number JSON format (stored procedure)
DROP PROCEDURE IF EXISTS _pb_wkt_value_json_to_number_json $$
CREATE PROCEDURE _pb_wkt_value_json_to_number_json(IN proto_json_value JSON, OUT result JSON)
BEGIN
	DECLARE converted_value JSON;
	DECLARE message_text TEXT;

	SET @@SESSION.max_sp_recursion_depth = 255;

	CASE JSON_TYPE(proto_json_value)
	WHEN 'NULL' THEN
		-- null_value (field 1, enum value 0)
		SET result = JSON_OBJECT('1', 0);
	WHEN 'INTEGER' THEN
		-- number_value (field 2)
		SET result = JSON_OBJECT('2', _pb_convert_double_uint64_to_number_json(_pb_util_reinterpret_double_as_uint64(CAST(proto_json_value AS DOUBLE))));
	WHEN 'UNSIGNED INTEGER' THEN
		-- number_value (field 2)
		SET result = JSON_OBJECT('2', _pb_convert_double_uint64_to_number_json(_pb_util_reinterpret_double_as_uint64(CAST(proto_json_value AS DOUBLE))));
	WHEN 'DOUBLE' THEN
		-- number_value (field 2)
		SET result = JSON_OBJECT('2', _pb_convert_double_uint64_to_number_json(_pb_util_reinterpret_double_as_uint64(CAST(proto_json_value AS DOUBLE))));
	WHEN 'STRING' THEN
		-- string_value (field 3)
		SET result = JSON_OBJECT('3', proto_json_value);
	WHEN 'BOOLEAN' THEN
		-- bool_value (field 4)
		SET result = JSON_OBJECT('4', proto_json_value);
	WHEN 'OBJECT' THEN
		-- struct_value (field 5) - recursively convert as Struct
		CALL _pb_wkt_struct_json_to_number_json(proto_json_value, converted_value);
		SET result = JSON_OBJECT('5', converted_value);
	WHEN 'ARRAY' THEN
		-- list_value (field 6) - recursively convert as ListValue
		CALL _pb_wkt_list_value_json_to_number_json(proto_json_value, converted_value);
		SET result = JSON_OBJECT('6', converted_value);
	ELSE
		-- Unknown JSON type, signal error
		SET message_text = CONCAT('Unsupported JSON type for Value: ', JSON_TYPE(proto_json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

-- Convert Value JSON to number JSON format (function wrapper)
DROP FUNCTION IF EXISTS _pb_wkt_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wkt_value_json_to_number_json(proto_json_value, result);
	RETURN result;
END $$

-- Helper function to convert google.protobuf.NullValue from ProtoJSON to ProtoNumberJSON
DROP FUNCTION IF EXISTS _pb_wkt_null_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_null_value_json_to_number_json(proto_json_value JSON) RETURNS INT DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	-- google.protobuf.NullValue in ProtoJSON can be:
	-- 1. JSON null -> should convert to enum value 0 (NULL_VALUE)
	-- 2. String "NULL_VALUE" -> should convert to enum value 0
	-- 3. Number 0 -> should convert to enum value 0

	IF JSON_TYPE(proto_json_value) = 'NULL' THEN
		-- JSON null represents NULL_VALUE (enum value 0)
		RETURN 0;
	ELSEIF JSON_TYPE(proto_json_value) = 'STRING' THEN
		-- String name "NULL_VALUE"
		IF JSON_UNQUOTE(proto_json_value) = 'NULL_VALUE' THEN
			RETURN 0;
		ELSE
			-- TODO: STRING '0'?
			-- Invalid string value for NullValue enum
			-- TODO: What if ignore_unknown_enums is set?
			SET message_text = CONCAT('Invalid NullValue enum string: ', JSON_UNQUOTE(proto_json_value));
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
	ELSEIF JSON_TYPE(proto_json_value) IN ('INTEGER', 'UNSIGNED INTEGER') THEN
		-- Numeric value (should be 0 for NULL_VALUE)
		RETURN proto_json_value;
	ELSE
		-- Invalid JSON type for NullValue
		SET message_text = CONCAT('Invalid JSON type for NullValue: ', JSON_TYPE(proto_json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;
END $$

-- Helper function to convert google.protobuf.NullValue from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_null_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_null_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	DECLARE enum_value INT;

	-- google.protobuf.NullValue in ProtoNumberJSON is just the enum numeric value
	-- It should always be 0 (NULL_VALUE), and converts back to JSON null

	IF JSON_TYPE(number_json_value) IN ('INTEGER', 'UNSIGNED INTEGER') THEN
		SET enum_value = CAST(number_json_value AS SIGNED);
		IF enum_value = 0 THEN
			-- NULL_VALUE (enum value 0) converts to JSON null
			RETURN CAST(NULL AS JSON);
		ELSE
			-- Invalid numeric value for NullValue enum
			SET message_text = CONCAT('Invalid NullValue enum number in ProtoNumberJSON: ', enum_value);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
	ELSE
		-- Invalid JSON type for NullValue in ProtoNumberJSON
		SET message_text = CONCAT('Invalid JSON type for NullValue in ProtoNumberJSON: ', JSON_TYPE(number_json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;
END $$

-- Helper procedure to convert google.protobuf.Value from ProtoNumberJSON to ProtoJSON
DROP PROCEDURE IF EXISTS _pb_wkt_value_number_json_to_json $$
CREATE PROCEDURE _pb_wkt_value_number_json_to_json(IN number_json_value JSON, OUT result JSON)
BEGIN
	DECLARE struct_converted_value JSON;
	DECLARE list_converted_value JSON;
	DECLARE uint64_value BIGINT UNSIGNED;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Convert Value to its unwrapped form
	-- Value has oneof fields: null_value(1), number_value(2), string_value(3), bool_value(4), struct_value(5), list_value(6)
	IF JSON_LENGTH(number_json_value) = 0 THEN
		SET result = CAST(NULL AS JSON);
	ELSEIF JSON_CONTAINS_PATH(number_json_value, 'one', '$."1"') THEN
		-- null_value
		SET result = CAST(NULL AS JSON);
	ELSEIF JSON_CONTAINS_PATH(number_json_value, 'one', '$."2"') THEN
		-- number_value
		SET uint64_value = _pb_json_parse_double_as_uint64(JSON_EXTRACT(number_json_value, '$."2"'), TRUE);
		SET result = _pb_convert_double_uint64_to_json(uint64_value);
	ELSEIF JSON_CONTAINS_PATH(number_json_value, 'one', '$."3"') THEN
		-- string_value
		SET result = JSON_EXTRACT(number_json_value, '$."3"');
	ELSEIF JSON_CONTAINS_PATH(number_json_value, 'one', '$."4"') THEN
		-- bool_value
		SET result = JSON_EXTRACT(number_json_value, '$."4"');
	ELSEIF JSON_CONTAINS_PATH(number_json_value, 'one', '$."5"') THEN
		-- struct_value - recursively convert
		CALL _pb_wkt_struct_number_json_to_json(JSON_EXTRACT(number_json_value, '$."5"'), struct_converted_value);
		SET result = struct_converted_value;
	ELSEIF JSON_CONTAINS_PATH(number_json_value, 'one', '$."6"') THEN
		-- list_value - recursively convert
		CALL _pb_wkt_list_value_number_json_to_json(JSON_EXTRACT(number_json_value, '$."6"'), list_converted_value);
		SET result = list_converted_value;
	ELSE
		SET result = CAST(NULL AS JSON);
	END IF;
END $$

-- Helper function to convert google.protobuf.Value from ProtoNumberJSON to ProtoJSON (function wrapper)
DROP FUNCTION IF EXISTS _pb_wkt_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wkt_value_number_json_to_json(number_json_value, result);
	RETURN result;
END $$

-- Helper procedure to convert google.protobuf.Struct from ProtoNumberJSON to ProtoJSON
DROP PROCEDURE IF EXISTS _pb_wkt_struct_number_json_to_json $$
CREATE PROCEDURE _pb_wkt_struct_number_json_to_json(IN number_json_value JSON, OUT result JSON)
BEGIN
	DECLARE struct_fields JSON;
	DECLARE struct_keys JSON;
	DECLARE struct_key_count INT;
	DECLARE struct_key_index INT;
	DECLARE struct_key_name TEXT;
	DECLARE struct_value_json JSON;
	DECLARE struct_converted_value JSON;
	DECLARE struct_result JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Convert Struct {"1": {field_map}} to {key: value, key: value}
	SET struct_fields = JSON_EXTRACT(number_json_value, '$."1"');
	IF struct_fields IS NULL OR JSON_LENGTH(struct_fields) = 0 THEN
		SET result = JSON_OBJECT();
	ELSE
		SET struct_keys = JSON_KEYS(struct_fields);
		SET struct_key_count = JSON_LENGTH(struct_keys);
		SET struct_key_index = 0;
		SET struct_result = JSON_OBJECT();

		struct_loop: WHILE struct_key_index < struct_key_count DO
			SET struct_key_name = JSON_UNQUOTE(JSON_EXTRACT(struct_keys, CONCAT('$[', struct_key_index, ']')));
			SET struct_value_json = JSON_EXTRACT(struct_fields, CONCAT('$."', struct_key_name, '"'));
			-- Recursively convert the Value
			CALL _pb_wkt_value_number_json_to_json(struct_value_json, struct_converted_value);
			SET struct_result = JSON_SET(struct_result, CONCAT('$.', struct_key_name), struct_converted_value);
			SET struct_key_index = struct_key_index + 1;
		END WHILE struct_loop;

		SET result = struct_result;
	END IF;
END $$

-- Helper function to convert google.protobuf.Struct from ProtoNumberJSON to ProtoJSON (function wrapper)
DROP FUNCTION IF EXISTS _pb_wkt_struct_number_json_to_json $$
CREATE FUNCTION _pb_wkt_struct_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wkt_struct_number_json_to_json(number_json_value, result);
	RETURN result;
END $$

-- Helper procedure to convert google.protobuf.ListValue from ProtoNumberJSON to ProtoJSON
DROP PROCEDURE IF EXISTS _pb_wkt_list_value_number_json_to_json $$
CREATE PROCEDURE _pb_wkt_list_value_number_json_to_json(IN number_json_value JSON, OUT result JSON)
BEGIN
	DECLARE list_values JSON;
	DECLARE list_length INT;
	DECLARE list_index INT;
	DECLARE list_element_json JSON;
	DECLARE list_converted_value JSON;
	DECLARE list_result JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Convert ListValue {"1": [values]} to [value, value, value]
	SET list_values = JSON_EXTRACT(number_json_value, '$."1"');
	IF list_values IS NULL OR JSON_LENGTH(list_values) = 0 THEN
		SET result = JSON_ARRAY();
	ELSE
		SET list_length = JSON_LENGTH(list_values);
		SET list_index = 0;
		SET list_result = JSON_ARRAY();

		list_loop: WHILE list_index < list_length DO
			SET list_element_json = JSON_EXTRACT(list_values, CONCAT('$[', list_index, ']'));
			-- Recursively convert the Value
			CALL _pb_wkt_value_number_json_to_json(list_element_json, list_converted_value);
			SET list_result = JSON_ARRAY_APPEND(list_result, '$', list_converted_value);
			SET list_index = list_index + 1;
		END WHILE list_loop;

		SET result = list_result;
	END IF;
END $$

-- Helper function to convert google.protobuf.ListValue from ProtoNumberJSON to ProtoJSON (function wrapper)
DROP FUNCTION IF EXISTS _pb_wkt_list_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_list_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wkt_list_value_number_json_to_json(number_json_value, result);
	RETURN result;
END $$

DELIMITER $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_field_mask_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_field_mask_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE result TEXT;
	DECLARE string_value TEXT;
	DECLARE sep TEXT;

	SET result = '';
	SET sep = '';

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 2 THEN -- LEN
			SET string_value = CONVERT(FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v'))) USING utf8mb4);
			CASE field_number
			WHEN 1 THEN -- values
				-- Convert snake_case proto field path to camelCase JSON path with validation
				SET result = CONCAT(result, sep, _pb_util_snake_to_camel_safe(string_value));
				SET sep = ',';
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN JSON_QUOTE(result);
END $$

-- Helper function to convert FieldMask string to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_field_mask_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_field_mask_as_wire_json(field_mask_str TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE comma_pos INT;
	DECLARE path TEXT;
	DECLARE remaining TEXT;

	SET result = JSON_OBJECT();
	SET remaining = field_mask_str;

	WHILE remaining IS NOT NULL AND LENGTH(remaining) > 0 DO
		SET comma_pos = LOCATE(',', remaining);
		IF comma_pos > 0 THEN
			SET path = TRIM(LEFT(remaining, comma_pos - 1));
			SET remaining = SUBSTRING(remaining, comma_pos + 1);
		ELSE
			SET path = TRIM(remaining);
			SET remaining = NULL;
		END IF;

		IF LENGTH(path) > 0 THEN
			-- Validate that path is valid camelCase (no underscores allowed in JSON FieldMask)
			IF NOT _pb_util_is_camel(path) THEN
				SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'FieldMask path contains invalid characters in JSON format';
			END IF;
			-- Convert camelCase JSON field path to snake_case proto path
			-- Use add_repeated_string_field_element for repeated field
			SET result = pb_wire_json_add_repeated_string_field_element(result, 1, _pb_util_camel_to_snake(path));
		END IF;
	END WHILE;

	RETURN result;
END $$

-- Convert FieldMask JSON to number JSON format
DROP FUNCTION IF EXISTS _pb_wkt_field_mask_json_to_number_json $$
CREATE FUNCTION _pb_wkt_field_mask_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE field_mask_str TEXT;
	DECLARE paths_array JSON;
	DECLARE comma_pos INT;
	DECLARE current_path TEXT;
	DECLARE remaining_str TEXT;

	-- Convert comma-separated string to paths array
	-- "path1,path2" -> {"1": ["path1", "path2"]}

	SET field_mask_str = JSON_UNQUOTE(proto_json_value);
	IF field_mask_str = '' THEN
		RETURN JSON_OBJECT();
	END IF;

	-- Split comma-separated string into array
	SET paths_array = JSON_ARRAY();
	-- Simple implementation: split by comma and add each path
	-- Note: This is a simplified implementation
	SET remaining_str = field_mask_str;

	split_loop: WHILE LENGTH(remaining_str) > 0 DO
		SET comma_pos = LOCATE(',', remaining_str);
		IF comma_pos > 0 THEN
			SET current_path = TRIM(LEFT(remaining_str, comma_pos - 1));
			SET remaining_str = TRIM(SUBSTRING(remaining_str, comma_pos + 1));
		ELSE
			SET current_path = TRIM(remaining_str);
			SET remaining_str = '';
		END IF;

		IF LENGTH(current_path) > 0 THEN
			-- Validate that path is valid camelCase (no underscores allowed in JSON FieldMask)
			IF NOT _pb_util_is_camel(current_path) THEN
				SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = 'FieldMask path contains invalid characters in JSON format';
			END IF;
			-- Convert camelCase JSON field path to snake_case proto path
			SET paths_array = JSON_ARRAY_APPEND(paths_array, '$', _pb_util_camel_to_snake(current_path));
		END IF;
	END WHILE split_loop;

	RETURN JSON_OBJECT('1', paths_array);
END $$

-- Convert FieldMask from number JSON format to JSON format
-- Extracts from number-json-to-json.sql and applies proper snake_to_camel conversion
DROP FUNCTION IF EXISTS _pb_wkt_field_mask_number_json_to_json $$
CREATE FUNCTION _pb_wkt_field_mask_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE paths_array JSON;
	DECLARE path_count INT;
	DECLARE path_index INT;
	DECLARE current_path TEXT;
	DECLARE result_str TEXT;

	-- Convert {"1": ["path1", "path2"]} to "camelPath1,camelPath2"
	SET paths_array = JSON_EXTRACT(number_json_value, '$.\"1\"');
	IF paths_array IS NULL OR JSON_LENGTH(paths_array) = 0 THEN
		RETURN JSON_QUOTE('');
	ELSE
		SET path_count = JSON_LENGTH(paths_array);
		SET path_index = 0;
		SET result_str = '';

		path_loop: WHILE path_index < path_count DO
			SET current_path = JSON_UNQUOTE(JSON_EXTRACT(paths_array, CONCAT('$[', path_index, ']')));
			IF path_index > 0 THEN
				SET result_str = CONCAT(result_str, ',');
			END IF;
			-- Convert snake_case proto field path to camelCase JSON path with validation
			SET result_str = CONCAT(result_str, _pb_util_snake_to_camel_safe(current_path));
			SET path_index = path_index + 1;
		END WHILE path_loop;

		RETURN JSON_QUOTE(result_str);
	END IF;
END $$

DELIMITER $$

DROP FUNCTION IF EXISTS _pb_wkt_time_common_format_fractional_seconds $$
CREATE FUNCTION _pb_wkt_time_common_format_fractional_seconds(nanos INT) RETURNS TEXT DETERMINISTIC
BEGIN
	-- Validate that nanos is within [0, 999999999] range
	-- Caller must ensure proper normalization before calling this function
	IF nanos < 0 OR nanos > 999999999 THEN
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = '_pb_wkt_time_common_format_fractional_seconds: nanos must be in range [0, 999999999]';
	END IF;

	IF nanos = 0 THEN
		RETURN '';
	END IF;

	IF nanos % 1000000 = 0 THEN
		RETURN CONCAT('.', LPAD(CAST(nanos DIV 1000000 AS CHAR), 3, '0')); -- 3 digits
	ELSEIF nanos % 1000 = 0 THEN
		RETURN CONCAT('.', LPAD(CAST(nanos DIV 1000 AS CHAR), 6, '0')); -- 6 digits
	ELSE
		RETURN CONCAT('.', LPAD(CAST(nanos AS CHAR), 9, '0')); -- 9 digits
	END IF;
END $$

DELIMITER $$

-- Helper function to convert google.protobuf.Any from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_any_number_json_to_json $$
CREATE FUNCTION _pb_wkt_any_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE type_url TEXT;
	DECLARE any_data TEXT;

	-- {"1": "url", "2": "base64data"} -> {"@type": "url", "field": "value"}
	-- This is simplified - real Any handling is more complex
	SET type_url = JSON_UNQUOTE(JSON_EXTRACT(number_json_value, '$."1"'));
	SET any_data = JSON_UNQUOTE(JSON_EXTRACT(number_json_value, '$."2"'));
	-- Convert base64 data back to object (simplified)
	RETURN JSON_OBJECT('@type', type_url);
	-- In reality, we would decode the base64 data and merge it
END $$

DROP FUNCTION IF EXISTS _pb_wkt_any_json_to_number_json $$
CREATE FUNCTION _pb_wkt_any_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE type_url TEXT;
	DECLARE remaining_object JSON;

	-- {"@type": "url", "field": "value"} -> {"1": "url", "2": "base64data"}
	-- This is simplified - real Any handling is more complex
	SET type_url = JSON_UNQUOTE(JSON_EXTRACT(proto_json_value, '$."@type"'));
	SET remaining_object = JSON_REMOVE(proto_json_value, '$."@type"');

	-- Convert remaining object to base64-encoded bytes (simplified)
	RETURN JSON_OBJECT('1', type_url, '2', TO_BASE64(remaining_object));
END $$
DELIMITER $$

DROP FUNCTION IF EXISTS _pb_wkt_empty_json_to_number_json $$
CREATE FUNCTION _pb_wkt_empty_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- Empty always returns an empty JSON object regardless of input
	RETURN JSON_OBJECT();
END $$

-- Helper function to convert Empty from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_empty_number_json_to_json $$
CREATE FUNCTION _pb_wkt_empty_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- Empty object stays empty
	RETURN JSON_OBJECT();
END $$
DELIMITER $$

DROP FUNCTION IF EXISTS _pb_wkt_int64_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_int64_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE int64_val BIGINT;

	IF proto_json_value IS NULL THEN
		SET int64_val = 0;
	ELSE
		SET int64_val = _pb_json_parse_signed_int(proto_json_value);
	END IF;

	IF int64_val != 0 THEN
		RETURN JSON_OBJECT('1', int64_val);
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_uint64_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_uint64_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE uint64_val BIGINT UNSIGNED;

	IF proto_json_value IS NULL THEN
		SET uint64_val = 0;
	ELSE
		SET uint64_val = _pb_json_parse_unsigned_int(proto_json_value);
	END IF;

	IF uint64_val != 0 THEN
		RETURN JSON_OBJECT('1', uint64_val);
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_int32_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_int32_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE int32_val INT;

	IF proto_json_value IS NULL THEN
		SET int32_val = 0;
	ELSE
		SET int32_val = _pb_json_parse_signed_int(proto_json_value);
	END IF;

	IF int32_val != 0 THEN
		RETURN JSON_OBJECT('1', int32_val);
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_uint32_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_uint32_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE uint32_val INT UNSIGNED;

	IF proto_json_value IS NULL THEN
		SET uint32_val = 0;
	ELSE
		SET uint32_val = _pb_json_parse_unsigned_int(proto_json_value);
	END IF;

	IF uint32_val != 0 THEN
		RETURN JSON_OBJECT('1', uint32_val);
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_float_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_float_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE uint32_value INT UNSIGNED;

	IF proto_json_value IS NULL THEN
		SET uint32_value = 0;
	ELSE
		SET uint32_value = _pb_json_parse_float_as_uint32(proto_json_value, FALSE);
	END IF;

	IF uint32_value <> 0 THEN
		RETURN JSON_OBJECT('1', _pb_convert_float_uint32_to_number_json(uint32_value));
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_double_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_double_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE uint64_value BIGINT UNSIGNED;

	IF proto_json_value IS NULL THEN
		SET uint64_value = 0;
	ELSE
		SET uint64_value = _pb_json_parse_double_as_uint64(proto_json_value, FALSE);
	END IF;

	IF uint64_value <> 0 THEN
		RETURN JSON_OBJECT('1', _pb_convert_double_uint64_to_number_json(uint64_value));
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_bytes_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_bytes_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;
	DECLARE bytes_val LONGBLOB;

	IF proto_json_value IS NULL THEN
		SET str_value = '';
	ELSE
		SET str_value = JSON_UNQUOTE(proto_json_value);
	END IF;

	IF str_value != '' THEN
		-- Use the parsing function to decode and get standard Base64
		SET bytes_val = _pb_json_parse_bytes(proto_json_value);
		RETURN JSON_OBJECT('1', TO_BASE64(bytes_val));
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_bool_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_bool_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE bool_val BOOLEAN;

	IF proto_json_value IS NULL THEN
		SET bool_val = FALSE;
	ELSE
		SET bool_val = _pb_json_parse_bool(proto_json_value);
	END IF;

	IF bool_val THEN
		RETURN JSON_OBJECT('1', CAST('true' AS JSON));
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_string_value_json_to_number_json $$
CREATE FUNCTION _pb_wkt_string_value_json_to_number_json(proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;

	IF proto_json_value IS NULL THEN
		SET str_value = '';
	ELSE
		SET str_value = JSON_UNQUOTE(proto_json_value);
	END IF;

	IF str_value != '' THEN
		RETURN JSON_OBJECT('1', proto_json_value);
	ELSE
		RETURN JSON_OBJECT();
	END IF;
END $$

-- Helper function to convert StringValue from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_string_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_string_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- {"1": "value"} becomes unwrapped "value", {} becomes ""
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN JSON_QUOTE('');
	ELSE
		RETURN JSON_EXTRACT(number_json_value, '$."1"');
	END IF;
END $$

-- Helper function to convert Int64Value from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_int64_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_int64_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE wrapped_value JSON;
	-- {"1": value} becomes unwrapped "value" (as string for 64-bit), {} becomes "0"
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN JSON_QUOTE('0');
	ELSE
		SET wrapped_value = JSON_EXTRACT(number_json_value, '$."1"');
		RETURN JSON_QUOTE(CAST(wrapped_value AS CHAR));
	END IF;
END $$

-- Helper function to convert UInt64Value from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_uint64_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_uint64_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE wrapped_value JSON;
	-- {"1": value} becomes unwrapped "value" (as string for 64-bit), {} becomes "0"
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN JSON_QUOTE('0');
	ELSE
		SET wrapped_value = JSON_EXTRACT(number_json_value, '$."1"');
		RETURN JSON_QUOTE(CAST(wrapped_value AS CHAR));
	END IF;
END $$

-- Helper function to convert Int32Value from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_int32_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_int32_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- {"1": value} becomes unwrapped value (as number for 32-bit), {} becomes 0
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN CAST(0 AS JSON);
	ELSE
		RETURN JSON_EXTRACT(number_json_value, '$."1"');
	END IF;
END $$

-- Helper function to convert UInt32Value from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_uint32_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_uint32_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- {"1": value} becomes unwrapped value (as number for 32-bit), {} becomes 0
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN CAST(0 AS JSON);
	ELSE
		RETURN JSON_EXTRACT(number_json_value, '$."1"');
	END IF;
END $$

-- Helper function to convert BoolValue from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_bool_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_bool_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- {"1": value} becomes unwrapped value, {} becomes false
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN CAST(false AS JSON);
	ELSE
		RETURN JSON_EXTRACT(number_json_value, '$."1"');
	END IF;
END $$

-- Helper function to convert FloatValue from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_float_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_float_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE field_value JSON;
	DECLARE uint32_value INT UNSIGNED;

	-- {"1": value} becomes unwrapped value, {} becomes 0.0
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN CAST(0.0 AS JSON);
	ELSE
		SET field_value = JSON_EXTRACT(number_json_value, '$."1"');
		-- Parse the field value (which may be in binary32 format) and convert to uint32
		SET uint32_value = _pb_json_parse_float_as_uint32(field_value, TRUE);
		-- Convert uint32 to proper JSON representation
		RETURN _pb_convert_float_uint32_to_json(uint32_value);
	END IF;
END $$

-- Helper function to convert DoubleValue from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_double_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_double_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE field_value JSON;
	DECLARE uint64_value BIGINT UNSIGNED;

	-- {"1": value} becomes unwrapped value, {} becomes 0.0
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN CAST(0.0 AS JSON);
	ELSE
		SET field_value = JSON_EXTRACT(number_json_value, '$."1"');
		-- Parse the field value (which may be in binary64 format) and convert to uint64
		SET uint64_value = _pb_json_parse_double_as_uint64(field_value, TRUE);
		-- Convert uint64 to proper JSON representation
		RETURN _pb_convert_double_uint64_to_json(uint64_value);
	END IF;
END $$

-- Helper function to convert BytesValue from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_wkt_bytes_value_number_json_to_json $$
CREATE FUNCTION _pb_wkt_bytes_value_number_json_to_json(number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	-- {"1": "value"} becomes unwrapped "value", {} becomes ""
	IF JSON_LENGTH(number_json_value) = 0 THEN
		RETURN JSON_QUOTE('');
	ELSE
		RETURN JSON_EXTRACT(number_json_value, '$."1"');
	END IF;
END $$

DELIMITER $$

-- Helper function to get the appropriate descriptor set for Google well-known types
DROP FUNCTION IF EXISTS _pb_wkt_get_descriptor_set $$
CREATE FUNCTION _pb_wkt_get_descriptor_set(full_type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	-- For Google well-known types, use built-in descriptor functions
	CASE
	WHEN full_type_name IN ('.google.protobuf.Struct', '.google.protobuf.Value', '.google.protobuf.ListValue', '.google.protobuf.NullValue') THEN
		RETURN _pb_wkt_struct_proto();
	WHEN full_type_name = '.google.protobuf.FieldMask' THEN
		RETURN _pb_wkt_field_mask_proto();
	WHEN full_type_name IN ('.google.protobuf.DoubleValue', '.google.protobuf.FloatValue', '.google.protobuf.Int64Value', '.google.protobuf.UInt64Value', '.google.protobuf.Int32Value', '.google.protobuf.UInt32Value', '.google.protobuf.BoolValue', '.google.protobuf.StringValue', '.google.protobuf.BytesValue') THEN
		RETURN _pb_wkt_wrappers_proto();
	WHEN full_type_name = '.google.protobuf.Empty' THEN
		RETURN _pb_wkt_empty_proto();
	WHEN full_type_name = '.google.protobuf.Any' THEN
		RETURN _pb_wkt_any_proto();
	WHEN full_type_name = '.google.protobuf.Timestamp' THEN
		RETURN _pb_wkt_timestamp_proto();
	WHEN full_type_name = '.google.protobuf.Duration' THEN
		RETURN _pb_wkt_duration_proto();
	ELSE
		-- Return NULL for types that don't match or should use regular WKT handling
		RETURN NULL;
	END CASE;
END $$

-- Helper function to convert well-known type from ProtoJSON to ProtoNumberJSON
DROP FUNCTION IF EXISTS _pb_convert_json_wkt_to_number_json $$
CREATE FUNCTION _pb_convert_json_wkt_to_number_json(field_type INT, full_type_name TEXT, proto_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	CASE field_type
	WHEN 14 THEN -- enum
		CASE full_type_name
		WHEN '.google.protobuf.NullValue' THEN
			RETURN CAST(_pb_wkt_null_value_json_to_number_json(proto_json_value) AS JSON);
		ELSE
			RETURN NULL;
		END CASE;
	WHEN 11 THEN -- message
		CASE full_type_name
		WHEN '.google.protobuf.Timestamp' THEN
			RETURN _pb_wkt_timestamp_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Duration' THEN
			RETURN _pb_wkt_duration_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.FieldMask' THEN
			RETURN _pb_wkt_field_mask_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Value' THEN
			RETURN _pb_wkt_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Struct' THEN
			RETURN _pb_wkt_struct_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.ListValue' THEN
			RETURN _pb_wkt_list_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.StringValue' THEN
			RETURN _pb_wkt_string_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Int64Value' THEN
			RETURN _pb_wkt_int64_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.UInt64Value' THEN
			RETURN _pb_wkt_uint64_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Int32Value' THEN
			RETURN _pb_wkt_int32_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.UInt32Value' THEN
			RETURN _pb_wkt_uint32_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.BoolValue' THEN
			RETURN _pb_wkt_bool_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.FloatValue' THEN
			RETURN _pb_wkt_float_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.DoubleValue' THEN
			RETURN _pb_wkt_double_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.BytesValue' THEN
			RETURN _pb_wkt_bytes_value_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Empty' THEN
			RETURN _pb_wkt_empty_json_to_number_json(proto_json_value);
		WHEN '.google.protobuf.Any' THEN
			RETURN _pb_wkt_any_json_to_number_json(proto_json_value);
		ELSE
			RETURN NULL;
		END CASE;
	END CASE;
END $$

-- Helper function to convert well-known type from ProtoNumberJSON to ProtoJSON
DROP FUNCTION IF EXISTS _pb_convert_number_json_to_wkt $$
CREATE FUNCTION _pb_convert_number_json_to_wkt(field_type INT, full_type_name TEXT, number_json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	CASE field_type
	WHEN 14 THEN -- enum
		CASE full_type_name
		WHEN '.google.protobuf.NullValue' THEN
			RETURN _pb_wkt_null_value_number_json_to_json(number_json_value);
		ELSE
			RETURN NULL;
		END CASE;
	WHEN 11 THEN -- message
		CASE full_type_name
		WHEN '.google.protobuf.Timestamp' THEN
			RETURN _pb_wkt_timestamp_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Duration' THEN
			RETURN _pb_wkt_duration_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.StringValue' THEN
			RETURN _pb_wkt_string_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Int64Value' THEN
			RETURN _pb_wkt_int64_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.UInt64Value' THEN
			RETURN _pb_wkt_uint64_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Int32Value' THEN
			RETURN _pb_wkt_int32_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.UInt32Value' THEN
			RETURN _pb_wkt_uint32_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.BoolValue' THEN
			RETURN _pb_wkt_bool_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.FloatValue' THEN
			RETURN _pb_wkt_float_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.DoubleValue' THEN
			RETURN _pb_wkt_double_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.BytesValue' THEN
			RETURN _pb_wkt_bytes_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Empty' THEN
			RETURN _pb_wkt_empty_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Value' THEN
			RETURN _pb_wkt_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Struct' THEN
			RETURN _pb_wkt_struct_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.ListValue' THEN
			RETURN _pb_wkt_list_value_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.FieldMask' THEN
			RETURN _pb_wkt_field_mask_number_json_to_json(number_json_value);
		WHEN '.google.protobuf.Any' THEN
			RETURN _pb_wkt_any_number_json_to_json(number_json_value);
		ELSE
			RETURN NULL;
		END CASE;
	END CASE;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_as_json(wire_json JSON, full_type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	CASE full_type_name
	WHEN '.google.protobuf.Timestamp' THEN
		RETURN _pb_wire_json_decode_wkt_timestamp_as_json(wire_json);
	WHEN '.google.protobuf.Duration' THEN
		RETURN _pb_wire_json_decode_wkt_duration_as_json(wire_json);
	WHEN '.google.protobuf.Struct' THEN
		RETURN _pb_wire_json_decode_wkt_struct_as_json(wire_json);
	WHEN '.google.protobuf.Value' THEN
		RETURN _pb_wire_json_decode_wkt_value_as_json(wire_json);
	WHEN '.google.protobuf.ListValue' THEN
		RETURN _pb_wire_json_decode_wkt_list_value_as_json(wire_json);
	WHEN '.google.protobuf.Empty' THEN
		RETURN JSON_OBJECT();
	WHEN '.google.protobuf.DoubleValue' THEN
		RETURN CAST(pb_wire_json_get_double_field(wire_json, 1, 0.0) AS JSON);
	WHEN '.google.protobuf.FloatValue' THEN
		RETURN CAST(pb_wire_json_get_float_field(wire_json, 1, 0.0) AS JSON);
	WHEN '.google.protobuf.Int64Value' THEN
		RETURN JSON_QUOTE(CAST(pb_wire_json_get_int64_field(wire_json, 1, 0) AS CHAR));
	WHEN '.google.protobuf.UInt64Value' THEN
		RETURN JSON_QUOTE(CAST(pb_wire_json_get_uint64_field(wire_json, 1, 0) AS CHAR));
	WHEN '.google.protobuf.Int32Value' THEN
		RETURN CAST(pb_wire_json_get_int32_field(wire_json, 1, 0) AS JSON);
	WHEN '.google.protobuf.UInt32Value' THEN
		RETURN CAST(pb_wire_json_get_uint32_field(wire_json, 1, 0) AS JSON);
	WHEN '.google.protobuf.BoolValue' THEN
		RETURN CAST((pb_wire_json_get_bool_field(wire_json, 1, FALSE) IS TRUE) AS JSON);
	WHEN '.google.protobuf.StringValue' THEN
		RETURN JSON_QUOTE(pb_wire_json_get_string_field(wire_json, 1, ''));
	WHEN '.google.protobuf.BytesValue' THEN
		RETURN JSON_QUOTE(TO_BASE64(pb_wire_json_get_bytes_field(wire_json, 1, _binary X'')));
	WHEN '.google.protobuf.FieldMask' THEN
		RETURN _pb_wire_json_decode_wkt_field_mask_as_json(wire_json);
	ELSE
		RETURN NULL;
	END CASE;
END $$

-- Helper function to encode well-known types from JSON to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_as_wire_json(json_value JSON, full_type_name TEXT, from_number_json BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE float_value FLOAT;
	DECLARE double_value DOUBLE;
	DECLARE uint32_value INT UNSIGNED;
	DECLARE uint64_value BIGINT UNSIGNED;

	CASE full_type_name
	WHEN '.google.protobuf.Timestamp' THEN
		-- Parse RFC 3339 timestamp string like "1996-12-19T16:39:57.000340012Z"
		IF JSON_TYPE(json_value) = 'NULL' THEN
			-- Null timestamp should not produce any field in protobuf
			RETURN NULL;
		ELSEIF JSON_TYPE(json_value) = 'STRING' THEN
			RETURN _pb_json_encode_wkt_timestamp_as_wire_json(JSON_UNQUOTE(json_value));
		END IF;

	WHEN '.google.protobuf.Duration' THEN
		-- Parse duration string like "1.000340012s" or "3600s"
		IF JSON_TYPE(json_value) = 'NULL' THEN
			-- Null duration should not produce any field in protobuf
			RETURN NULL;
		ELSEIF JSON_TYPE(json_value) = 'STRING' THEN
			RETURN _pb_json_encode_wkt_duration_as_wire_json(JSON_UNQUOTE(json_value));
		END IF;

	WHEN '.google.protobuf.FieldMask' THEN
		-- Parse comma-separated field names like "path1,path2"
		IF JSON_TYPE(json_value) = 'STRING' THEN
			RETURN _pb_json_encode_wkt_field_mask_as_wire_json(JSON_UNQUOTE(json_value));
		END IF;

	WHEN '.google.protobuf.Empty' THEN
		-- Always return empty wire_json
		RETURN JSON_OBJECT();

	WHEN '.google.protobuf.Struct' THEN
		-- For number JSON format, use regular descriptor-based processing
		IF from_number_json THEN
			RETURN NULL;
		END IF;
		-- Convert JSON object to Struct with repeated fields map
		CALL _pb_json_encode_wkt_struct_as_wire_json(json_value, from_number_json, result);
		IF result IS NOT NULL THEN
			RETURN result;
		END IF;

	WHEN '.google.protobuf.Value' THEN
		-- For number JSON format, use regular descriptor-based processing
		IF from_number_json THEN
			RETURN NULL;
		END IF;
		-- Handle different JSON value types
		CALL _pb_json_encode_wkt_value_as_wire_json(json_value, from_number_json, result);
		IF result IS NOT NULL THEN
			RETURN result;
		END IF;

	WHEN '.google.protobuf.ListValue' THEN
		-- For number JSON format, use regular descriptor-based processing
		IF from_number_json THEN
			RETURN NULL;
		END IF;
		-- Convert JSON array to ListValue with repeated Value fields
		CALL _pb_json_encode_wkt_list_value_as_wire_json(json_value, from_number_json, result);
		IF result IS NOT NULL THEN
			RETURN result;
		END IF;

	-- Wrapper types
	WHEN '.google.protobuf.Int32Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_signed_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_int32_field(result, 1, _pb_json_to_signed_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.UInt32Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_unsigned_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_uint32_field(result, 1, _pb_json_to_unsigned_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.Int64Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_signed_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_int64_field(result, 1, _pb_json_to_signed_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.UInt64Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_unsigned_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_uint64_field(result, 1, _pb_json_to_unsigned_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.FloatValue' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'DOUBLE', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Use parsing function with appropriate hex string support
			SET uint32_value = _pb_json_parse_float_as_uint32(json_value, from_number_json);
			-- Only encode non-default values (proto3 behavior)
			IF uint32_value <> 0 THEN
				-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
				SET result = pb_wire_json_set_fixed32_field(result, 1, uint32_value);
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.DoubleValue' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'DOUBLE', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Use parsing function with appropriate hex string support
			SET uint64_value = _pb_json_parse_double_as_uint64(json_value, from_number_json);
			-- Only encode non-default values (proto3 behavior)
			IF uint64_value <> 0 THEN
				-- TODO: This is a workaround and should be replaced with generated code by @cmd/protobuf-accessors/
				SET result = pb_wire_json_set_fixed64_field(result, 1, uint64_value);
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.BoolValue' THEN
		IF JSON_TYPE(json_value) = 'BOOLEAN' THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF json_value THEN
				SET result = pb_wire_json_set_bool_field(result, 1, TRUE);
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.StringValue' THEN
		IF JSON_TYPE(json_value) = 'STRING' THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF JSON_UNQUOTE(json_value) <> '' THEN
				SET result = pb_wire_json_set_string_field(result, 1, JSON_UNQUOTE(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.BytesValue' THEN
		IF JSON_TYPE(json_value) = 'STRING' THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF JSON_UNQUOTE(json_value) <> '' THEN
				SET result = pb_wire_json_set_bytes_field(result, 1, _pb_util_from_base64_url(JSON_UNQUOTE(json_value)));
			END IF;
			RETURN result;
		END IF;
	END CASE;

	-- Return NULL to fall back to normal message handling
	RETURN NULL;
END $$

DELIMITER $$

-- Convert snake_case to camelCase
-- Implements logic from protobuf-go JSONCamelCase:
-- https://github.com/protocolbuffers/protobuf-go/blob/v1.28.1/internal/strs/strings.go
DROP FUNCTION IF EXISTS _pb_util_snake_to_camel $$
CREATE FUNCTION _pb_util_snake_to_camel(snake_name TEXT) RETURNS TEXT DETERMINISTIC
BEGIN
	DECLARE result TEXT DEFAULT '';
	DECLARE i INT DEFAULT 1;
	DECLARE char_val BINARY(1);
	DECLARE was_underscore BOOLEAN DEFAULT FALSE;
	DECLARE binary_name LONGBLOB;

	-- Handle empty or null input
	IF snake_name IS NULL OR LENGTH(snake_name) = 0 THEN
		RETURN snake_name;
	END IF;

	-- Cast to binary for proper character comparisons
	SET binary_name = CAST(snake_name AS BINARY);

	-- Process character by character (proto identifiers are always ASCII)
	WHILE i <= LENGTH(binary_name) DO
		SET char_val = SUBSTRING(binary_name, i, 1);

		IF char_val != _binary '_' THEN
			IF was_underscore AND (char_val >= _binary 'a' AND char_val <= _binary 'z') THEN
				-- Convert lowercase to uppercase after underscore
				SET result = CONCAT(result, UPPER(CONVERT(char_val USING utf8mb4)));
			ELSE
				-- Keep character as-is
				SET result = CONCAT(result, CONVERT(char_val USING utf8mb4));
			END IF;
		END IF;

		SET was_underscore = (char_val = _binary '_');
		SET i = i + 1;
	END WHILE;

	RETURN result;
END $$

-- Convert camelCase to snake_case
-- Implements logic from protobuf-go JSONSnakeCase:
-- https://github.com/protocolbuffers/protobuf-go/blob/v1.28.1/internal/strs/strings.go
DROP FUNCTION IF EXISTS _pb_util_camel_to_snake $$
CREATE FUNCTION _pb_util_camel_to_snake(camel_name TEXT) RETURNS TEXT DETERMINISTIC
BEGIN
	DECLARE result TEXT DEFAULT '';
	DECLARE i INT DEFAULT 1;
	DECLARE char_val BINARY(1);
	DECLARE binary_name LONGBLOB;

	-- Handle empty or null input
	IF camel_name IS NULL OR LENGTH(camel_name) = 0 THEN
		RETURN camel_name;
	END IF;

	-- Cast to binary for proper character comparisons
	SET binary_name = CAST(camel_name AS BINARY);

	-- Process character by character (proto identifiers are always ASCII)
	WHILE i <= LENGTH(binary_name) DO
		SET char_val = SUBSTRING(binary_name, i, 1);

		IF char_val >= _binary 'A' AND char_val <= _binary 'Z' THEN
			-- Add underscore before uppercase letter, then convert to lowercase
			SET result = CONCAT(result, '_', LOWER(CONVERT(char_val USING utf8mb4)));
		ELSE
			-- Keep character as-is
			SET result = CONCAT(result, CONVERT(char_val USING utf8mb4));
		END IF;

		SET i = i + 1;
	END WHILE;

	RETURN result;
END $$

-- Safe snake_case to camelCase conversion with round-trip validation
-- Matches protobuf-go's marshalFieldMask validation logic
DROP FUNCTION IF EXISTS _pb_util_snake_to_camel_safe $$
CREATE FUNCTION _pb_util_snake_to_camel_safe(snake_name TEXT) RETURNS TEXT DETERMINISTIC
BEGIN
	DECLARE camel_name TEXT;
	DECLARE roundtrip_name TEXT;
	DECLARE message_text TEXT;

	-- Convert snake_case to camelCase
	SET camel_name = _pb_util_snake_to_camel(snake_name);

	-- Round-trip validation: snakecamelsnake should equal original
	SET roundtrip_name = _pb_util_camel_to_snake(camel_name);

	IF snake_name != roundtrip_name THEN
		-- Contains irreversible value, fail like protobuf-go
		SET message_text = CONCAT('Contains irreversible value "', snake_name, '"');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	RETURN camel_name;
END $$

-- Check if a string is valid camelCase for protobuf identifiers
-- Valid camelCase: only letters and digits, no underscores or special characters
DROP FUNCTION IF EXISTS _pb_util_is_camel $$
CREATE FUNCTION _pb_util_is_camel(input_name TEXT) RETURNS BOOLEAN DETERMINISTIC
BEGIN
	-- Handle empty or null input
	IF input_name IS NULL OR LENGTH(input_name) = 0 THEN
		RETURN TRUE;
	END IF;

	-- Valid camelCase: only letters and digits (no underscores, special characters)
	RETURN input_name REGEXP '^[a-zA-Z0-9]+$';
END $$

DELIMITER $$

-- Decode Base64 encoded string to bytes
-- Supports both standard Base64 (+/) and Base64 URL (-_) encoding
-- Handles input with or without padding as per protobuf JSON spec
DROP FUNCTION IF EXISTS _pb_util_from_base64_url $$
CREATE FUNCTION _pb_util_from_base64_url(encoded_value LONGTEXT) RETURNS LONGBLOB DETERMINISTIC
BEGIN
	DECLARE standard_base64 LONGTEXT;

	-- Handle null/empty input
	IF encoded_value IS NULL OR LENGTH(encoded_value) = 0 THEN
		RETURN encoded_value;
	END IF;

	-- Convert Base64 URL encoding to standard Base64 if needed:
	-- Replace - with + and _ with / (no-op for standard Base64)
	SET standard_base64 = REPLACE(REPLACE(encoded_value, '-', '+'), '_', '/');

	-- Add padding if needed (handles both Base64 URL without padding and standard Base64 without padding)
	-- Base64 strings must be multiples of 4 characters
	WHILE LENGTH(standard_base64) % 4 != 0 DO
		SET standard_base64 = CONCAT(standard_base64, '=');
	END WHILE;

	-- Decode using MySQL's standard FROM_BASE64 function
	RETURN FROM_BASE64(standard_base64);
END $$

DELIMITER ;
DELIMITER $$

-- Helper function to get message descriptor from descriptor set JSON
DROP FUNCTION IF EXISTS _pb_descriptor_set_get_message_descriptor $$
CREATE FUNCTION _pb_descriptor_set_get_message_descriptor(descriptor_set_json JSON, type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE message_type_index JSON;
	DECLARE type_paths JSON;
	DECLARE file_path TEXT;
	DECLARE type_path TEXT;

	-- Get message type index (field 2 from DescriptorSet)
	SET message_type_index = JSON_EXTRACT(descriptor_set_json, '$.\"2\"');

	-- Get paths for the type
	SET type_paths = JSON_EXTRACT(message_type_index, CONCAT('$."', type_name, '"'));

	IF type_paths IS NULL THEN
		RETURN NULL;
	END IF;

	-- Extract file path and type path from MessageTypeIndex message
	SET file_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$.\"1\"'));
	SET type_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$.\"2\"'));

	-- Get FileDescriptorSet (field "1" of DescriptorSet), then apply type_path directly
	RETURN JSON_EXTRACT(JSON_EXTRACT(descriptor_set_json, '$.\"1\"'), type_path);
END $$

-- Helper function to get enum descriptor from descriptor set JSON
DROP FUNCTION IF EXISTS _pb_descriptor_set_get_enum_descriptor $$
CREATE FUNCTION _pb_descriptor_set_get_enum_descriptor(descriptor_set_json JSON, type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE enum_type_index JSON;
	DECLARE type_paths JSON;
	DECLARE file_path TEXT;
	DECLARE type_path TEXT;

	-- Get enum type index (field 3 from DescriptorSet)
	SET enum_type_index = JSON_EXTRACT(descriptor_set_json, '$.\"3\"');

	-- Get paths for the type
	SET type_paths = JSON_EXTRACT(enum_type_index, CONCAT('$."', type_name, '"'));

	IF type_paths IS NULL THEN
		RETURN NULL;
	END IF;

	-- Extract file path and type path from EnumTypeIndex message
	SET file_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$.\"1\"'));
	SET type_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$.\"2\"'));

	-- Get FileDescriptorSet (field "1" of DescriptorSet), then apply type_path directly
	RETURN JSON_EXTRACT(JSON_EXTRACT(descriptor_set_json, '$.\"1\"'), type_path);
END $$


-- Helper function to get file descriptor for a type
DROP FUNCTION IF EXISTS _pb_descriptor_set_get_file_descriptor $$
CREATE FUNCTION _pb_descriptor_set_get_file_descriptor(descriptor_set_json JSON, type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE type_index JSON;
	DECLARE type_paths JSON;
	DECLARE file_path TEXT;

	-- Get type index (field 2 from DescriptorSet)
	SET type_index = JSON_EXTRACT(descriptor_set_json, '$.\"2\"');

	-- Get paths for the type
	SET type_paths = JSON_EXTRACT(type_index, CONCAT('$."', type_name, '"'));

	IF type_paths IS NULL THEN
		RETURN NULL;
	END IF;

	-- Extract file path from MessageTypeIndex message (field "1")
	SET file_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$.\"1\"'));

	-- Get FileDescriptorSet (field "1" of DescriptorSet), then apply file_path
	RETURN JSON_EXTRACT(JSON_EXTRACT(descriptor_set_json, '$.\"1\"'), file_path);
END $$

DELIMITER $$

-- Helper function to build fully-qualified type name
DROP FUNCTION IF EXISTS _pb_build_type_name $$
CREATE FUNCTION _pb_build_type_name(package_name TEXT, type_name TEXT) RETURNS TEXT DETERMINISTIC
BEGIN
	IF package_name = '' OR package_name IS NULL THEN
		RETURN CONCAT('.', type_name);
	ELSE
		RETURN CONCAT('.', package_name, '.', type_name);
	END IF;
END $$

-- Helper procedure to process nested types recursively
DROP PROCEDURE IF EXISTS _pb_build_nested_types $$
CREATE PROCEDURE _pb_build_nested_types(
	IN message_descriptor JSON,
	IN parent_name TEXT,
	IN parent_path TEXT,
	IN file_path TEXT,
	INOUT message_type_index JSON,
	INOUT enum_type_index JSON
)
proc: BEGIN
	DECLARE nested_messages JSON;
	DECLARE nested_enums JSON;
	DECLARE nested_msg_count INT DEFAULT 0;
	DECLARE nested_enum_count INT DEFAULT 0;
	DECLARE nested_msg_index INT DEFAULT 0;
	DECLARE nested_enum_index INT DEFAULT 0;
	DECLARE nested_msg_descriptor JSON;
	DECLARE nested_enum_descriptor JSON;
	DECLARE nested_msg_name TEXT;
	DECLARE nested_enum_name TEXT;
	DECLARE nested_msg_path TEXT;
	DECLARE nested_enum_path TEXT;
	DECLARE nested_type_name TEXT;
	DECLARE type_entry JSON;

	-- Enum indexing variables
	DECLARE enum_name_index JSON;
	DECLARE enum_number_index JSON;
	DECLARE enum_values_array JSON;
	DECLARE enum_value_count INT DEFAULT 0;
	DECLARE enum_value_idx INT DEFAULT 0;
	DECLARE enum_value_desc JSON;
	DECLARE enum_value_name TEXT;
	DECLARE enum_value_number INT;

	-- Nested field indexing variables
	DECLARE nested_field_name_index JSON;
	DECLARE nested_field_number_index JSON;
	DECLARE nested_field_array JSON;
	DECLARE nested_field_count INT DEFAULT 0;
	DECLARE nested_field_idx INT DEFAULT 0;
	DECLARE nested_field_desc JSON;
	DECLARE nested_field_name_val TEXT;
	DECLARE nested_field_number_val INT;

	-- Process nested message types (field 3 in DescriptorProto)
	SET nested_messages = JSON_EXTRACT(message_descriptor, '$."3"');

	IF nested_messages IS NOT NULL THEN
		SET nested_msg_count = JSON_LENGTH(nested_messages);
		SET nested_msg_index = 0;

		WHILE nested_msg_index < nested_msg_count DO
			SET nested_msg_descriptor = JSON_EXTRACT(nested_messages, CONCAT('$[', nested_msg_index, ']'));
			SET nested_msg_name = JSON_UNQUOTE(JSON_EXTRACT(nested_msg_descriptor, '$."1"')); -- name field
			SET nested_msg_path = CONCAT(parent_path, '."3"[', nested_msg_index, ']');
			SET nested_type_name = CONCAT(parent_name, '.', nested_msg_name);

			-- Build field indexes for nested message
			SET nested_field_name_index = JSON_OBJECT();
			SET nested_field_number_index = JSON_OBJECT();
			SET nested_field_array = JSON_EXTRACT(nested_msg_descriptor, '$."2"'); -- field array
			IF nested_field_array IS NOT NULL THEN
				SET nested_field_count = JSON_LENGTH(nested_field_array);
				SET nested_field_idx = 0;
				WHILE nested_field_idx < nested_field_count DO
					SET nested_field_desc = JSON_EXTRACT(nested_field_array, CONCAT('$[', nested_field_idx, ']'));
					SET nested_field_name_val = JSON_UNQUOTE(JSON_EXTRACT(nested_field_desc, '$."1"')); -- name
					SET nested_field_number_val = JSON_EXTRACT(nested_field_desc, '$."3"'); -- number
					IF nested_field_name_val IS NOT NULL THEN
						SET nested_field_name_index = JSON_SET(nested_field_name_index, CONCAT('$."', nested_field_name_val, '"'), nested_field_idx);
					END IF;
					IF nested_field_number_val IS NOT NULL THEN
						SET nested_field_number_index = JSON_SET(nested_field_number_index, CONCAT('$."', nested_field_number_val, '"'), nested_field_idx);
					END IF;
					SET nested_field_idx = nested_field_idx + 1;
				END WHILE;
			END IF;

			-- Add to message type index: MessageTypeIndex format
			SET type_entry = JSON_OBJECT(
				'1', file_path,
				'2', nested_msg_path
			);
			-- Only include field indexes if they're non-empty
			IF JSON_LENGTH(JSON_KEYS(nested_field_name_index)) > 0 THEN
				SET type_entry = JSON_SET(type_entry, '$.\"3\"', nested_field_name_index);
			END IF;
			IF JSON_LENGTH(JSON_KEYS(nested_field_number_index)) > 0 THEN
				SET type_entry = JSON_SET(type_entry, '$.\"4\"', nested_field_number_index);
			END IF;
			SET message_type_index = JSON_SET(message_type_index, CONCAT('$."', nested_type_name, '"'), type_entry);

			-- Recursively process further nested types
			CALL _pb_build_nested_types(nested_msg_descriptor, nested_type_name, nested_msg_path, file_path, message_type_index, enum_type_index);

			SET nested_msg_index = nested_msg_index + 1;
		END WHILE;
	END IF;

	-- Process nested enum types (field 4 in DescriptorProto)
	SET nested_enums = JSON_EXTRACT(message_descriptor, '$."4"');

	IF nested_enums IS NOT NULL THEN
		SET nested_enum_count = JSON_LENGTH(nested_enums);
		SET nested_enum_index = 0;

		WHILE nested_enum_index < nested_enum_count DO
			SET nested_enum_descriptor = JSON_EXTRACT(nested_enums, CONCAT('$[', nested_enum_index, ']'));
			SET nested_enum_name = JSON_UNQUOTE(JSON_EXTRACT(nested_enum_descriptor, '$."1"')); -- name field
			SET nested_enum_path = CONCAT(parent_path, '."4"[', nested_enum_index, ']');
			SET nested_type_name = CONCAT(parent_name, '.', nested_enum_name);

			-- Build enum value indexes
			SET enum_name_index = JSON_OBJECT();
			SET enum_number_index = JSON_OBJECT();
			SET enum_values_array = JSON_EXTRACT(nested_enum_descriptor, '$."2"'); -- value array
			IF enum_values_array IS NOT NULL THEN
				SET enum_value_count = JSON_LENGTH(enum_values_array);
				SET enum_value_idx = 0;
				WHILE enum_value_idx < enum_value_count DO
					SET enum_value_desc = JSON_EXTRACT(enum_values_array, CONCAT('$[', enum_value_idx, ']'));
					SET enum_value_name = JSON_UNQUOTE(JSON_EXTRACT(enum_value_desc, '$."1"')); -- name
					SET enum_value_number = JSON_EXTRACT(enum_value_desc, '$."2"'); -- number
					IF enum_value_name IS NOT NULL THEN
						SET enum_name_index = JSON_SET(enum_name_index, CONCAT('$."', enum_value_name, '"'), enum_value_idx);
					END IF;
					IF enum_value_number IS NOT NULL THEN
						SET enum_number_index = JSON_SET(enum_number_index, CONCAT('$."', enum_value_number, '"'), enum_value_idx);
					END IF;
					SET enum_value_idx = enum_value_idx + 1;
				END WHILE;
			END IF;

			-- Add to enum type index: EnumTypeIndex format
			SET type_entry = JSON_OBJECT(
				'1', file_path,
				'2', nested_enum_path,
				'3', enum_name_index,
				'4', enum_number_index
			);
			SET enum_type_index = JSON_SET(enum_type_index, CONCAT('$."', nested_type_name, '"'), type_entry);

			SET nested_enum_index = nested_enum_index + 1;
		END WHILE;
	END IF;
END $$

-- Public procedure to generate type indexes from FileDescriptorSet in protonumberjson format
DROP PROCEDURE IF EXISTS _pb_build_type_indexes_from_descriptor_set $$
CREATE PROCEDURE _pb_build_type_indexes_from_descriptor_set(
	IN file_descriptor_set_json JSON,
	OUT message_type_index JSON,
	OUT enum_type_index JSON
)
proc: BEGIN
	DECLARE files JSON;
	DECLARE file_count INT DEFAULT 0;
	DECLARE file_index INT DEFAULT 0;
	DECLARE file_descriptor JSON;
	DECLARE file_package TEXT;
	DECLARE file_path TEXT;
	DECLARE message_types JSON;
	DECLARE enum_types JSON;
	DECLARE msg_count INT DEFAULT 0;
	DECLARE enum_count INT DEFAULT 0;
	DECLARE msg_index INT DEFAULT 0;
	DECLARE enum_index INT DEFAULT 0;
	DECLARE message_descriptor JSON;
	DECLARE enum_descriptor JSON;
	DECLARE message_name TEXT;
	DECLARE enum_name TEXT;
	DECLARE message_path TEXT;
	DECLARE enum_path TEXT;
	DECLARE full_type_name TEXT;
	DECLARE type_entry JSON;

	-- Field indexing variables
	DECLARE field_name_index JSON;
	DECLARE field_number_index JSON;
	DECLARE field_array JSON;
	DECLARE field_count INT DEFAULT 0;
	DECLARE field_idx INT DEFAULT 0;
	DECLARE field_desc JSON;
	DECLARE field_name_val TEXT;
	DECLARE field_number_val INT;

	-- Enum indexing variables
	DECLARE enum_name_index JSON;
	DECLARE enum_number_index JSON;
	DECLARE enum_values_array JSON;
	DECLARE enum_value_count INT DEFAULT 0;
	DECLARE enum_value_idx INT DEFAULT 0;
	DECLARE enum_value_desc JSON;
	DECLARE enum_value_name TEXT;
	DECLARE enum_value_number INT;

	-- Initialize indexes
	SET message_type_index = JSON_OBJECT();
	SET enum_type_index = JSON_OBJECT();

	-- Extract files array (field 1 in FileDescriptorSet)
	SET files = JSON_EXTRACT(file_descriptor_set_json, '$."1"');

	IF files IS NULL THEN
		-- Return empty indexes (OUT parameters already initialized)
		LEAVE proc;
	END IF;

	SET file_count = JSON_LENGTH(files);
	SET file_index = 0;

	-- Iterate through each file
	WHILE file_index < file_count DO
		SET file_descriptor = JSON_EXTRACT(files, CONCAT('$[', file_index, ']'));
		SET file_package = COALESCE(JSON_UNQUOTE(JSON_EXTRACT(file_descriptor, '$."2"')), ''); -- package field
		SET file_path = CONCAT('$."1"[', file_index, ']');

		-- Process message types (field 4 in FileDescriptorProto)
		SET message_types = JSON_EXTRACT(file_descriptor, '$."4"');

		IF message_types IS NOT NULL THEN
			SET msg_count = JSON_LENGTH(message_types);
			SET msg_index = 0;

			WHILE msg_index < msg_count DO
				SET message_descriptor = JSON_EXTRACT(message_types, CONCAT('$[', msg_index, ']'));
				SET message_name = JSON_UNQUOTE(JSON_EXTRACT(message_descriptor, '$."1"')); -- name field
				SET message_path = CONCAT(file_path, '."4"[', msg_index, ']');
				SET full_type_name = _pb_build_type_name(file_package, message_name);

				-- Build field indexes for message
				SET field_name_index = JSON_OBJECT();
				SET field_number_index = JSON_OBJECT();
				SET field_array = JSON_EXTRACT(message_descriptor, '$."2"'); -- field array
				IF field_array IS NOT NULL THEN
					SET field_count = JSON_LENGTH(field_array);
					SET field_idx = 0;
					WHILE field_idx < field_count DO
						SET field_desc = JSON_EXTRACT(field_array, CONCAT('$[', field_idx, ']'));
						SET field_name_val = JSON_UNQUOTE(JSON_EXTRACT(field_desc, '$."1"')); -- name
						SET field_number_val = JSON_EXTRACT(field_desc, '$."3"'); -- number
						IF field_name_val IS NOT NULL THEN
							SET field_name_index = JSON_SET(field_name_index, CONCAT('$."', field_name_val, '"'), field_idx);
						END IF;
						IF field_number_val IS NOT NULL THEN
							SET field_number_index = JSON_SET(field_number_index, CONCAT('$."', field_number_val, '"'), field_idx);
						END IF;
						SET field_idx = field_idx + 1;
					END WHILE;
				END IF;

				-- Add to message type index: MessageTypeIndex format
				SET type_entry = JSON_OBJECT(
					'1', file_path,
					'2', message_path
				);
				-- Only include field indexes if they're non-empty
				IF JSON_LENGTH(JSON_KEYS(field_name_index)) > 0 THEN
					SET type_entry = JSON_SET(type_entry, '$.\"3\"', field_name_index);
				END IF;
				IF JSON_LENGTH(JSON_KEYS(field_number_index)) > 0 THEN
					SET type_entry = JSON_SET(type_entry, '$.\"4\"', field_number_index);
				END IF;
				SET message_type_index = JSON_SET(message_type_index, CONCAT('$."', full_type_name, '"'), type_entry);

				-- Process nested types recursively
				CALL _pb_build_nested_types(message_descriptor, full_type_name, message_path, file_path, message_type_index, enum_type_index);

				SET msg_index = msg_index + 1;
			END WHILE;
		END IF;

		-- Process enum types (field 5 in FileDescriptorProto)
		SET enum_types = JSON_EXTRACT(file_descriptor, '$."5"');

		IF enum_types IS NOT NULL THEN
			SET enum_count = JSON_LENGTH(enum_types);
			SET enum_index = 0;

			WHILE enum_index < enum_count DO
				SET enum_descriptor = JSON_EXTRACT(enum_types, CONCAT('$[', enum_index, ']'));
				SET enum_name = JSON_UNQUOTE(JSON_EXTRACT(enum_descriptor, '$."1"')); -- name field
				SET enum_path = CONCAT(file_path, '."5"[', enum_index, ']');
				SET full_type_name = _pb_build_type_name(file_package, enum_name);

				-- Build enum value indexes
				SET enum_name_index = JSON_OBJECT();
				SET enum_number_index = JSON_OBJECT();
				SET enum_values_array = JSON_EXTRACT(enum_descriptor, '$."2"'); -- value array
				IF enum_values_array IS NOT NULL THEN
					SET enum_value_count = JSON_LENGTH(enum_values_array);
					SET enum_value_idx = 0;
					WHILE enum_value_idx < enum_value_count DO
						SET enum_value_desc = JSON_EXTRACT(enum_values_array, CONCAT('$[', enum_value_idx, ']'));
						SET enum_value_name = JSON_UNQUOTE(JSON_EXTRACT(enum_value_desc, '$."1"')); -- name
						SET enum_value_number = JSON_EXTRACT(enum_value_desc, '$."2"'); -- number
						IF enum_value_name IS NOT NULL THEN
							SET enum_name_index = JSON_SET(enum_name_index, CONCAT('$."', enum_value_name, '"'), enum_value_idx);
						END IF;
						IF enum_value_number IS NOT NULL THEN
							SET enum_number_index = JSON_SET(enum_number_index, CONCAT('$."', enum_value_number, '"'), enum_value_idx);
						END IF;
						SET enum_value_idx = enum_value_idx + 1;
					END WHILE;
				END IF;

				-- Add to enum type index: EnumTypeIndex format
				SET type_entry = JSON_OBJECT(
					'1', file_path,
					'2', enum_path,
					'3', enum_name_index,
					'4', enum_number_index
				);
				SET enum_type_index = JSON_SET(enum_type_index, CONCAT('$."', full_type_name, '"'), type_entry);

				SET enum_index = enum_index + 1;
			END WHILE;
		END IF;

		SET file_index = file_index + 1;
	END WHILE;
END $$

-- Public function to convert FileDescriptorSet LONGBLOB to descriptor set JSON
-- Returns a DescriptorSet message in protonumberjson format
DROP FUNCTION IF EXISTS pb_build_descriptor_set_json $$
CREATE FUNCTION pb_build_descriptor_set_json(file_descriptor_set_blob LONGBLOB) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE file_descriptor_set_number_json JSON;
	DECLARE message_type_index JSON;
	DECLARE enum_type_index JSON;
	DECLARE result JSON;

	-- Convert FileDescriptorSet LONGBLOB to protonumberjson format
	SET file_descriptor_set_number_json = _pb_message_to_number_json(
		_pb_descriptor_proto(),
		'.google.protobuf.FileDescriptorSet',
		file_descriptor_set_blob,
		NULL  -- unmarshal_options: use default behavior
	);

	-- Build type indexes from the FileDescriptorSet
	CALL _pb_build_type_indexes_from_descriptor_set(
		file_descriptor_set_number_json,
		message_type_index,
		enum_type_index
	);

	-- Return DescriptorSet message: {"1": fileDescriptorSet, "2": messageTypeIndex, "3": enumTypeIndex}
	SET result = JSON_OBJECT(
		'1', file_descriptor_set_number_json,
		'2', message_type_index
	);
	-- Only include enumTypeIndex if it's non-empty
	IF JSON_LENGTH(JSON_KEYS(enum_type_index)) > 0 THEN
		SET result = JSON_SET(result, '$.\"3\"', enum_type_index);
	END IF;

	RETURN result;
END $$

DELIMITER $$

-- Helper function to convert uint32 IEEE 754 bits to JSON float value
DROP FUNCTION IF EXISTS _pb_convert_float_uint32_to_json $$
CREATE FUNCTION _pb_convert_float_uint32_to_json(uint32_bits INT UNSIGNED) RETURNS JSON DETERMINISTIC
BEGIN
	-- Check for special values first
	IF (uint32_bits & 0x7F800000) = 0x7F800000 THEN
		-- Exponent is all 1s (255)
		IF (uint32_bits & 0x007FFFFF) = 0 THEN
			-- Mantissa is zero - this is infinity
			IF (uint32_bits & 0x80000000) = 0 THEN
				RETURN JSON_QUOTE('Infinity');
			ELSE
				RETURN JSON_QUOTE('-Infinity');
			END IF;
		ELSE
			-- Mantissa is non-zero - this is NaN
			RETURN JSON_QUOTE('NaN');
		END IF;
	END IF;

	-- For regular numbers, convert back to float and cast to JSON
	RETURN CAST(_pb_util_reinterpret_uint32_as_float(uint32_bits) AS JSON);
END $$

-- Helper function to convert uint64 IEEE 754 bits to JSON double value
DROP FUNCTION IF EXISTS _pb_convert_double_uint64_to_json $$
CREATE FUNCTION _pb_convert_double_uint64_to_json(uint64_bits BIGINT UNSIGNED) RETURNS JSON DETERMINISTIC
BEGIN
	-- Check for special values first
	IF (uint64_bits & 0x7FF0000000000000) = 0x7FF0000000000000 THEN
		-- Exponent is all 1s (2047)
		IF (uint64_bits & 0x000FFFFFFFFFFFFF) = 0 THEN
			-- Mantissa is zero - this is infinity
			IF (uint64_bits & 0x8000000000000000) = 0 THEN
				RETURN JSON_QUOTE('Infinity');
			ELSE
				RETURN JSON_QUOTE('-Infinity');
			END IF;
		ELSE
			-- Mantissa is non-zero - this is NaN
			RETURN JSON_QUOTE('NaN');
		END IF;
	END IF;

	-- For regular numbers, convert back to double and cast to JSON
	RETURN CAST(_pb_util_reinterpret_uint64_as_double(uint64_bits) AS JSON);
END $$

-- Helper function to parse JSON value as BIGINT with validation
DROP FUNCTION IF EXISTS _pb_json_parse_signed_int $$
CREATE FUNCTION _pb_json_parse_signed_int(json_value JSON) RETURNS BIGINT DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;
	DECLARE message_text TEXT;
	DECLARE double_value DOUBLE;
	DECLARE uint_value BIGINT UNSIGNED;

	IF JSON_TYPE(json_value) = 'STRING' THEN
		SET str_value = JSON_UNQUOTE(json_value);

		-- Early return for invalid inputs
		IF str_value = '' OR NOT (str_value REGEXP '^-?[0-9]+(\\.[0-9]+)?([eE][+-]?[0-9]+)?$') THEN
			SET message_text = CONCAT('Invalid number format for signed integer: ', str_value);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;

		SET json_value = CAST(str_value AS JSON);
	END IF;

	CASE JSON_TYPE(json_value)
	WHEN 'UNSIGNED INTEGER' THEN
		-- Cast to unsigned first, then check range for signed integer
		SET uint_value = CAST(json_value AS UNSIGNED);
		IF uint_value > 9223372036854775807 THEN
			SET message_text = CONCAT('Value too large for signed integer field: ', CAST(uint_value AS CHAR));
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
		RETURN CAST(uint_value AS SIGNED);
	WHEN 'INTEGER' THEN
		-- JSON INTEGER type should be safe for signed integers
		RETURN CAST(json_value AS SIGNED);
	WHEN 'DOUBLE' THEN
		-- Handle JSON numbers with exponential notation (e.g., 1e5)
		-- But reject non-integer values (e.g., 0.5)
		SET double_value = CAST(json_value AS DOUBLE);
		IF double_value != FLOOR(double_value) THEN
			SET message_text = CONCAT('Non-integer value for signed integer field: ', CAST(double_value AS CHAR));
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
		RETURN CAST(double_value AS SIGNED);
	ELSE
		RETURN CAST(json_value AS SIGNED);
	END CASE;
END $$

-- Helper function to parse JSON value as BIGINT UNSIGNED with validation
DROP FUNCTION IF EXISTS _pb_json_parse_unsigned_int $$
CREATE FUNCTION _pb_json_parse_unsigned_int(json_value JSON) RETURNS BIGINT UNSIGNED DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;
	DECLARE message_text TEXT;
	DECLARE double_value DOUBLE;

	IF JSON_TYPE(json_value) = 'STRING' THEN
		SET str_value = JSON_UNQUOTE(json_value);

		-- Early return for invalid inputs
		IF str_value = '' OR NOT (str_value REGEXP '^-?[0-9]+(\\.[0-9]+)?([eE][+-]?[0-9]+)?$') THEN
			SET message_text = CONCAT('Invalid number format for signed integer: ', str_value);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;

		SET json_value = CAST(str_value AS JSON);
	END IF;

	CASE JSON_TYPE(json_value)
	WHEN 'INTEGER' THEN
		-- Check if the INTEGER value is negative (invalid for unsigned)
		IF CAST(json_value AS SIGNED) < 0 THEN
			SET message_text = CONCAT('Negative value for unsigned integer field: ', CAST(json_value AS CHAR));
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
		RETURN CAST(json_value AS UNSIGNED);
	WHEN 'UNSIGNED INTEGER' THEN
		-- UNSIGNED INTEGER values are always valid for unsigned fields
		RETURN CAST(json_value AS UNSIGNED);
	WHEN 'DOUBLE' THEN
		-- Handle JSON numbers with exponential notation (e.g., 1e5)
		-- But reject non-integer values (e.g., 0.5)
		SET double_value = CAST(json_value AS DOUBLE);
		IF double_value != FLOOR(double_value) THEN
			SET message_text = CONCAT('Non-integer value for unsigned integer field: ', CAST(double_value AS CHAR));
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;
		RETURN CAST(double_value AS UNSIGNED);
	ELSE
		RETURN CAST(json_value AS UNSIGNED);
	END CASE;
END $$

-- Helper function to parse JSON value as DOUBLE with validation
DROP FUNCTION IF EXISTS _pb_json_parse_double_as_uint64 $$
CREATE FUNCTION _pb_json_parse_double_as_uint64(json_value JSON, allow_hex_strings BOOLEAN) RETURNS BIGINT UNSIGNED DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;
	DECLARE message_text TEXT;
	DECLARE double_value DOUBLE;
	DECLARE hex_value TEXT;

	IF JSON_TYPE(json_value) = 'STRING' THEN
		SET str_value = JSON_UNQUOTE(json_value);

		-- Reject empty strings
		IF str_value = '' THEN
			SET message_text = 'Empty string is not a valid number for double field';
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;

		-- Handle binary64 hex format if allowed
		IF allow_hex_strings AND str_value REGEXP '^binary64:0x[0-9a-fA-F]{16}$' THEN
			SET hex_value = SUBSTRING(str_value, 12); -- Skip "binary64:0x"
			RETURN CONV(hex_value, 16, 10);
		END IF;

		-- Handle special values
		IF str_value IN ('Infinity', '-Infinity', 'NaN') THEN
			CASE str_value
			WHEN 'Infinity' THEN
				RETURN 0x7FF0000000000000;
			WHEN '-Infinity' THEN
				RETURN 0xFFF0000000000000;
			WHEN 'NaN' THEN
				RETURN 0x7FF8000000000000;
			END CASE;
		END IF;

		-- Reject non-numeric strings (but allow binary64 format)
		IF NOT (str_value REGEXP '^[+-]?([0-9]*\\.?[0-9]+([eE][+-]?[0-9]+)?|Infinity|-Infinity|NaN|binary64:0x[0-9a-fA-F]{16})$') THEN
			SET message_text = CONCAT('Invalid number format for double field: ', str_value);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;

		-- Convert string to JSON for further processing
		SET json_value = CAST(str_value AS JSON);
	END IF;

	-- Convert JSON value to double
	CASE JSON_TYPE(json_value)
	WHEN 'INTEGER' THEN
		SET double_value = CAST(json_value AS DOUBLE);
	WHEN 'UNSIGNED INTEGER' THEN
		SET double_value = CAST(json_value AS DOUBLE);
	WHEN 'DECIMAL' THEN
		SET double_value = CAST(json_value AS DOUBLE);
	WHEN 'DOUBLE' THEN
		SET double_value = CAST(json_value AS DOUBLE);
	ELSE
		SET message_text = CONCAT('Invalid JSON type for double field: ', JSON_TYPE(json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;

	-- Convert to IEEE 754 binary representation
	RETURN _pb_util_reinterpret_double_as_uint64(double_value);
END $$

-- Helper function to parse JSON value as FLOAT with validation
DROP FUNCTION IF EXISTS _pb_json_parse_float_as_uint32 $$
CREATE FUNCTION _pb_json_parse_float_as_uint32(json_value JSON, allow_hex_strings BOOLEAN) RETURNS INT UNSIGNED DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;
	DECLARE message_text TEXT;
	DECLARE float_value FLOAT;
	DECLARE hex_value TEXT;

	IF JSON_TYPE(json_value) = 'STRING' THEN
		SET str_value = JSON_UNQUOTE(json_value);

		-- Reject empty strings
		IF str_value = '' THEN
			SET message_text = 'Empty string is not a valid number for float field';
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;

		-- Handle binary32 hex format if allowed
		IF allow_hex_strings AND str_value REGEXP '^binary32:0x[0-9a-fA-F]{8}$' THEN
			SET hex_value = SUBSTRING(str_value, 12); -- Skip "binary32:0x"
			RETURN CONV(hex_value, 16, 10);
		END IF;

		-- Handle special values
		IF str_value IN ('Infinity', '-Infinity', 'NaN') THEN
			CASE str_value
			WHEN 'Infinity' THEN
				RETURN 0x7F800000;
			WHEN '-Infinity' THEN
				RETURN 0xFF800000;
			WHEN 'NaN' THEN
				RETURN 0x7FC00000;
			END CASE;
		END IF;

		-- Reject non-numeric strings (but allow binary32 format)
		IF NOT (str_value REGEXP '^[+-]?([0-9]*\\.?[0-9]+([eE][+-]?[0-9]+)?|Infinity|-Infinity|NaN|binary32:0x[0-9a-fA-F]{8})$') THEN
			SET message_text = CONCAT('Invalid number format for float field: ', str_value);
			SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
		END IF;

		-- Convert string to JSON for further processing
		SET json_value = CAST(str_value AS JSON);
	END IF;

	-- Convert JSON value to float
	CASE JSON_TYPE(json_value)
	WHEN 'INTEGER' THEN
		SET float_value = CAST(json_value AS FLOAT);
	WHEN 'UNSIGNED INTEGER' THEN
		SET float_value = CAST(json_value AS FLOAT);
	WHEN 'DECIMAL' THEN
		SET float_value = CAST(json_value AS FLOAT);
	WHEN 'DOUBLE' THEN
		SET float_value = CAST(json_value AS FLOAT);
	ELSE
		SET message_text = CONCAT('Invalid JSON type for float field: ', JSON_TYPE(json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;

	-- Convert to IEEE 754 binary representation
	RETURN _pb_util_reinterpret_float_as_uint32(float_value);
END $$

-- Helper function to parse JSON value as bytes with Base64 decoding
DROP FUNCTION IF EXISTS _pb_json_parse_bytes $$
CREATE FUNCTION _pb_json_parse_bytes(json_value JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
	DECLARE str_value TEXT;
	DECLARE message_text TEXT;

	-- Bytes must be a JSON string
	IF JSON_TYPE(json_value) != 'STRING' THEN
		SET message_text = CONCAT('Invalid JSON type for bytes field: expected STRING, got ', JSON_TYPE(json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	-- Unquote the JSON string
	SET str_value = JSON_UNQUOTE(json_value);

	-- Decode from Base64/Base64URL and return as binary data
	RETURN _pb_util_from_base64_url(str_value);
END $$

-- Helper function to parse JSON value as Protobuf string type
DROP FUNCTION IF EXISTS _pb_json_parse_string $$
CREATE FUNCTION _pb_json_parse_string(json_value JSON) RETURNS LONGTEXT DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;

	-- String fields must receive JSON string values
	IF JSON_TYPE(json_value) != 'STRING' THEN
		SET message_text = CONCAT('Invalid JSON type for string field: expected STRING, got ', JSON_TYPE(json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	RETURN JSON_UNQUOTE(json_value);
END $$

-- Helper function to parse JSON value as Protobuf bool type
DROP FUNCTION IF EXISTS _pb_json_parse_bool $$
CREATE FUNCTION _pb_json_parse_bool(json_value JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
	DECLARE bool_value BOOLEAN;
	DECLARE message_text TEXT;

	IF JSON_TYPE(json_value) <> 'BOOLEAN' THEN
		SET message_text = CONCAT('Invalid JSON type for bool field: expected BOOLEAN, got ', JSON_TYPE(json_value));
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	SET bool_value = json_value;

	RETURN bool_value;
END $$

DELIMITER $$

-- Helper function to convert uint32 IEEE 754 bits to binary32 number JSON format
DROP FUNCTION IF EXISTS _pb_convert_float_uint32_to_number_json $$
CREATE FUNCTION _pb_convert_float_uint32_to_number_json(uint32_bits INT UNSIGNED) RETURNS JSON DETERMINISTIC
BEGIN
	-- Always produce binary32 format for number JSON
	RETURN JSON_QUOTE(CONCAT('binary32:0x', LPAD(LOWER(HEX(uint32_bits)), 8, '0')));
END $$

-- Helper function to convert uint64 IEEE 754 bits to binary64 number JSON format
DROP FUNCTION IF EXISTS _pb_convert_double_uint64_to_number_json $$
CREATE FUNCTION _pb_convert_double_uint64_to_number_json(uint64_bits BIGINT UNSIGNED) RETURNS JSON DETERMINISTIC
BEGIN
	-- Always produce binary64 format for number JSON
	RETURN JSON_QUOTE(CONCAT('binary64:0x', LPAD(LOWER(HEX(uint64_bits)), 16, '0')));
END $$

-- Generated by cmd/protoc-gen-mysql; DO NOT EDIT

-- The following FileDescriptorSets (in JSON format) are auto-generated from files
-- in https://github.com/google/protobuf, and the following license terms apply.

-- Copyright 2010 The Go Authors.  All rights reserved.
--
-- Redistribution and use in source and binary forms, with or without
-- modification, are permitted provided that the following conditions are
-- met:
--
--     * Redistributions of source code must retain the above copyright
-- notice, this list of conditions and the following disclaimer.
--     * Redistributions in binary form must reproduce the above
-- copyright notice, this list of conditions and the following disclaimer
-- in the documentation and/or other materials provided with the
-- distribution.
--     * Neither the name of Google Inc. nor the names of its
-- contributors may be used to endorse or promote products derived from
-- this software without specific prior written permission.
--
-- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
-- "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
-- LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
-- A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-- OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-- LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-- DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-- THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-- OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

DELIMITER $$

DROP FUNCTION IF EXISTS _pb_descriptor_proto $$
CREATE FUNCTION _pb_descriptor_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/descriptor.proto","2":"google.protobuf","4":[{"1":"FileDescriptorSet","2":[{"1":"file","10":"file","3":1,"4":3,"5":11,"6":".google.protobuf.FileDescriptorProto"}],"5":[{"1":536000000,"2":536000001}]},{"1":"FileDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"package","10":"package","3":2,"4":1,"5":9},{"1":"dependency","10":"dependency","3":3,"4":3,"5":9},{"1":"public_dependency","10":"publicDependency","3":10,"4":3,"5":5},{"1":"weak_dependency","10":"weakDependency","3":11,"4":3,"5":5},{"1":"message_type","10":"messageType","3":4,"4":3,"5":11,"6":".google.protobuf.DescriptorProto"},{"1":"enum_type","10":"enumType","3":5,"4":3,"5":11,"6":".google.protobuf.EnumDescriptorProto"},{"1":"service","10":"service","3":6,"4":3,"5":11,"6":".google.protobuf.ServiceDescriptorProto"},{"1":"extension","10":"extension","3":7,"4":3,"5":11,"6":".google.protobuf.FieldDescriptorProto"},{"1":"options","10":"options","3":8,"4":1,"5":11,"6":".google.protobuf.FileOptions"},{"1":"source_code_info","10":"sourceCodeInfo","3":9,"4":1,"5":11,"6":".google.protobuf.SourceCodeInfo"},{"1":"syntax","10":"syntax","3":12,"4":1,"5":9},{"1":"edition","10":"edition","3":14,"4":1,"5":14,"6":".google.protobuf.Edition"}]},{"1":"DescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"field","10":"field","3":2,"4":3,"5":11,"6":".google.protobuf.FieldDescriptorProto"},{"1":"extension","10":"extension","3":6,"4":3,"5":11,"6":".google.protobuf.FieldDescriptorProto"},{"1":"nested_type","10":"nestedType","3":3,"4":3,"5":11,"6":".google.protobuf.DescriptorProto"},{"1":"enum_type","10":"enumType","3":4,"4":3,"5":11,"6":".google.protobuf.EnumDescriptorProto"},{"1":"extension_range","10":"extensionRange","3":5,"4":3,"5":11,"6":".google.protobuf.DescriptorProto.ExtensionRange"},{"1":"oneof_decl","10":"oneofDecl","3":8,"4":3,"5":11,"6":".google.protobuf.OneofDescriptorProto"},{"1":"options","10":"options","3":7,"4":1,"5":11,"6":".google.protobuf.MessageOptions"},{"1":"reserved_range","10":"reservedRange","3":9,"4":3,"5":11,"6":".google.protobuf.DescriptorProto.ReservedRange"},{"1":"reserved_name","10":"reservedName","3":10,"4":3,"5":9}],"3":[{"1":"ExtensionRange","2":[{"1":"start","10":"start","3":1,"4":1,"5":5},{"1":"end","10":"end","3":2,"4":1,"5":5},{"1":"options","10":"options","3":3,"4":1,"5":11,"6":".google.protobuf.ExtensionRangeOptions"}]},{"1":"ReservedRange","2":[{"1":"start","10":"start","3":1,"4":1,"5":5},{"1":"end","10":"end","3":2,"4":1,"5":5}]}]},{"1":"ExtensionRangeOptions","2":[{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"},{"1":"declaration","10":"declaration","3":2,"4":3,"5":11,"6":".google.protobuf.ExtensionRangeOptions.Declaration","8":{"17":2}},{"1":"features","10":"features","3":50,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"verification","10":"verification","3":3,"4":1,"5":14,"6":".google.protobuf.ExtensionRangeOptions.VerificationState","7":"UNVERIFIED","8":{"17":2}}],"3":[{"1":"Declaration","2":[{"1":"number","10":"number","3":1,"4":1,"5":5},{"1":"full_name","10":"fullName","3":2,"4":1,"5":9},{"1":"type","10":"type","3":3,"4":1,"5":9},{"1":"reserved","10":"reserved","3":5,"4":1,"5":8},{"1":"repeated","10":"repeated","3":6,"4":1,"5":8}],"9":[{"1":4,"2":5}]}],"4":[{"1":"VerificationState","2":[{"1":"DECLARATION","2":0},{"1":"UNVERIFIED","2":1}]}],"5":[{"1":1000,"2":536870912}]},{"1":"FieldDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"number","10":"number","3":3,"4":1,"5":5},{"1":"label","10":"label","3":4,"4":1,"5":14,"6":".google.protobuf.FieldDescriptorProto.Label"},{"1":"type","10":"type","3":5,"4":1,"5":14,"6":".google.protobuf.FieldDescriptorProto.Type"},{"1":"type_name","10":"typeName","3":6,"4":1,"5":9},{"1":"extendee","10":"extendee","3":2,"4":1,"5":9},{"1":"default_value","10":"defaultValue","3":7,"4":1,"5":9},{"1":"oneof_index","10":"oneofIndex","3":9,"4":1,"5":5},{"1":"json_name","10":"jsonName","3":10,"4":1,"5":9},{"1":"options","10":"options","3":8,"4":1,"5":11,"6":".google.protobuf.FieldOptions"},{"1":"proto3_optional","10":"proto3Optional","3":17,"4":1,"5":8}],"4":[{"1":"Type","2":[{"1":"TYPE_DOUBLE","2":1},{"1":"TYPE_FLOAT","2":2},{"1":"TYPE_INT64","2":3},{"1":"TYPE_UINT64","2":4},{"1":"TYPE_INT32","2":5},{"1":"TYPE_FIXED64","2":6},{"1":"TYPE_FIXED32","2":7},{"1":"TYPE_BOOL","2":8},{"1":"TYPE_STRING","2":9},{"1":"TYPE_GROUP","2":10},{"1":"TYPE_MESSAGE","2":11},{"1":"TYPE_BYTES","2":12},{"1":"TYPE_UINT32","2":13},{"1":"TYPE_ENUM","2":14},{"1":"TYPE_SFIXED32","2":15},{"1":"TYPE_SFIXED64","2":16},{"1":"TYPE_SINT32","2":17},{"1":"TYPE_SINT64","2":18}]},{"1":"Label","2":[{"1":"LABEL_OPTIONAL","2":1},{"1":"LABEL_REPEATED","2":3},{"1":"LABEL_REQUIRED","2":2}]}]},{"1":"OneofDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"options","10":"options","3":2,"4":1,"5":11,"6":".google.protobuf.OneofOptions"}]},{"1":"EnumDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"value","10":"value","3":2,"4":3,"5":11,"6":".google.protobuf.EnumValueDescriptorProto"},{"1":"options","10":"options","3":3,"4":1,"5":11,"6":".google.protobuf.EnumOptions"},{"1":"reserved_range","10":"reservedRange","3":4,"4":3,"5":11,"6":".google.protobuf.EnumDescriptorProto.EnumReservedRange"},{"1":"reserved_name","10":"reservedName","3":5,"4":3,"5":9}],"3":[{"1":"EnumReservedRange","2":[{"1":"start","10":"start","3":1,"4":1,"5":5},{"1":"end","10":"end","3":2,"4":1,"5":5}]}]},{"1":"EnumValueDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"number","10":"number","3":2,"4":1,"5":5},{"1":"options","10":"options","3":3,"4":1,"5":11,"6":".google.protobuf.EnumValueOptions"}]},{"1":"ServiceDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"method","10":"method","3":2,"4":3,"5":11,"6":".google.protobuf.MethodDescriptorProto"},{"1":"options","10":"options","3":3,"4":1,"5":11,"6":".google.protobuf.ServiceOptions"}]},{"1":"MethodDescriptorProto","2":[{"1":"name","10":"name","3":1,"4":1,"5":9},{"1":"input_type","10":"inputType","3":2,"4":1,"5":9},{"1":"output_type","10":"outputType","3":3,"4":1,"5":9},{"1":"options","10":"options","3":4,"4":1,"5":11,"6":".google.protobuf.MethodOptions"},{"1":"client_streaming","10":"clientStreaming","3":5,"4":1,"5":8,"7":"false"},{"1":"server_streaming","10":"serverStreaming","3":6,"4":1,"5":8,"7":"false"}]},{"1":"FileOptions","10":["php_generic_services"],"2":[{"1":"java_package","10":"javaPackage","3":1,"4":1,"5":9},{"1":"java_outer_classname","10":"javaOuterClassname","3":8,"4":1,"5":9},{"1":"java_multiple_files","10":"javaMultipleFiles","3":10,"4":1,"5":8,"7":"false"},{"1":"java_generate_equals_and_hash","10":"javaGenerateEqualsAndHash","3":20,"4":1,"5":8,"8":{"3":true}},{"1":"java_string_check_utf8","10":"javaStringCheckUtf8","3":27,"4":1,"5":8,"7":"false"},{"1":"optimize_for","10":"optimizeFor","3":9,"4":1,"5":14,"6":".google.protobuf.FileOptions.OptimizeMode","7":"SPEED"},{"1":"go_package","10":"goPackage","3":11,"4":1,"5":9},{"1":"cc_generic_services","10":"ccGenericServices","3":16,"4":1,"5":8,"7":"false"},{"1":"java_generic_services","10":"javaGenericServices","3":17,"4":1,"5":8,"7":"false"},{"1":"py_generic_services","10":"pyGenericServices","3":18,"4":1,"5":8,"7":"false"},{"1":"deprecated","10":"deprecated","3":23,"4":1,"5":8,"7":"false"},{"1":"cc_enable_arenas","10":"ccEnableArenas","3":31,"4":1,"5":8,"7":"true"},{"1":"objc_class_prefix","10":"objcClassPrefix","3":36,"4":1,"5":9},{"1":"csharp_namespace","10":"csharpNamespace","3":37,"4":1,"5":9},{"1":"swift_prefix","10":"swiftPrefix","3":39,"4":1,"5":9},{"1":"php_class_prefix","10":"phpClassPrefix","3":40,"4":1,"5":9},{"1":"php_namespace","10":"phpNamespace","3":41,"4":1,"5":9},{"1":"php_metadata_namespace","10":"phpMetadataNamespace","3":44,"4":1,"5":9},{"1":"ruby_package","10":"rubyPackage","3":45,"4":1,"5":9},{"1":"features","10":"features","3":50,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"4":[{"1":"OptimizeMode","2":[{"1":"SPEED","2":1},{"1":"CODE_SIZE","2":2},{"1":"LITE_RUNTIME","2":3}]}],"5":[{"1":1000,"2":536870912}],"9":[{"1":42,"2":43},{"1":38,"2":39}]},{"1":"MessageOptions","2":[{"1":"message_set_wire_format","10":"messageSetWireFormat","3":1,"4":1,"5":8,"7":"false"},{"1":"no_standard_descriptor_accessor","10":"noStandardDescriptorAccessor","3":2,"4":1,"5":8,"7":"false"},{"1":"deprecated","10":"deprecated","3":3,"4":1,"5":8,"7":"false"},{"1":"map_entry","10":"mapEntry","3":7,"4":1,"5":8},{"1":"deprecated_legacy_json_field_conflicts","10":"deprecatedLegacyJsonFieldConflicts","3":11,"4":1,"5":8,"8":{"3":true}},{"1":"features","10":"features","3":12,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"5":[{"1":1000,"2":536870912}],"9":[{"1":4,"2":5},{"1":5,"2":6},{"1":6,"2":7},{"1":8,"2":9},{"1":9,"2":10}]},{"1":"FieldOptions","2":[{"1":"ctype","10":"ctype","3":1,"4":1,"5":14,"6":".google.protobuf.FieldOptions.CType","7":"STRING"},{"1":"packed","10":"packed","3":2,"4":1,"5":8},{"1":"jstype","10":"jstype","3":6,"4":1,"5":14,"6":".google.protobuf.FieldOptions.JSType","7":"JS_NORMAL"},{"1":"lazy","10":"lazy","3":5,"4":1,"5":8,"7":"false"},{"1":"unverified_lazy","10":"unverifiedLazy","3":15,"4":1,"5":8,"7":"false"},{"1":"deprecated","10":"deprecated","3":3,"4":1,"5":8,"7":"false"},{"1":"weak","10":"weak","3":10,"4":1,"5":8,"7":"false"},{"1":"debug_redact","10":"debugRedact","3":16,"4":1,"5":8,"7":"false"},{"1":"retention","10":"retention","3":17,"4":1,"5":14,"6":".google.protobuf.FieldOptions.OptionRetention"},{"1":"targets","10":"targets","3":19,"4":3,"5":14,"6":".google.protobuf.FieldOptions.OptionTargetType"},{"1":"edition_defaults","10":"editionDefaults","3":20,"4":3,"5":11,"6":".google.protobuf.FieldOptions.EditionDefault"},{"1":"features","10":"features","3":21,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"feature_support","10":"featureSupport","3":22,"4":1,"5":11,"6":".google.protobuf.FieldOptions.FeatureSupport"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"3":[{"1":"EditionDefault","2":[{"1":"edition","10":"edition","3":3,"4":1,"5":14,"6":".google.protobuf.Edition"},{"1":"value","10":"value","3":2,"4":1,"5":9}]},{"1":"FeatureSupport","2":[{"1":"edition_introduced","10":"editionIntroduced","3":1,"4":1,"5":14,"6":".google.protobuf.Edition"},{"1":"edition_deprecated","10":"editionDeprecated","3":2,"4":1,"5":14,"6":".google.protobuf.Edition"},{"1":"deprecation_warning","10":"deprecationWarning","3":3,"4":1,"5":9},{"1":"edition_removed","10":"editionRemoved","3":4,"4":1,"5":14,"6":".google.protobuf.Edition"}]}],"4":[{"1":"CType","2":[{"1":"STRING","2":0},{"1":"CORD","2":1},{"1":"STRING_PIECE","2":2}]},{"1":"JSType","2":[{"1":"JS_NORMAL","2":0},{"1":"JS_STRING","2":1},{"1":"JS_NUMBER","2":2}]},{"1":"OptionRetention","2":[{"1":"RETENTION_UNKNOWN","2":0},{"1":"RETENTION_RUNTIME","2":1},{"1":"RETENTION_SOURCE","2":2}]},{"1":"OptionTargetType","2":[{"1":"TARGET_TYPE_UNKNOWN","2":0},{"1":"TARGET_TYPE_FILE","2":1},{"1":"TARGET_TYPE_EXTENSION_RANGE","2":2},{"1":"TARGET_TYPE_MESSAGE","2":3},{"1":"TARGET_TYPE_FIELD","2":4},{"1":"TARGET_TYPE_ONEOF","2":5},{"1":"TARGET_TYPE_ENUM","2":6},{"1":"TARGET_TYPE_ENUM_ENTRY","2":7},{"1":"TARGET_TYPE_SERVICE","2":8},{"1":"TARGET_TYPE_METHOD","2":9}]}],"5":[{"1":1000,"2":536870912}],"9":[{"1":4,"2":5},{"1":18,"2":19}]},{"1":"OneofOptions","2":[{"1":"features","10":"features","3":1,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"5":[{"1":1000,"2":536870912}]},{"1":"EnumOptions","2":[{"1":"allow_alias","10":"allowAlias","3":2,"4":1,"5":8},{"1":"deprecated","10":"deprecated","3":3,"4":1,"5":8,"7":"false"},{"1":"deprecated_legacy_json_field_conflicts","10":"deprecatedLegacyJsonFieldConflicts","3":6,"4":1,"5":8,"8":{"3":true}},{"1":"features","10":"features","3":7,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"5":[{"1":1000,"2":536870912}],"9":[{"1":5,"2":6}]},{"1":"EnumValueOptions","2":[{"1":"deprecated","10":"deprecated","3":1,"4":1,"5":8,"7":"false"},{"1":"features","10":"features","3":2,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"debug_redact","10":"debugRedact","3":3,"4":1,"5":8,"7":"false"},{"1":"feature_support","10":"featureSupport","3":4,"4":1,"5":11,"6":".google.protobuf.FieldOptions.FeatureSupport"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"5":[{"1":1000,"2":536870912}]},{"1":"ServiceOptions","2":[{"1":"features","10":"features","3":34,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"deprecated","10":"deprecated","3":33,"4":1,"5":8,"7":"false"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"5":[{"1":1000,"2":536870912}]},{"1":"MethodOptions","2":[{"1":"deprecated","10":"deprecated","3":33,"4":1,"5":8,"7":"false"},{"1":"idempotency_level","10":"idempotencyLevel","3":34,"4":1,"5":14,"6":".google.protobuf.MethodOptions.IdempotencyLevel","7":"IDEMPOTENCY_UNKNOWN"},{"1":"features","10":"features","3":35,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"uninterpreted_option","10":"uninterpretedOption","3":999,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption"}],"4":[{"1":"IdempotencyLevel","2":[{"1":"IDEMPOTENCY_UNKNOWN","2":0},{"1":"NO_SIDE_EFFECTS","2":1},{"1":"IDEMPOTENT","2":2}]}],"5":[{"1":1000,"2":536870912}]},{"1":"UninterpretedOption","2":[{"1":"name","10":"name","3":2,"4":3,"5":11,"6":".google.protobuf.UninterpretedOption.NamePart"},{"1":"identifier_value","10":"identifierValue","3":3,"4":1,"5":9},{"1":"positive_int_value","10":"positiveIntValue","3":4,"4":1,"5":4},{"1":"negative_int_value","10":"negativeIntValue","3":5,"4":1,"5":3},{"1":"double_value","10":"doubleValue","3":6,"4":1,"5":1},{"1":"string_value","10":"stringValue","3":7,"4":1,"5":12},{"1":"aggregate_value","10":"aggregateValue","3":8,"4":1,"5":9}],"3":[{"1":"NamePart","2":[{"1":"name_part","10":"namePart","3":1,"4":2,"5":9},{"1":"is_extension","10":"isExtension","3":2,"4":2,"5":8}]}]},{"1":"FeatureSet","2":[{"1":"field_presence","10":"fieldPresence","3":1,"4":1,"5":14,"6":".google.protobuf.FeatureSet.FieldPresence","8":{"17":1,"19":[4,1],"20":[{"2":"EXPLICIT","3":900},{"2":"IMPLICIT","3":999},{"2":"EXPLICIT","3":1000}],"22":{"1":1000}}},{"1":"enum_type","10":"enumType","3":2,"4":1,"5":14,"6":".google.protobuf.FeatureSet.EnumType","8":{"17":1,"19":[6,1],"20":[{"2":"CLOSED","3":900},{"2":"OPEN","3":999}],"22":{"1":1000}}},{"1":"repeated_field_encoding","10":"repeatedFieldEncoding","3":3,"4":1,"5":14,"6":".google.protobuf.FeatureSet.RepeatedFieldEncoding","8":{"17":1,"19":[4,1],"20":[{"2":"EXPANDED","3":900},{"2":"PACKED","3":999}],"22":{"1":1000}}},{"1":"utf8_validation","10":"utf8Validation","3":4,"4":1,"5":14,"6":".google.protobuf.FeatureSet.Utf8Validation","8":{"17":1,"19":[4,1],"20":[{"2":"NONE","3":900},{"2":"VERIFY","3":999}],"22":{"1":1000}}},{"1":"message_encoding","10":"messageEncoding","3":5,"4":1,"5":14,"6":".google.protobuf.FeatureSet.MessageEncoding","8":{"17":1,"19":[4,1],"20":[{"2":"LENGTH_PREFIXED","3":900}],"22":{"1":1000}}},{"1":"json_format","10":"jsonFormat","3":6,"4":1,"5":14,"6":".google.protobuf.FeatureSet.JsonFormat","8":{"17":1,"19":[3,6,1],"20":[{"2":"LEGACY_BEST_EFFORT","3":900},{"2":"ALLOW","3":999}],"22":{"1":1000}}},{"1":"enforce_naming_style","10":"enforceNamingStyle","3":7,"4":1,"5":14,"6":".google.protobuf.FeatureSet.EnforceNamingStyle","8":{"17":2,"19":[1,2,3,4,5,6,7,8,9],"20":[{"2":"STYLE_LEGACY","3":900},{"2":"STYLE2024","3":1001}],"22":{"1":1001}}}],"4":[{"1":"FieldPresence","2":[{"1":"FIELD_PRESENCE_UNKNOWN","2":0},{"1":"EXPLICIT","2":1},{"1":"IMPLICIT","2":2},{"1":"LEGACY_REQUIRED","2":3}]},{"1":"EnumType","2":[{"1":"ENUM_TYPE_UNKNOWN","2":0},{"1":"OPEN","2":1},{"1":"CLOSED","2":2}]},{"1":"RepeatedFieldEncoding","2":[{"1":"REPEATED_FIELD_ENCODING_UNKNOWN","2":0},{"1":"PACKED","2":1},{"1":"EXPANDED","2":2}]},{"1":"Utf8Validation","2":[{"1":"UTF8_VALIDATION_UNKNOWN","2":0},{"1":"VERIFY","2":2},{"1":"NONE","2":3}],"4":[{"1":1,"2":1}]},{"1":"MessageEncoding","2":[{"1":"MESSAGE_ENCODING_UNKNOWN","2":0},{"1":"LENGTH_PREFIXED","2":1},{"1":"DELIMITED","2":2}]},{"1":"JsonFormat","2":[{"1":"JSON_FORMAT_UNKNOWN","2":0},{"1":"ALLOW","2":1},{"1":"LEGACY_BEST_EFFORT","2":2}]},{"1":"EnforceNamingStyle","2":[{"1":"ENFORCE_NAMING_STYLE_UNKNOWN","2":0},{"1":"STYLE2024","2":1},{"1":"STYLE_LEGACY","2":2}]}],"5":[{"1":1000,"2":9995},{"1":9995,"2":10000},{"1":10000,"2":10001}],"9":[{"1":999,"2":1000}]},{"1":"FeatureSetDefaults","2":[{"1":"defaults","10":"defaults","3":1,"4":3,"5":11,"6":".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault"},{"1":"minimum_edition","10":"minimumEdition","3":4,"4":1,"5":14,"6":".google.protobuf.Edition"},{"1":"maximum_edition","10":"maximumEdition","3":5,"4":1,"5":14,"6":".google.protobuf.Edition"}],"3":[{"1":"FeatureSetEditionDefault","10":["features"],"2":[{"1":"edition","10":"edition","3":3,"4":1,"5":14,"6":".google.protobuf.Edition"},{"1":"overridable_features","10":"overridableFeatures","3":4,"4":1,"5":11,"6":".google.protobuf.FeatureSet"},{"1":"fixed_features","10":"fixedFeatures","3":5,"4":1,"5":11,"6":".google.protobuf.FeatureSet"}],"9":[{"1":1,"2":2},{"1":2,"2":3}]}]},{"1":"SourceCodeInfo","2":[{"1":"location","10":"location","3":1,"4":3,"5":11,"6":".google.protobuf.SourceCodeInfo.Location"}],"3":[{"1":"Location","2":[{"1":"path","10":"path","3":1,"4":3,"5":5,"8":{"2":true}},{"1":"span","10":"span","3":2,"4":3,"5":5,"8":{"2":true}},{"1":"leading_comments","10":"leadingComments","3":3,"4":1,"5":9},{"1":"trailing_comments","10":"trailingComments","3":4,"4":1,"5":9},{"1":"leading_detached_comments","10":"leadingDetachedComments","3":6,"4":3,"5":9}]}],"5":[{"1":536000000,"2":536000001}]},{"1":"GeneratedCodeInfo","2":[{"1":"annotation","10":"annotation","3":1,"4":3,"5":11,"6":".google.protobuf.GeneratedCodeInfo.Annotation"}],"3":[{"1":"Annotation","2":[{"1":"path","10":"path","3":1,"4":3,"5":5,"8":{"2":true}},{"1":"source_file","10":"sourceFile","3":2,"4":1,"5":9},{"1":"begin","10":"begin","3":3,"4":1,"5":5},{"1":"end","10":"end","3":4,"4":1,"5":5},{"1":"semantic","10":"semantic","3":5,"4":1,"5":14,"6":".google.protobuf.GeneratedCodeInfo.Annotation.Semantic"}],"4":[{"1":"Semantic","2":[{"1":"NONE","2":0},{"1":"SET","2":1},{"1":"ALIAS","2":2}]}]}]}],"5":[{"1":"Edition","2":[{"1":"EDITION_UNKNOWN","2":0},{"1":"EDITION_LEGACY","2":900},{"1":"EDITION_PROTO2","2":998},{"1":"EDITION_PROTO3","2":999},{"1":"EDITION_2023","2":1000},{"1":"EDITION_2024","2":1001},{"1":"EDITION_1_TEST_ONLY","2":1},{"1":"EDITION_2_TEST_ONLY","2":2},{"1":"EDITION_99997_TEST_ONLY","2":99997},{"1":"EDITION_99998_TEST_ONLY","2":99998},{"1":"EDITION_99999_TEST_ONLY","2":99999},{"1":"EDITION_MAX","2":2147483647}]}],"8":{"1":"com.google.protobuf","11":"google.golang.org/protobuf/types/descriptorpb","31":true,"36":"GPB","37":"Google.Protobuf.Reflection","8":"DescriptorProtos","9":1}}]},"2":{".google.protobuf.DescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[2]","3":{"enum_type":4,"extension":2,"extension_range":5,"field":1,"name":0,"nested_type":3,"oneof_decl":6,"options":7,"reserved_name":9,"reserved_range":8},"4":{"1":0,"10":9,"2":1,"3":3,"4":4,"5":5,"6":2,"7":7,"8":6,"9":8}},".google.protobuf.DescriptorProto.ExtensionRange":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[2].\\"3\\"[0]","3":{"end":1,"options":2,"start":0},"4":{"1":0,"2":1,"3":2}},".google.protobuf.DescriptorProto.ReservedRange":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[2].\\"3\\"[1]","3":{"end":1,"start":0},"4":{"1":0,"2":1}},".google.protobuf.EnumDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[6]","3":{"name":0,"options":2,"reserved_name":4,"reserved_range":3,"value":1},"4":{"1":0,"2":1,"3":2,"4":3,"5":4}},".google.protobuf.EnumDescriptorProto.EnumReservedRange":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[6].\\"3\\"[0]","3":{"end":1,"start":0},"4":{"1":0,"2":1}},".google.protobuf.EnumOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[14]","3":{"allow_alias":0,"deprecated":1,"deprecated_legacy_json_field_conflicts":2,"features":3,"uninterpreted_option":4},"4":{"2":0,"3":1,"6":2,"7":3,"999":4}},".google.protobuf.EnumValueDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[7]","3":{"name":0,"number":1,"options":2},"4":{"1":0,"2":1,"3":2}},".google.protobuf.EnumValueOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[15]","3":{"debug_redact":2,"deprecated":0,"feature_support":3,"features":1,"uninterpreted_option":4},"4":{"1":0,"2":1,"3":2,"4":3,"999":4}},".google.protobuf.ExtensionRangeOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[3]","3":{"declaration":1,"features":2,"uninterpreted_option":0,"verification":3},"4":{"2":1,"3":3,"50":2,"999":0}},".google.protobuf.ExtensionRangeOptions.Declaration":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[3].\\"3\\"[0]","3":{"full_name":1,"number":0,"repeated":4,"reserved":3,"type":2},"4":{"1":0,"2":1,"3":2,"5":3,"6":4}},".google.protobuf.FeatureSet":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19]","3":{"enforce_naming_style":6,"enum_type":1,"field_presence":0,"json_format":5,"message_encoding":4,"repeated_field_encoding":2,"utf8_validation":3},"4":{"1":0,"2":1,"3":2,"4":3,"5":4,"6":5,"7":6}},".google.protobuf.FeatureSetDefaults":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[20]","3":{"defaults":0,"maximum_edition":2,"minimum_edition":1},"4":{"1":0,"4":1,"5":2}},".google.protobuf.FeatureSetDefaults.FeatureSetEditionDefault":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[20].\\"3\\"[0]","3":{"edition":0,"fixed_features":2,"overridable_features":1},"4":{"3":0,"4":1,"5":2}},".google.protobuf.FieldDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[4]","3":{"default_value":6,"extendee":5,"json_name":8,"label":2,"name":0,"number":1,"oneof_index":7,"options":9,"proto3_optional":10,"type":3,"type_name":4},"4":{"1":0,"10":8,"17":10,"2":5,"3":1,"4":2,"5":3,"6":4,"7":6,"8":9,"9":7}},".google.protobuf.FieldOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12]","3":{"ctype":0,"debug_redact":7,"deprecated":5,"edition_defaults":10,"feature_support":12,"features":11,"jstype":2,"lazy":3,"packed":1,"retention":8,"targets":9,"uninterpreted_option":13,"unverified_lazy":4,"weak":6},"4":{"1":0,"10":6,"15":4,"16":7,"17":8,"19":9,"2":1,"20":10,"21":11,"22":12,"3":5,"5":3,"6":2,"999":13}},".google.protobuf.FieldOptions.EditionDefault":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12].\\"3\\"[0]","3":{"edition":0,"value":1},"4":{"2":1,"3":0}},".google.protobuf.FieldOptions.FeatureSupport":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12].\\"3\\"[1]","3":{"deprecation_warning":2,"edition_deprecated":1,"edition_introduced":0,"edition_removed":3},"4":{"1":0,"2":1,"3":2,"4":3}},".google.protobuf.FileDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[1]","3":{"dependency":2,"edition":12,"enum_type":6,"extension":8,"message_type":5,"name":0,"options":9,"package":1,"public_dependency":3,"service":7,"source_code_info":10,"syntax":11,"weak_dependency":4},"4":{"1":0,"10":3,"11":4,"12":11,"14":12,"2":1,"3":2,"4":5,"5":6,"6":7,"7":8,"8":9,"9":10}},".google.protobuf.FileDescriptorSet":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"file":0},"4":{"1":0}},".google.protobuf.FileOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[10]","3":{"cc_enable_arenas":11,"cc_generic_services":7,"csharp_namespace":13,"deprecated":10,"features":19,"go_package":6,"java_generate_equals_and_hash":3,"java_generic_services":8,"java_multiple_files":2,"java_outer_classname":1,"java_package":0,"java_string_check_utf8":4,"objc_class_prefix":12,"optimize_for":5,"php_class_prefix":15,"php_metadata_namespace":17,"php_namespace":16,"py_generic_services":9,"ruby_package":18,"swift_prefix":14,"uninterpreted_option":20},"4":{"1":0,"10":2,"11":6,"16":7,"17":8,"18":9,"20":3,"23":10,"27":4,"31":11,"36":12,"37":13,"39":14,"40":15,"41":16,"44":17,"45":18,"50":19,"8":1,"9":5,"999":20}},".google.protobuf.GeneratedCodeInfo":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[22]","3":{"annotation":0},"4":{"1":0}},".google.protobuf.GeneratedCodeInfo.Annotation":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[22].\\"3\\"[0]","3":{"begin":2,"end":3,"path":0,"semantic":4,"source_file":1},"4":{"1":0,"2":1,"3":2,"4":3,"5":4}},".google.protobuf.MessageOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[11]","3":{"deprecated":2,"deprecated_legacy_json_field_conflicts":4,"features":5,"map_entry":3,"message_set_wire_format":0,"no_standard_descriptor_accessor":1,"uninterpreted_option":6},"4":{"1":0,"11":4,"12":5,"2":1,"3":2,"7":3,"999":6}},".google.protobuf.MethodDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[9]","3":{"client_streaming":4,"input_type":1,"name":0,"options":3,"output_type":2,"server_streaming":5},"4":{"1":0,"2":1,"3":2,"4":3,"5":4,"6":5}},".google.protobuf.MethodOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[17]","3":{"deprecated":0,"features":2,"idempotency_level":1,"uninterpreted_option":3},"4":{"33":0,"34":1,"35":2,"999":3}},".google.protobuf.OneofDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[5]","3":{"name":0,"options":1},"4":{"1":0,"2":1}},".google.protobuf.OneofOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[13]","3":{"features":0,"uninterpreted_option":1},"4":{"1":0,"999":1}},".google.protobuf.ServiceDescriptorProto":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[8]","3":{"method":1,"name":0,"options":2},"4":{"1":0,"2":1,"3":2}},".google.protobuf.ServiceOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[16]","3":{"deprecated":1,"features":0,"uninterpreted_option":2},"4":{"33":1,"34":0,"999":2}},".google.protobuf.SourceCodeInfo":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[21]","3":{"location":0},"4":{"1":0}},".google.protobuf.SourceCodeInfo.Location":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[21].\\"3\\"[0]","3":{"leading_comments":2,"leading_detached_comments":4,"path":0,"span":1,"trailing_comments":3},"4":{"1":0,"2":1,"3":2,"4":3,"6":4}},".google.protobuf.UninterpretedOption":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[18]","3":{"aggregate_value":6,"double_value":4,"identifier_value":1,"name":0,"negative_int_value":3,"positive_int_value":2,"string_value":5},"4":{"2":0,"3":1,"4":2,"5":3,"6":4,"7":5,"8":6}},".google.protobuf.UninterpretedOption.NamePart":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[18].\\"3\\"[0]","3":{"is_extension":1,"name_part":0},"4":{"1":0,"2":1}}},"3":{".google.protobuf.Edition":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"5\\"[0]","3":{"EDITION_1_TEST_ONLY":6,"EDITION_2023":4,"EDITION_2024":5,"EDITION_2_TEST_ONLY":7,"EDITION_99997_TEST_ONLY":8,"EDITION_99998_TEST_ONLY":9,"EDITION_99999_TEST_ONLY":10,"EDITION_LEGACY":1,"EDITION_MAX":11,"EDITION_PROTO2":2,"EDITION_PROTO3":3,"EDITION_UNKNOWN":0},"4":{"0":0,"1":6,"1000":4,"1001":5,"2":7,"2147483647":11,"900":1,"998":2,"999":3,"99997":8,"99998":9,"99999":10}},".google.protobuf.ExtensionRangeOptions.VerificationState":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[3].\\"4\\"[0]","3":{"DECLARATION":0,"UNVERIFIED":1},"4":{"0":0,"1":1}},".google.protobuf.FeatureSet.EnforceNamingStyle":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[6]","3":{"ENFORCE_NAMING_STYLE_UNKNOWN":0,"STYLE2024":1,"STYLE_LEGACY":2},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FeatureSet.EnumType":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[1]","3":{"CLOSED":2,"ENUM_TYPE_UNKNOWN":0,"OPEN":1},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FeatureSet.FieldPresence":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[0]","3":{"EXPLICIT":1,"FIELD_PRESENCE_UNKNOWN":0,"IMPLICIT":2,"LEGACY_REQUIRED":3},"4":{"0":0,"1":1,"2":2,"3":3}},".google.protobuf.FeatureSet.JsonFormat":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[5]","3":{"ALLOW":1,"JSON_FORMAT_UNKNOWN":0,"LEGACY_BEST_EFFORT":2},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FeatureSet.MessageEncoding":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[4]","3":{"DELIMITED":2,"LENGTH_PREFIXED":1,"MESSAGE_ENCODING_UNKNOWN":0},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FeatureSet.RepeatedFieldEncoding":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[2]","3":{"EXPANDED":2,"PACKED":1,"REPEATED_FIELD_ENCODING_UNKNOWN":0},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FeatureSet.Utf8Validation":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[19].\\"4\\"[3]","3":{"NONE":2,"UTF8_VALIDATION_UNKNOWN":0,"VERIFY":1},"4":{"0":0,"2":1,"3":2}},".google.protobuf.FieldDescriptorProto.Label":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[4].\\"4\\"[1]","3":{"LABEL_OPTIONAL":0,"LABEL_REPEATED":1,"LABEL_REQUIRED":2},"4":{"1":0,"2":2,"3":1}},".google.protobuf.FieldDescriptorProto.Type":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[4].\\"4\\"[0]","3":{"TYPE_BOOL":7,"TYPE_BYTES":11,"TYPE_DOUBLE":0,"TYPE_ENUM":13,"TYPE_FIXED32":6,"TYPE_FIXED64":5,"TYPE_FLOAT":1,"TYPE_GROUP":9,"TYPE_INT32":4,"TYPE_INT64":2,"TYPE_MESSAGE":10,"TYPE_SFIXED32":14,"TYPE_SFIXED64":15,"TYPE_SINT32":16,"TYPE_SINT64":17,"TYPE_STRING":8,"TYPE_UINT32":12,"TYPE_UINT64":3},"4":{"1":0,"10":9,"11":10,"12":11,"13":12,"14":13,"15":14,"16":15,"17":16,"18":17,"2":1,"3":2,"4":3,"5":4,"6":5,"7":6,"8":7,"9":8}},".google.protobuf.FieldOptions.CType":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12].\\"4\\"[0]","3":{"CORD":1,"STRING":0,"STRING_PIECE":2},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FieldOptions.JSType":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12].\\"4\\"[1]","3":{"JS_NORMAL":0,"JS_NUMBER":2,"JS_STRING":1},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FieldOptions.OptionRetention":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12].\\"4\\"[2]","3":{"RETENTION_RUNTIME":1,"RETENTION_SOURCE":2,"RETENTION_UNKNOWN":0},"4":{"0":0,"1":1,"2":2}},".google.protobuf.FieldOptions.OptionTargetType":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[12].\\"4\\"[3]","3":{"TARGET_TYPE_ENUM":6,"TARGET_TYPE_ENUM_ENTRY":7,"TARGET_TYPE_EXTENSION_RANGE":2,"TARGET_TYPE_FIELD":4,"TARGET_TYPE_FILE":1,"TARGET_TYPE_MESSAGE":3,"TARGET_TYPE_METHOD":9,"TARGET_TYPE_ONEOF":5,"TARGET_TYPE_SERVICE":8,"TARGET_TYPE_UNKNOWN":0},"4":{"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9}},".google.protobuf.FileOptions.OptimizeMode":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[10].\\"4\\"[0]","3":{"CODE_SIZE":1,"LITE_RUNTIME":2,"SPEED":0},"4":{"1":0,"2":1,"3":2}},".google.protobuf.GeneratedCodeInfo.Annotation.Semantic":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[22].\\"3\\"[0].\\"4\\"[0]","3":{"ALIAS":2,"NONE":0,"SET":1},"4":{"0":0,"1":1,"2":2}},".google.protobuf.MethodOptions.IdempotencyLevel":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[17].\\"4\\"[0]","3":{"IDEMPOTENCY_UNKNOWN":0,"IDEMPOTENT":2,"NO_SIDE_EFFECTS":1},"4":{"0":0,"1":1,"2":2}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS _pb_wkt_struct_proto $$
CREATE FUNCTION _pb_wkt_struct_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/struct.proto","12":"proto3","2":"google.protobuf","4":[{"1":"Struct","2":[{"1":"fields","10":"fields","3":1,"4":3,"5":11,"6":".google.protobuf.Struct.FieldsEntry"}],"3":[{"1":"FieldsEntry","2":[{"1":"key","10":"key","3":1,"4":1,"5":9},{"1":"value","10":"value","3":2,"4":1,"5":11,"6":".google.protobuf.Value"}],"7":{"7":true}}]},{"1":"Value","2":[{"1":"null_value","10":"nullValue","3":1,"4":1,"5":14,"6":".google.protobuf.NullValue","9":0},{"1":"number_value","10":"numberValue","3":2,"4":1,"5":1,"9":0},{"1":"string_value","10":"stringValue","3":3,"4":1,"5":9,"9":0},{"1":"bool_value","10":"boolValue","3":4,"4":1,"5":8,"9":0},{"1":"struct_value","10":"structValue","3":5,"4":1,"5":11,"6":".google.protobuf.Struct","9":0},{"1":"list_value","10":"listValue","3":6,"4":1,"5":11,"6":".google.protobuf.ListValue","9":0}],"8":[{"1":"kind"}]},{"1":"ListValue","2":[{"1":"values","10":"values","3":1,"4":3,"5":11,"6":".google.protobuf.Value"}]}],"5":[{"1":"NullValue","2":[{"1":"NULL_VALUE","2":0}]}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/structpb","31":true,"36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"StructProto"}}]},"2":{".google.protobuf.ListValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[2]","3":{"values":0},"4":{"1":0}},".google.protobuf.Struct":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"fields":0},"4":{"1":0}},".google.protobuf.Struct.FieldsEntry":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0].\\"3\\"[0]","3":{"key":0,"value":1},"4":{"1":0,"2":1}},".google.protobuf.Value":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[1]","3":{"bool_value":3,"list_value":5,"null_value":0,"number_value":1,"string_value":2,"struct_value":4},"4":{"1":0,"2":1,"3":2,"4":3,"5":4,"6":5}}},"3":{".google.protobuf.NullValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"5\\"[0]","3":{"NULL_VALUE":0},"4":{"0":0}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_new $$
CREATE FUNCTION pb_wkt_struct_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_from_json $$
CREATE FUNCTION pb_wkt_struct_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.Struct', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_from_message $$
CREATE FUNCTION pb_wkt_struct_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.Struct', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_to_json $$
CREATE FUNCTION pb_wkt_struct_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_struct_proto(), '.google.protobuf.Struct', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_to_message $$
CREATE FUNCTION pb_wkt_struct_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_struct_proto(), '.google.protobuf.Struct', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_set_fields $$
CREATE FUNCTION pb_wkt_struct_set_fields(proto_data JSON, field_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_get_fields $$
CREATE FUNCTION pb_wkt_struct_get_fields(proto_data JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."1"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_new $$
CREATE FUNCTION pb_wkt_struct_fields_entry_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_from_json $$
CREATE FUNCTION pb_wkt_struct_fields_entry_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.Struct.FieldsEntry', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_from_message $$
CREATE FUNCTION pb_wkt_struct_fields_entry_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.Struct.FieldsEntry', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_to_json $$
CREATE FUNCTION pb_wkt_struct_fields_entry_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_struct_proto(), '.google.protobuf.Struct.FieldsEntry', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_to_message $$
CREATE FUNCTION pb_wkt_struct_fields_entry_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_struct_proto(), '.google.protobuf.Struct.FieldsEntry', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_set_key $$
CREATE FUNCTION pb_wkt_struct_fields_entry_set_key(proto_data JSON, field_value LONGTEXT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_get_key $$
CREATE FUNCTION pb_wkt_struct_fields_entry_get_key(proto_data JSON) RETURNS LONGTEXT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), '');
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_set_value $$
CREATE FUNCTION pb_wkt_struct_fields_entry_set_value(proto_data JSON, field_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_struct_fields_entry_get_value $$
CREATE FUNCTION pb_wkt_struct_fields_entry_get_value(proto_data JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."2"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_new $$
CREATE FUNCTION pb_wkt_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_from_json $$
CREATE FUNCTION pb_wkt_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.Value', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_from_message $$
CREATE FUNCTION pb_wkt_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.Value', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_to_json $$
CREATE FUNCTION pb_wkt_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_struct_proto(), '.google.protobuf.Value', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_to_message $$
CREATE FUNCTION pb_wkt_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_struct_proto(), '.google.protobuf.Value', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_set_null_value $$
CREATE FUNCTION pb_wkt_value_set_null_value(proto_data JSON, field_value INT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_get_null_value $$
CREATE FUNCTION pb_wkt_value_get_null_value(proto_data JSON) RETURNS INT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_set_number_value $$
CREATE FUNCTION pb_wkt_value_set_number_value(proto_data JSON, field_value DOUBLE) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_get_number_value $$
CREATE FUNCTION pb_wkt_value_get_number_value(proto_data JSON) RETURNS DOUBLE DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."2"')), 0.0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_set_string_value $$
CREATE FUNCTION pb_wkt_value_set_string_value(proto_data JSON, field_value LONGTEXT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."3"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_get_string_value $$
CREATE FUNCTION pb_wkt_value_get_string_value(proto_data JSON) RETURNS LONGTEXT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."3"')), '');
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_set_bool_value $$
CREATE FUNCTION pb_wkt_value_set_bool_value(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."4"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_get_bool_value $$
CREATE FUNCTION pb_wkt_value_get_bool_value(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."4"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_set_struct_value $$
CREATE FUNCTION pb_wkt_value_set_struct_value(proto_data JSON, field_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."5"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_get_struct_value $$
CREATE FUNCTION pb_wkt_value_get_struct_value(proto_data JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."5"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_set_list_value $$
CREATE FUNCTION pb_wkt_value_set_list_value(proto_data JSON, field_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."6"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_value_get_list_value $$
CREATE FUNCTION pb_wkt_value_get_list_value(proto_data JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."6"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_new $$
CREATE FUNCTION pb_wkt_list_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_from_json $$
CREATE FUNCTION pb_wkt_list_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.ListValue', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_from_message $$
CREATE FUNCTION pb_wkt_list_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_struct_proto(), '.google.protobuf.ListValue', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_to_json $$
CREATE FUNCTION pb_wkt_list_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_struct_proto(), '.google.protobuf.ListValue', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_to_message $$
CREATE FUNCTION pb_wkt_list_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_struct_proto(), '.google.protobuf.ListValue', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_set_values $$
CREATE FUNCTION pb_wkt_list_value_set_values(proto_data JSON, field_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_list_value_get_values $$
CREATE FUNCTION pb_wkt_list_value_get_values(proto_data JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."1"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_null_value_from_string $$
CREATE FUNCTION pb_wkt_null_value_from_string(enum_name LONGTEXT) RETURNS INT DETERMINISTIC
BEGIN
    CASE enum_name
        WHEN 'NULL_VALUE' THEN RETURN 0;
        ELSE RETURN NULL;
    END CASE;
END $$

DROP FUNCTION IF EXISTS pb_wkt_null_value_to_string $$
CREATE FUNCTION pb_wkt_null_value_to_string(enum_value INT) RETURNS LONGTEXT DETERMINISTIC
BEGIN
    CASE enum_value
        WHEN 0 THEN RETURN 'NULL_VALUE';
        ELSE RETURN NULL;
    END CASE;
END $$

DROP FUNCTION IF EXISTS _pb_wkt_field_mask_proto $$
CREATE FUNCTION _pb_wkt_field_mask_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/field_mask.proto","12":"proto3","2":"google.protobuf","4":[{"1":"FieldMask","2":[{"1":"paths","10":"paths","3":1,"4":3,"5":9}]}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/fieldmaskpb","31":true,"36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"FieldMaskProto"}}]},"2":{".google.protobuf.FieldMask":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"paths":0},"4":{"1":0}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_new $$
CREATE FUNCTION pb_wkt_field_mask_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_from_json $$
CREATE FUNCTION pb_wkt_field_mask_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_field_mask_proto(), '.google.protobuf.FieldMask', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_from_message $$
CREATE FUNCTION pb_wkt_field_mask_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_field_mask_proto(), '.google.protobuf.FieldMask', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_to_json $$
CREATE FUNCTION pb_wkt_field_mask_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_field_mask_proto(), '.google.protobuf.FieldMask', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_to_message $$
CREATE FUNCTION pb_wkt_field_mask_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_field_mask_proto(), '.google.protobuf.FieldMask', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_set_paths $$
CREATE FUNCTION pb_wkt_field_mask_set_paths(proto_data JSON, field_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_field_mask_get_paths $$
CREATE FUNCTION pb_wkt_field_mask_get_paths(proto_data JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."1"');
END $$

DROP FUNCTION IF EXISTS _pb_wkt_wrappers_proto $$
CREATE FUNCTION _pb_wkt_wrappers_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/wrappers.proto","12":"proto3","2":"google.protobuf","4":[{"1":"DoubleValue","2":[{"1":"value","10":"value","3":1,"4":1,"5":1}]},{"1":"FloatValue","2":[{"1":"value","10":"value","3":1,"4":1,"5":2}]},{"1":"Int64Value","2":[{"1":"value","10":"value","3":1,"4":1,"5":3}]},{"1":"UInt64Value","2":[{"1":"value","10":"value","3":1,"4":1,"5":4}]},{"1":"Int32Value","2":[{"1":"value","10":"value","3":1,"4":1,"5":5}]},{"1":"UInt32Value","2":[{"1":"value","10":"value","3":1,"4":1,"5":13}]},{"1":"BoolValue","2":[{"1":"value","10":"value","3":1,"4":1,"5":8}]},{"1":"StringValue","2":[{"1":"value","10":"value","3":1,"4":1,"5":9}]},{"1":"BytesValue","2":[{"1":"value","10":"value","3":1,"4":1,"5":12}]}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/wrapperspb","31":true,"36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"WrappersProto"}}]},"2":{".google.protobuf.BoolValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[6]","3":{"value":0},"4":{"1":0}},".google.protobuf.BytesValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[8]","3":{"value":0},"4":{"1":0}},".google.protobuf.DoubleValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"value":0},"4":{"1":0}},".google.protobuf.FloatValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[1]","3":{"value":0},"4":{"1":0}},".google.protobuf.Int32Value":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[4]","3":{"value":0},"4":{"1":0}},".google.protobuf.Int64Value":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[2]","3":{"value":0},"4":{"1":0}},".google.protobuf.StringValue":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[7]","3":{"value":0},"4":{"1":0}},".google.protobuf.UInt32Value":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[5]","3":{"value":0},"4":{"1":0}},".google.protobuf.UInt64Value":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[3]","3":{"value":0},"4":{"1":0}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_new $$
CREATE FUNCTION pb_wkt_double_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_from_json $$
CREATE FUNCTION pb_wkt_double_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.DoubleValue', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_from_message $$
CREATE FUNCTION pb_wkt_double_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.DoubleValue', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_to_json $$
CREATE FUNCTION pb_wkt_double_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.DoubleValue', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_to_message $$
CREATE FUNCTION pb_wkt_double_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.DoubleValue', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_set_value $$
CREATE FUNCTION pb_wkt_double_value_set_value(proto_data JSON, field_value DOUBLE) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_double_value_get_value $$
CREATE FUNCTION pb_wkt_double_value_get_value(proto_data JSON) RETURNS DOUBLE DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0.0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_new $$
CREATE FUNCTION pb_wkt_float_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_from_json $$
CREATE FUNCTION pb_wkt_float_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.FloatValue', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_from_message $$
CREATE FUNCTION pb_wkt_float_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.FloatValue', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_to_json $$
CREATE FUNCTION pb_wkt_float_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.FloatValue', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_to_message $$
CREATE FUNCTION pb_wkt_float_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.FloatValue', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_set_value $$
CREATE FUNCTION pb_wkt_float_value_set_value(proto_data JSON, field_value FLOAT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_float_value_get_value $$
CREATE FUNCTION pb_wkt_float_value_get_value(proto_data JSON) RETURNS FLOAT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0.0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_new $$
CREATE FUNCTION pb_wkt_int64_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_from_json $$
CREATE FUNCTION pb_wkt_int64_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.Int64Value', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_from_message $$
CREATE FUNCTION pb_wkt_int64_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.Int64Value', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_to_json $$
CREATE FUNCTION pb_wkt_int64_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.Int64Value', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_to_message $$
CREATE FUNCTION pb_wkt_int64_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.Int64Value', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_set_value $$
CREATE FUNCTION pb_wkt_int64_value_set_value(proto_data JSON, field_value BIGINT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int64_value_get_value $$
CREATE FUNCTION pb_wkt_int64_value_get_value(proto_data JSON) RETURNS BIGINT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_new $$
CREATE FUNCTION pb_wkt_uint64_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_from_json $$
CREATE FUNCTION pb_wkt_uint64_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt64Value', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_from_message $$
CREATE FUNCTION pb_wkt_uint64_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt64Value', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_to_json $$
CREATE FUNCTION pb_wkt_uint64_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt64Value', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_to_message $$
CREATE FUNCTION pb_wkt_uint64_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt64Value', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_set_value $$
CREATE FUNCTION pb_wkt_uint64_value_set_value(proto_data JSON, field_value BIGINT UNSIGNED) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint64_value_get_value $$
CREATE FUNCTION pb_wkt_uint64_value_get_value(proto_data JSON) RETURNS BIGINT UNSIGNED DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_new $$
CREATE FUNCTION pb_wkt_int32_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_from_json $$
CREATE FUNCTION pb_wkt_int32_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.Int32Value', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_from_message $$
CREATE FUNCTION pb_wkt_int32_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.Int32Value', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_to_json $$
CREATE FUNCTION pb_wkt_int32_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.Int32Value', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_to_message $$
CREATE FUNCTION pb_wkt_int32_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.Int32Value', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_set_value $$
CREATE FUNCTION pb_wkt_int32_value_set_value(proto_data JSON, field_value INT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_int32_value_get_value $$
CREATE FUNCTION pb_wkt_int32_value_get_value(proto_data JSON) RETURNS INT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_new $$
CREATE FUNCTION pb_wkt_uint32_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_from_json $$
CREATE FUNCTION pb_wkt_uint32_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt32Value', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_from_message $$
CREATE FUNCTION pb_wkt_uint32_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt32Value', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_to_json $$
CREATE FUNCTION pb_wkt_uint32_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt32Value', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_to_message $$
CREATE FUNCTION pb_wkt_uint32_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.UInt32Value', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_set_value $$
CREATE FUNCTION pb_wkt_uint32_value_set_value(proto_data JSON, field_value INT UNSIGNED) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_uint32_value_get_value $$
CREATE FUNCTION pb_wkt_uint32_value_get_value(proto_data JSON) RETURNS INT UNSIGNED DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_new $$
CREATE FUNCTION pb_wkt_bool_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_from_json $$
CREATE FUNCTION pb_wkt_bool_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.BoolValue', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_from_message $$
CREATE FUNCTION pb_wkt_bool_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.BoolValue', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_to_json $$
CREATE FUNCTION pb_wkt_bool_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.BoolValue', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_to_message $$
CREATE FUNCTION pb_wkt_bool_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.BoolValue', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_set_value $$
CREATE FUNCTION pb_wkt_bool_value_set_value(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bool_value_get_value $$
CREATE FUNCTION pb_wkt_bool_value_get_value(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."1"');
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_new $$
CREATE FUNCTION pb_wkt_string_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_from_json $$
CREATE FUNCTION pb_wkt_string_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.StringValue', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_from_message $$
CREATE FUNCTION pb_wkt_string_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.StringValue', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_to_json $$
CREATE FUNCTION pb_wkt_string_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.StringValue', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_to_message $$
CREATE FUNCTION pb_wkt_string_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.StringValue', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_set_value $$
CREATE FUNCTION pb_wkt_string_value_set_value(proto_data JSON, field_value LONGTEXT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_string_value_get_value $$
CREATE FUNCTION pb_wkt_string_value_get_value(proto_data JSON) RETURNS LONGTEXT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), '');
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_new $$
CREATE FUNCTION pb_wkt_bytes_value_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_from_json $$
CREATE FUNCTION pb_wkt_bytes_value_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.BytesValue', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_from_message $$
CREATE FUNCTION pb_wkt_bytes_value_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_wrappers_proto(), '.google.protobuf.BytesValue', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_to_json $$
CREATE FUNCTION pb_wkt_bytes_value_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_wrappers_proto(), '.google.protobuf.BytesValue', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_to_message $$
CREATE FUNCTION pb_wkt_bytes_value_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_wrappers_proto(), '.google.protobuf.BytesValue', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_set_value $$
CREATE FUNCTION pb_wkt_bytes_value_set_value(proto_data JSON, field_value LONGBLOB) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_bytes_value_get_value $$
CREATE FUNCTION pb_wkt_bytes_value_get_value(proto_data JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), X'');
END $$

DROP FUNCTION IF EXISTS _pb_wkt_timestamp_proto $$
CREATE FUNCTION _pb_wkt_timestamp_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/timestamp.proto","12":"proto3","2":"google.protobuf","4":[{"1":"Timestamp","2":[{"1":"seconds","10":"seconds","3":1,"4":1,"5":3},{"1":"nanos","10":"nanos","3":2,"4":1,"5":5}]}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/timestamppb","31":true,"36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"TimestampProto"}}]},"2":{".google.protobuf.Timestamp":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"nanos":1,"seconds":0},"4":{"1":0,"2":1}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_new $$
CREATE FUNCTION pb_wkt_timestamp_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_from_json $$
CREATE FUNCTION pb_wkt_timestamp_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_timestamp_proto(), '.google.protobuf.Timestamp', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_from_message $$
CREATE FUNCTION pb_wkt_timestamp_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_timestamp_proto(), '.google.protobuf.Timestamp', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_to_json $$
CREATE FUNCTION pb_wkt_timestamp_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_timestamp_proto(), '.google.protobuf.Timestamp', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_to_message $$
CREATE FUNCTION pb_wkt_timestamp_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_timestamp_proto(), '.google.protobuf.Timestamp', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_set_seconds $$
CREATE FUNCTION pb_wkt_timestamp_set_seconds(proto_data JSON, field_value BIGINT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_get_seconds $$
CREATE FUNCTION pb_wkt_timestamp_get_seconds(proto_data JSON) RETURNS BIGINT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_set_nanos $$
CREATE FUNCTION pb_wkt_timestamp_set_nanos(proto_data JSON, field_value INT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_timestamp_get_nanos $$
CREATE FUNCTION pb_wkt_timestamp_get_nanos(proto_data JSON) RETURNS INT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."2"')), 0);
END $$

DROP FUNCTION IF EXISTS _pb_wkt_duration_proto $$
CREATE FUNCTION _pb_wkt_duration_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/duration.proto","12":"proto3","2":"google.protobuf","4":[{"1":"Duration","2":[{"1":"seconds","10":"seconds","3":1,"4":1,"5":3},{"1":"nanos","10":"nanos","3":2,"4":1,"5":5}]}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/durationpb","31":true,"36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"DurationProto"}}]},"2":{".google.protobuf.Duration":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"nanos":1,"seconds":0},"4":{"1":0,"2":1}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_new $$
CREATE FUNCTION pb_wkt_duration_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_from_json $$
CREATE FUNCTION pb_wkt_duration_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_duration_proto(), '.google.protobuf.Duration', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_from_message $$
CREATE FUNCTION pb_wkt_duration_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_duration_proto(), '.google.protobuf.Duration', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_to_json $$
CREATE FUNCTION pb_wkt_duration_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_duration_proto(), '.google.protobuf.Duration', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_to_message $$
CREATE FUNCTION pb_wkt_duration_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_duration_proto(), '.google.protobuf.Duration', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_set_seconds $$
CREATE FUNCTION pb_wkt_duration_set_seconds(proto_data JSON, field_value BIGINT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_get_seconds $$
CREATE FUNCTION pb_wkt_duration_get_seconds(proto_data JSON) RETURNS BIGINT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), 0);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_set_nanos $$
CREATE FUNCTION pb_wkt_duration_set_nanos(proto_data JSON, field_value INT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_duration_get_nanos $$
CREATE FUNCTION pb_wkt_duration_get_nanos(proto_data JSON) RETURNS INT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."2"')), 0);
END $$

DROP FUNCTION IF EXISTS _pb_wkt_any_proto $$
CREATE FUNCTION _pb_wkt_any_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/any.proto","12":"proto3","2":"google.protobuf","4":[{"1":"Any","2":[{"1":"type_url","10":"typeUrl","3":1,"4":1,"5":9},{"1":"value","10":"value","3":2,"4":1,"5":12}]}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/anypb","36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"AnyProto"}}]},"2":{".google.protobuf.Any":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"type_url":0,"value":1},"4":{"1":0,"2":1}}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_new $$
CREATE FUNCTION pb_wkt_any_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_from_json $$
CREATE FUNCTION pb_wkt_any_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_any_proto(), '.google.protobuf.Any', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_from_message $$
CREATE FUNCTION pb_wkt_any_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_any_proto(), '.google.protobuf.Any', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_to_json $$
CREATE FUNCTION pb_wkt_any_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_any_proto(), '.google.protobuf.Any', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_to_message $$
CREATE FUNCTION pb_wkt_any_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_any_proto(), '.google.protobuf.Any', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_set_type_url $$
CREATE FUNCTION pb_wkt_any_set_type_url(proto_data JSON, field_value LONGTEXT) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_get_type_url $$
CREATE FUNCTION pb_wkt_any_get_type_url(proto_data JSON) RETURNS LONGTEXT DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."1"')), '');
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_set_value $$
CREATE FUNCTION pb_wkt_any_set_value(proto_data JSON, field_value LONGBLOB) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_wkt_any_get_value $$
CREATE FUNCTION pb_wkt_any_get_value(proto_data JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN COALESCE(JSON_UNQUOTE(JSON_EXTRACT(proto_data, '$."2"')), X'');
END $$

DROP FUNCTION IF EXISTS _pb_wkt_empty_proto $$
CREATE FUNCTION _pb_wkt_empty_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"google/protobuf/empty.proto","12":"proto3","2":"google.protobuf","4":[{"1":"Empty"}],"8":{"1":"com.google.protobuf","10":true,"11":"google.golang.org/protobuf/types/known/emptypb","31":true,"36":"GPB","37":"Google.Protobuf.WellKnownTypes","8":"EmptyProto"}}]},"2":{".google.protobuf.Empty":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]"}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_wkt_empty_new $$
CREATE FUNCTION pb_wkt_empty_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_wkt_empty_from_json $$
CREATE FUNCTION pb_wkt_empty_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_wkt_empty_proto(), '.google.protobuf.Empty', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_empty_from_message $$
CREATE FUNCTION pb_wkt_empty_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_wkt_empty_proto(), '.google.protobuf.Empty', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_empty_to_json $$
CREATE FUNCTION pb_wkt_empty_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_wkt_empty_proto(), '.google.protobuf.Empty', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_wkt_empty_to_message $$
CREATE FUNCTION pb_wkt_empty_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_wkt_empty_proto(), '.google.protobuf.Empty', proto_data, marshal_options);
END $$

-- Code generated by protoc-gen-mysql. DO NOT EDIT.

DELIMITER $$

DROP FUNCTION IF EXISTS _pb_options_proto $$
CREATE FUNCTION _pb_options_proto() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('{"1":{"1":[{"1":"json_options.proto","12":"proto3","2":"mysqlprotobuf","4":[{"1":"JsonUnmarshalOptions","2":[{"1":"ignore_unknown_fields","10":"ignoreUnknownFields","3":1,"4":1,"5":8},{"1":"ignore_unknown_enums","10":"ignoreUnknownEnums","3":2,"4":1,"5":8}]},{"1":"JsonMarshalOptions","2":[{"1":"emit_default_values","10":"emitDefaultValues","3":1,"4":1,"5":8},{"1":"use_enum_numbers","10":"useEnumNumbers","3":2,"4":1,"5":8},{"1":"emit_int64s_as_numbers","10":"emitInt64sAsNumbers","3":3,"4":1,"5":8},{"1":"treat_wkt_as_normal_types","10":"treatWktAsNormalTypes","3":4,"4":1,"5":8}]}]},{"1":"marshal_options.proto","12":"proto3","2":"mysqlprotobuf","4":[{"1":"MarshalOptions"},{"1":"UnmarshalOptions"}]}]},"2":{".mysqlprotobuf.JsonMarshalOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[1]","3":{"emit_default_values":0,"emit_int64s_as_numbers":2,"treat_wkt_as_normal_types":3,"use_enum_numbers":1},"4":{"1":0,"2":1,"3":2,"4":3}},".mysqlprotobuf.JsonUnmarshalOptions":{"1":"$.\\"1\\"[0]","2":"$.\\"1\\"[0].\\"4\\"[0]","3":{"ignore_unknown_enums":1,"ignore_unknown_fields":0},"4":{"1":0,"2":1}},".mysqlprotobuf.MarshalOptions":{"1":"$.\\"1\\"[1]","2":"$.\\"1\\"[1].\\"4\\"[0]"},".mysqlprotobuf.UnmarshalOptions":{"1":"$.\\"1\\"[1]","2":"$.\\"1\\"[1].\\"4\\"[1]"}}}' AS JSON);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_new $$
CREATE FUNCTION pb_json_unmarshal_options_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_from_json $$
CREATE FUNCTION pb_json_unmarshal_options_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_options_proto(), '.mysqlprotobuf.JsonUnmarshalOptions', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_from_message $$
CREATE FUNCTION pb_json_unmarshal_options_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_options_proto(), '.mysqlprotobuf.JsonUnmarshalOptions', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_to_json $$
CREATE FUNCTION pb_json_unmarshal_options_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_options_proto(), '.mysqlprotobuf.JsonUnmarshalOptions', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_to_message $$
CREATE FUNCTION pb_json_unmarshal_options_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_options_proto(), '.mysqlprotobuf.JsonUnmarshalOptions', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_set_ignore_unknown_fields $$
CREATE FUNCTION pb_json_unmarshal_options_set_ignore_unknown_fields(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_get_ignore_unknown_fields $$
CREATE FUNCTION pb_json_unmarshal_options_get_ignore_unknown_fields(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."1"');
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_set_ignore_unknown_enums $$
CREATE FUNCTION pb_json_unmarshal_options_set_ignore_unknown_enums(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_json_unmarshal_options_get_ignore_unknown_enums $$
CREATE FUNCTION pb_json_unmarshal_options_get_ignore_unknown_enums(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."2"');
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_new $$
CREATE FUNCTION pb_json_marshal_options_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_from_json $$
CREATE FUNCTION pb_json_marshal_options_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_options_proto(), '.mysqlprotobuf.JsonMarshalOptions', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_from_message $$
CREATE FUNCTION pb_json_marshal_options_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_options_proto(), '.mysqlprotobuf.JsonMarshalOptions', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_to_json $$
CREATE FUNCTION pb_json_marshal_options_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_options_proto(), '.mysqlprotobuf.JsonMarshalOptions', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_to_message $$
CREATE FUNCTION pb_json_marshal_options_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_options_proto(), '.mysqlprotobuf.JsonMarshalOptions', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_set_emit_default_values $$
CREATE FUNCTION pb_json_marshal_options_set_emit_default_values(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."1"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_get_emit_default_values $$
CREATE FUNCTION pb_json_marshal_options_get_emit_default_values(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."1"');
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_set_use_enum_numbers $$
CREATE FUNCTION pb_json_marshal_options_set_use_enum_numbers(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."2"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_get_use_enum_numbers $$
CREATE FUNCTION pb_json_marshal_options_get_use_enum_numbers(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."2"');
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_set_emit_int64s_as_numbers $$
CREATE FUNCTION pb_json_marshal_options_set_emit_int64s_as_numbers(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."3"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_get_emit_int64s_as_numbers $$
CREATE FUNCTION pb_json_marshal_options_get_emit_int64s_as_numbers(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."3"');
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_set_treat_wkt_as_normal_types $$
CREATE FUNCTION pb_json_marshal_options_set_treat_wkt_as_normal_types(proto_data JSON, field_value BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_SET(proto_data, '$."4"', field_value);
END $$

DROP FUNCTION IF EXISTS pb_json_marshal_options_get_treat_wkt_as_normal_types $$
CREATE FUNCTION pb_json_marshal_options_get_treat_wkt_as_normal_types(proto_data JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
    RETURN JSON_EXTRACT(proto_data, '$."4"');
END $$

DROP FUNCTION IF EXISTS pb_marshal_options_new $$
CREATE FUNCTION pb_marshal_options_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_marshal_options_from_json $$
CREATE FUNCTION pb_marshal_options_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_options_proto(), '.mysqlprotobuf.MarshalOptions', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_marshal_options_from_message $$
CREATE FUNCTION pb_marshal_options_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_options_proto(), '.mysqlprotobuf.MarshalOptions', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_marshal_options_to_json $$
CREATE FUNCTION pb_marshal_options_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_options_proto(), '.mysqlprotobuf.MarshalOptions', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_marshal_options_to_message $$
CREATE FUNCTION pb_marshal_options_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_options_proto(), '.mysqlprotobuf.MarshalOptions', proto_data, marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_unmarshal_options_new $$
CREATE FUNCTION pb_unmarshal_options_new() RETURNS JSON DETERMINISTIC
BEGIN
    RETURN JSON_OBJECT();
END $$

DROP FUNCTION IF EXISTS pb_unmarshal_options_from_json $$
CREATE FUNCTION pb_unmarshal_options_from_json(json_data JSON, json_unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_json_to_number_json(_pb_options_proto(), '.mysqlprotobuf.UnmarshalOptions', json_data, json_unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_unmarshal_options_from_message $$
CREATE FUNCTION pb_unmarshal_options_from_message(message_data LONGBLOB, unmarshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_message_to_number_json(_pb_options_proto(), '.mysqlprotobuf.UnmarshalOptions', message_data, unmarshal_options);
END $$

DROP FUNCTION IF EXISTS pb_unmarshal_options_to_json $$
CREATE FUNCTION pb_unmarshal_options_to_json(proto_data JSON, json_marshal_options JSON) RETURNS JSON DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_json(_pb_options_proto(), '.mysqlprotobuf.UnmarshalOptions', proto_data, json_marshal_options);
END $$

DROP FUNCTION IF EXISTS pb_unmarshal_options_to_message $$
CREATE FUNCTION pb_unmarshal_options_to_message(proto_data JSON, marshal_options JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
    RETURN _pb_number_json_to_message(_pb_options_proto(), '.mysqlprotobuf.UnmarshalOptions', proto_data, marshal_options);
END $$

