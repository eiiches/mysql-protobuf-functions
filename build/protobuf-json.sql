-- Code generated by scripts/common.mk; DO NOT EDIT.

DELIMITER $$

DROP FUNCTION IF EXISTS _pb_util_snake_to_lower_camel $$
CREATE FUNCTION _pb_util_snake_to_lower_camel(s TEXT) RETURNS TEXT DETERMINISTIC
BEGIN
	-- TODO: implement
	RETURN s;
END $$

DROP PROCEDURE IF EXISTS _pb_wire_json_get_primitive_field_as_json $$
CREATE PROCEDURE _pb_wire_json_get_primitive_field_as_json(IN wire_json JSON, IN field_number INT, IN field_type INT, IN is_repeated BOOLEAN, IN has_field_presence BOOLEAN, IN as_number_json BOOLEAN, OUT field_json_value JSON)
BEGIN
	DECLARE message_text TEXT;
	DECLARE boolean_value BOOLEAN;

	CASE field_type
	WHEN 1 THEN -- double
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_double_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_double_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 2 THEN -- float
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_float_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_float_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 3 THEN -- int64
		IF is_repeated THEN
			IF as_number_json THEN
				SET field_json_value = pb_wire_json_get_repeated_int64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_int64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			IF as_number_json THEN
				SET field_json_value = CAST(pb_wire_json_get_int64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(pb_wire_json_get_int64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS CHAR));
			END IF;
		END IF;
	WHEN 4 THEN -- uint64
		IF is_repeated THEN
			IF as_number_json THEN
				SET field_json_value = pb_wire_json_get_repeated_uint64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_uint64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			IF as_number_json THEN
				SET field_json_value = CAST(pb_wire_json_get_uint64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(pb_wire_json_get_uint64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS CHAR));
			END IF;
		END IF;
	WHEN 5 THEN -- int32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_int32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_int32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 6 THEN -- fixed64
		IF is_repeated THEN
			IF as_number_json THEN
				SET field_json_value = pb_wire_json_get_repeated_fixed64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_fixed64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			IF as_number_json THEN
				SET field_json_value = CAST(pb_wire_json_get_fixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(pb_wire_json_get_fixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS CHAR));
			END IF;
		END IF;
	WHEN 7 THEN -- fixed32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_fixed32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_fixed32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 8 THEN -- bool
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_bool_field_as_json_array(wire_json, field_number);
		ELSE
			SET boolean_value = pb_wire_json_get_bool_field(wire_json, field_number, IF(has_field_presence, NULL, FALSE));
			IF boolean_value IS NULL THEN
				SET field_json_value = NULL;
			ELSE
				-- See https://bugs.mysql.com/bug.php?id=79813
				SET field_json_value = CAST((boolean_value IS TRUE) AS JSON);
			END IF;
		END IF;
	WHEN 9 THEN -- string
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_string_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = JSON_QUOTE(pb_wire_json_get_string_field(wire_json, field_number, IF(has_field_presence, NULL, '')));
		END IF;
	WHEN 12 THEN -- bytes
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_bytes_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = JSON_QUOTE(TO_BASE64(pb_wire_json_get_bytes_field(wire_json, field_number, IF(has_field_presence, NULL, _binary X''))));
		END IF;
	WHEN 13 THEN -- uint32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_uint32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_uint32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 15 THEN -- sfixed32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_sfixed32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_sfixed32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 16 THEN -- sfixed64
		IF is_repeated THEN
			IF as_number_json THEN
				SET field_json_value = pb_wire_json_get_repeated_sfixed64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_sfixed64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			IF as_number_json THEN
				SET field_json_value = CAST(pb_wire_json_get_sfixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(pb_wire_json_get_sfixed64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS CHAR));
			END IF;
		END IF;
	WHEN 17 THEN -- sint32
		IF is_repeated THEN
			SET field_json_value = pb_wire_json_get_repeated_sint32_field_as_json_array(wire_json, field_number);
		ELSE
			SET field_json_value = CAST(pb_wire_json_get_sint32_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
		END IF;
	WHEN 18 THEN -- sint64
		IF is_repeated THEN
			IF as_number_json THEN
				SET field_json_value = pb_wire_json_get_repeated_sint64_field_as_json_array(wire_json, field_number);
			ELSE
				SET field_json_value = pb_wire_json_get_repeated_sint64_field_as_json_string_array(wire_json, field_number);
			END IF;
		ELSE
			IF as_number_json THEN
				SET field_json_value = CAST(pb_wire_json_get_sint64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
			ELSE
				SET field_json_value = JSON_QUOTE(CAST(pb_wire_json_get_sint64_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS CHAR));
			END IF;
		END IF;
	ELSE
		SET message_text = CONCAT('_pb_message_to_json: unknown field_type `', field_type, '` for field `', field_name, '` (', field_number, ').');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_timestamp_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_timestamp_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE seconds BIGINT;
	DECLARE nanos INT;

	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE uint_value BIGINT;
	DECLARE datetime_part TEXT;

	SET seconds = 0;
	SET nanos = 0;

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 0 THEN
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 1 THEN
				SET seconds = _pb_util_reinterpret_uint64_as_int64(uint_value);
			WHEN 2 THEN
				SET nanos = _pb_util_reinterpret_uint64_as_int64(uint_value);
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	SET seconds = seconds + FLOOR(nanos / 1000000000);

	IF seconds = 0 THEN
		SET datetime_part = '1970-01-01 00:00:00';
	ELSE
		SET datetime_part = CONVERT_TZ(FROM_UNIXTIME(seconds), @@session.time_zone, '+00:00');
	END IF;

	RETURN JSON_QUOTE(CONCAT(REPLACE(datetime_part, " ", "T"), _pb_util_format_fractional_seconds(nanos), "Z"));
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_duration_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_duration_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE seconds BIGINT;
	DECLARE nanos INT;

	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE uint_value BIGINT;

	SET seconds = 0;
	SET nanos = 0;

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 0 THEN
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 1 THEN
				SET seconds = _pb_util_reinterpret_uint64_as_int64(uint_value);
			WHEN 2 THEN
				SET nanos = _pb_util_reinterpret_uint64_as_int64(uint_value);
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	SET seconds = seconds + FLOOR(nanos / 1000000000);

	RETURN JSON_QUOTE(CONCAT(CAST(seconds AS CHAR), _pb_util_format_fractional_seconds(nanos), 's'));
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_struct_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_struct_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE object_key TEXT;
	DECLARE object_value JSON;
	DECLARE result JSON;

	SET result = JSON_OBJECT();

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 2 THEN
			SET element = pb_message_to_wire_json(FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v'))));
			CASE field_number
			WHEN 1 THEN
				SET object_key = pb_wire_json_get_string_field(element, 1, '');
				SET object_value = _pb_wire_json_decode_wkt_value_as_json(pb_message_to_wire_json(pb_wire_json_get_message_field(element, 2, _binary X'')));
				SET result = JSON_MERGE(result, JSON_OBJECT(object_key, object_value));
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN result;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_value_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_value_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE result JSON;
	DECLARE uint_value BIGINT;
	DECLARE bytes_value LONGBLOB;

	SET result = JSON_OBJECT();

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 0 THEN -- VARINT
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 1 THEN -- null_value
				SET result = NULL;
			WHEN 4 THEN -- bool_value
				SET result = CAST(((uint_value <> 0) IS TRUE) AS JSON);
			END CASE;
		WHEN 2 THEN -- LEN
			SET bytes_value = FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v')));
			CASE field_number
			WHEN 3 THEN -- string_value
				SET result = JSON_QUOTE(CONVERT(bytes_value USING utf8mb4));
			WHEN 5 THEN -- struct_value
				SET result = _pb_wire_json_decode_wkt_struct_as_json(pb_message_to_wire_json(bytes_value));
			WHEN 6 THEN -- list_value
				SET result = _pb_wire_json_decode_wkt_list_value_as_json(pb_message_to_wire_json(bytes_value));
			END CASE;
		WHEN 1 THEN -- I64
			SET uint_value = CAST(JSON_EXTRACT(element, '$.v') AS UNSIGNED);
			CASE field_number
			WHEN 2 THEN -- double_value
				SET result = CAST(_pb_util_reinterpret_uint64_as_double(uint_value) AS JSON);
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN result;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_list_value_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_list_value_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE result JSON;
	DECLARE bytes_value LONGBLOB;

	SET result = JSON_ARRAY();

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 2 THEN -- LEN
			SET bytes_value = FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v')));
			CASE field_number
			WHEN 1 THEN -- values
				SET result = JSON_ARRAY_APPEND(result, '$', _pb_wire_json_decode_wkt_value_as_json(pb_message_to_wire_json(bytes_value)));
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN result;
END $$

DROP FUNCTION IF EXISTS _pb_util_format_fractional_seconds $$
CREATE FUNCTION _pb_util_format_fractional_seconds(nanos INT) RETURNS TEXT DETERMINISTIC
BEGIN
	SET nanos = nanos % 1000000000;
	IF nanos = 0 THEN
		RETURN '';
	ELSEIF nanos % 1000000 = 0 THEN
		RETURN CONCAT('.', CAST(FLOOR(nanos / 1000000) AS CHAR)); -- 3 digits
	ELSEIF nanos % 1000 = 0 THEN
		RETURN CONCAT('.', CAST(FLOOR(nanos / 1000) AS CHAR)); -- 6 digits
	ELSE
		RETURN CONCAT('.', CAST(nanos AS CHAR)); -- 9 digits
	END IF;
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_field_mask_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_field_mask_as_json(wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE wire_type INT;
	DECLARE field_number INT;
	DECLARE result TEXT;
	DECLARE string_value TEXT;
	DECLARE sep TEXT;

	SET result = '';
	SET sep = '';

	SET elements = JSON_EXTRACT(wire_json, '$.*[*]');
	SET element_index = 0;
	SET element_count = JSON_LENGTH(elements);
	WHILE element_index < element_count DO
		SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET wire_type = JSON_EXTRACT(element, '$.t');
		SET field_number = JSON_EXTRACT(element, '$.n');

		CASE wire_type
		WHEN 2 THEN -- LEN
			SET string_value = CONVERT(FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(element, '$.v'))) USING utf8mb4);
			CASE field_number
			WHEN 1 THEN -- values
				SET result = CONCAT(result, sep, string_value);
				SET sep = ',';
			END CASE;
		END CASE;

		SET element_index = element_index + 1;
	END WHILE;

	RETURN JSON_QUOTE(result);
END $$

DROP FUNCTION IF EXISTS _pb_wire_json_decode_wkt_as_json $$
CREATE FUNCTION _pb_wire_json_decode_wkt_as_json(wire_json JSON, full_type_name TEXT, as_number_json BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
	CASE full_type_name
	WHEN '.google.protobuf.Timestamp' THEN
		RETURN _pb_wire_json_decode_wkt_timestamp_as_json(wire_json);
	WHEN '.google.protobuf.Duration' THEN
		RETURN _pb_wire_json_decode_wkt_duration_as_json(wire_json);
	WHEN '.google.protobuf.Struct' THEN
		RETURN _pb_wire_json_decode_wkt_struct_as_json(wire_json);
	WHEN '.google.protobuf.Value' THEN
		RETURN _pb_wire_json_decode_wkt_value_as_json(wire_json);
	WHEN '.google.protobuf.ListValue' THEN
		RETURN _pb_wire_json_decode_wkt_list_value_as_json(wire_json);
	WHEN '.google.protobuf.Empty' THEN
		RETURN JSON_OBJECT();
	WHEN '.google.protobuf.DoubleValue' THEN
		RETURN CAST(pb_wire_json_get_double_field(wire_json, 1, 0.0) AS JSON);
	WHEN '.google.protobuf.FloatValue' THEN
		RETURN CAST(pb_wire_json_get_float_field(wire_json, 1, 0.0) AS JSON);
	WHEN '.google.protobuf.Int64Value' THEN
		IF as_number_json THEN
			RETURN CAST(pb_wire_json_get_int64_field(wire_json, 1, 0) AS JSON);
		ELSE
			RETURN JSON_QUOTE(CAST(pb_wire_json_get_int64_field(wire_json, 1, 0) AS CHAR));
		END IF;
	WHEN '.google.protobuf.UInt64Value' THEN
		IF as_number_json THEN
			RETURN CAST(pb_wire_json_get_uint64_field(wire_json, 1, 0) AS JSON);
		ELSE
			RETURN JSON_QUOTE(CAST(pb_wire_json_get_uint64_field(wire_json, 1, 0) AS CHAR));
		END IF;
	WHEN '.google.protobuf.Int32Value' THEN
		RETURN CAST(pb_wire_json_get_int32_field(wire_json, 1, 0) AS JSON);
	WHEN '.google.protobuf.UInt32Value' THEN
		RETURN CAST(pb_wire_json_get_uint32_field(wire_json, 1, 0) AS JSON);
	WHEN '.google.protobuf.BoolValue' THEN
		RETURN CAST((pb_wire_json_get_bool_field(wire_json, 1, FALSE) IS TRUE) AS JSON);
	WHEN '.google.protobuf.StringValue' THEN
		RETURN JSON_QUOTE(pb_wire_json_get_string_field(wire_json, 1, ''));
	WHEN '.google.protobuf.BytesValue' THEN
		RETURN JSON_QUOTE(TO_BASE64(pb_wire_json_get_bytes_field(wire_json, 1, _binary X'')));
	WHEN '.google.protobuf.FieldMask' THEN
		RETURN _pb_wire_json_decode_wkt_field_mask_as_json(wire_json);
	ELSE
		RETURN NULL;
	END CASE;
END $$

DELIMITER $$

-- Helper function to get message descriptor from descriptor set JSON
DROP FUNCTION IF EXISTS _pb_get_message_descriptor $$
CREATE FUNCTION _pb_get_message_descriptor(descriptor_set_json JSON, type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE type_index JSON;
	DECLARE type_paths JSON;
	DECLARE kind INT;
	DECLARE file_path TEXT;
	DECLARE type_path TEXT;

	-- Get type index (element 2)
	SET type_index = JSON_EXTRACT(descriptor_set_json, '$[2]');

	-- Get paths for the type
	SET type_paths = JSON_EXTRACT(type_index, CONCAT('$."', type_name, '"'));

	IF type_paths IS NULL THEN
		RETURN NULL;
	END IF;

	-- Extract kind, file path and type path
	SET kind = JSON_EXTRACT(type_paths, '$[0]');
	SET file_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$[1]'));
	SET type_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$[2]'));

	-- Verify this is a message type (kind = 11)
	IF kind <> 11 THEN
		RETURN NULL;
	END IF;

	-- Return the message descriptor
	RETURN JSON_EXTRACT(descriptor_set_json, type_path);
END $$

-- Helper function to get enum descriptor from descriptor set JSON
DROP FUNCTION IF EXISTS _pb_get_enum_descriptor $$
CREATE FUNCTION _pb_get_enum_descriptor(descriptor_set_json JSON, type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE type_index JSON;
	DECLARE type_paths JSON;
	DECLARE kind INT;
	DECLARE file_path TEXT;
	DECLARE type_path TEXT;

	-- Get type index (element 2)
	SET type_index = JSON_EXTRACT(descriptor_set_json, '$[2]');

	-- Get paths for the type
	SET type_paths = JSON_EXTRACT(type_index, CONCAT('$."', type_name, '"'));

	IF type_paths IS NULL THEN
		RETURN NULL;
	END IF;

	-- Extract kind, file path and type path
	SET kind = JSON_EXTRACT(type_paths, '$[0]');
	SET file_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$[1]'));
	SET type_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$[2]'));

	-- Verify this is an enum type (kind = 14)
	IF kind <> 14 THEN
		RETURN NULL;
	END IF;

	-- Return the enum descriptor
	RETURN JSON_EXTRACT(descriptor_set_json, type_path);
END $$

-- Helper procedure to convert enum value to JSON using descriptor set
DROP PROCEDURE IF EXISTS _pb_enum_to_json $$
CREATE PROCEDURE _pb_enum_to_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN enum_value_number INT, OUT result JSON)
proc: BEGIN
	DECLARE enum_descriptor JSON;
	DECLARE enum_values JSON;
	DECLARE enum_value JSON;
	DECLARE enum_count INT;
	DECLARE enum_index INT;
	DECLARE current_number INT;
	DECLARE current_name TEXT;

	SET enum_descriptor = _pb_get_enum_descriptor(descriptor_set_json, full_type_name);

	IF enum_descriptor IS NULL THEN
		SET result = NULL;
		LEAVE proc;
	END IF;

	-- Get enum values array (field 2 in EnumDescriptorProto)
	SET enum_values = JSON_EXTRACT(enum_descriptor, '$."2"');

	IF enum_values IS NULL THEN
		SET result = NULL;
		LEAVE proc;
	END IF;

	SET enum_count = JSON_LENGTH(enum_values);
	SET enum_index = 0;

	-- Find enum value by number
	WHILE enum_index < enum_count DO
		SET enum_value = JSON_EXTRACT(enum_values, CONCAT('$[', enum_index, ']'));
		SET current_number = JSON_EXTRACT(enum_value, '$."2"'); -- number field

		IF current_number = enum_value_number THEN
			SET current_name = JSON_UNQUOTE(JSON_EXTRACT(enum_value, '$."1"')); -- name field
			SET result = JSON_QUOTE(current_name);
			LEAVE proc;
		END IF;

		SET enum_index = enum_index + 1;
	END WHILE;

	-- If not found, return the numeric value (Proto3 behavior for unknown enum values)
	IF result IS NULL THEN
		SET result = CAST(enum_value_number AS JSON);
	END IF;
END $$

-- Helper function to get file descriptor for a type
DROP FUNCTION IF EXISTS _pb_get_file_descriptor $$
CREATE FUNCTION _pb_get_file_descriptor(descriptor_set_json JSON, type_name TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE type_index JSON;
	DECLARE type_paths JSON;
	DECLARE file_path TEXT;

	-- Get type index (element 2)
	SET type_index = JSON_EXTRACT(descriptor_set_json, '$[2]');

	-- Get paths for the type
	SET type_paths = JSON_EXTRACT(type_index, CONCAT('$."', type_name, '"'));

	IF type_paths IS NULL THEN
		RETURN NULL;
	END IF;

	-- Extract file path (now at index 1)
	SET file_path = JSON_UNQUOTE(JSON_EXTRACT(type_paths, '$[1]'));

	-- Return the file descriptor
	RETURN JSON_EXTRACT(descriptor_set_json, file_path);
END $$

-- Main procedure for converting protobuf message to JSON using descriptor set
DROP PROCEDURE IF EXISTS _pb_wire_json_to_json_proc $$
CREATE PROCEDURE _pb_wire_json_to_json_proc(IN descriptor_set_json JSON, IN full_type_name TEXT, IN wire_json JSON, IN as_number_json BOOLEAN, OUT result JSON)
proc: BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';

	DECLARE message_text TEXT;
	DECLARE message_descriptor JSON;
	DECLARE file_descriptor JSON;
	DECLARE syntax TEXT;
	DECLARE fields JSON;
	DECLARE field_count INT;
	DECLARE field_index INT;
	DECLARE field_descriptor JSON;

	-- Field properties
	DECLARE field_number INT;
	DECLARE field_name TEXT;
	DECLARE field_label INT;
	DECLARE field_type INT;
	DECLARE field_type_name TEXT;
	DECLARE json_name TEXT;
	DECLARE proto3_optional BOOLEAN;
	DECLARE oneof_index INT;
	DECLARE default_value TEXT;

	-- Processing variables
	DECLARE is_repeated BOOLEAN;
	DECLARE has_field_presence BOOLEAN;
	DECLARE field_json_value JSON;
	DECLARE json_field_name TEXT;
	DECLARE bytes_value LONGBLOB;
	DECLARE nested_json_value JSON;
	DECLARE elements JSON;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;

	-- Map handling
	DECLARE is_map BOOLEAN;
	DECLARE map_entry_descriptor JSON;
	DECLARE map_key_field JSON;
	DECLARE map_value_field JSON;
	DECLARE map_key_type INT;
	DECLARE map_value_type INT;
	DECLARE map_value_type_name TEXT;
	DECLARE map_key JSON;
	DECLARE map_value JSON;

	-- Oneof handling
	DECLARE oneofs JSON;
	DECLARE oneof_priority INT;
	DECLARE oneof_priority_prev INT;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Handle well-known types first
	IF full_type_name LIKE '.google.protobuf.%' THEN
		SET result = _pb_wire_json_decode_wkt_as_json(wire_json, full_type_name, as_number_json);
		IF result IS NOT NULL THEN
			LEAVE proc;
		END IF;
	END IF;

	-- Get message descriptor
	SET message_descriptor = _pb_get_message_descriptor(descriptor_set_json, full_type_name);

	IF message_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_wire_json_to_json: message type `', full_type_name, '` not found in descriptor set');
		SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get file descriptor to determine syntax
	SET file_descriptor = _pb_get_file_descriptor(descriptor_set_json, full_type_name);
	SET syntax = JSON_UNQUOTE(JSON_EXTRACT(file_descriptor, '$."12"')); -- syntax field
	IF syntax IS NULL THEN
		SET syntax = 'proto2'; -- default
	END IF;

	SET result = JSON_OBJECT();
	SET oneofs = JSON_OBJECT();

	-- Get fields array (field 2 in DescriptorProto)
	SET fields = JSON_EXTRACT(message_descriptor, '$."2"');

	IF fields IS NOT NULL THEN
		SET field_count = JSON_LENGTH(fields);
		SET field_index = 0;

		WHILE field_index < field_count DO
			SET field_descriptor = JSON_EXTRACT(fields, CONCAT('$[', field_index, ']'));

			-- Extract field properties from FieldDescriptorProto
			SET field_number = JSON_EXTRACT(field_descriptor, '$."3"'); -- number
			SET field_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."1"')); -- name
			SET field_label = JSON_EXTRACT(field_descriptor, '$."4"'); -- label
			SET field_type = JSON_EXTRACT(field_descriptor, '$."5"'); -- type
			SET field_type_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."6"')); -- type_name
			SET json_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."10"')); -- json_name
			SET proto3_optional = COALESCE(CAST(JSON_EXTRACT(field_descriptor, '$."17"') AS UNSIGNED), FALSE); -- proto3_optional
			SET oneof_index = JSON_EXTRACT(field_descriptor, '$."9"'); -- oneof_index
			SET default_value = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."7"')); -- default_value

			SET is_repeated = (field_label = 3); -- LABEL_REPEATED

			-- Check if this is a map field
			SET is_map = FALSE;
			IF field_type = 11 AND field_type_name IS NOT NULL THEN -- TYPE_MESSAGE
				SET map_entry_descriptor = _pb_get_message_descriptor(descriptor_set_json, field_type_name);
				SET is_map = COALESCE(CAST(JSON_EXTRACT(map_entry_descriptor, '$."7"."7"') AS UNSIGNED), FALSE); -- map_entry
			END IF;

			-- Determine field presence
			SET has_field_presence =
				(syntax = 'proto2' AND field_label <> 3) -- proto2: all non-repeated fields
				OR (syntax = 'proto3'
					AND (
						(field_label = 1 AND proto3_optional) -- proto3 optional
						OR (field_label <> 3 AND field_type = 11) -- message fields
						OR (oneof_index IS NOT NULL) -- oneof fields
					));

			CASE field_type
			WHEN 10 THEN -- TYPE_GROUP (unsupported)
				SET message_text = CONCAT('_pb_wire_json_to_json: unsupported field_type `', field_type, '` for field `', field_name, '` (', field_number, ').');
				SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;

			WHEN 11 THEN -- TYPE_MESSAGE
				IF is_map THEN
					-- Handle map fields
					SET elements = pb_wire_json_get_repeated_message_field_as_json_array(wire_json, field_number);
					SET element_count = JSON_LENGTH(elements);
					SET element_index = 0;
					SET field_json_value = JSON_OBJECT();

					-- Get map key/value field descriptors
					SET map_key_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[0]'); -- first field (key)
					SET map_value_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[1]'); -- second field (value)
					SET map_key_type = JSON_EXTRACT(map_key_field, '$."5"');
					SET map_value_type = JSON_EXTRACT(map_value_field, '$."5"');
					SET map_value_type_name = JSON_UNQUOTE(JSON_EXTRACT(map_value_field, '$."6"'));

					WHILE element_index < element_count DO
						SET element = pb_message_to_wire_json(FROM_BASE64(JSON_UNQUOTE(JSON_EXTRACT(elements, CONCAT('$[', element_index, ']')))));
						CALL _pb_wire_json_get_primitive_field_as_json(element, 1, map_key_type, FALSE, FALSE, as_number_json, map_key);

						IF map_value_type = 11 THEN -- message
							CALL _pb_message_to_json(descriptor_set_json, map_value_type_name, pb_wire_json_get_message_field(element, 2, NULL), as_number_json, map_value);
						ELSEIF map_value_type = 14 THEN -- enum
							IF as_number_json THEN
								SET map_value = CAST(pb_wire_json_get_enum_field(element, 2, NULL) AS JSON);
							ELSE
								CALL _pb_enum_to_json(descriptor_set_json, map_value_type_name, pb_wire_json_get_enum_field(element, 2, NULL), map_value);
							END IF;
						ELSE
							CALL _pb_wire_json_get_primitive_field_as_json(element, 2, map_value_type, FALSE, TRUE, as_number_json, map_value);
						END IF;

						IF JSON_TYPE(map_key) = 'STRING' THEN
							SET field_json_value = JSON_SET(field_json_value, CONCAT('$.', map_key), map_value);
						ELSE
							SET field_json_value = JSON_SET(field_json_value, CONCAT('$."', map_key, '"'), map_value);
						END IF;

						SET element_index = element_index + 1;
					END WHILE;

				ELSEIF is_repeated THEN
					-- Handle repeated message fields
					SET element_count = pb_wire_json_get_repeated_message_field_count(wire_json, field_number);
					SET element_index = 0;
					SET field_json_value = JSON_ARRAY();

					WHILE element_index < element_count DO
						SET bytes_value = pb_wire_json_get_repeated_message_field_element(wire_json, field_number, element_index);
						CALL _pb_message_to_json(descriptor_set_json, field_type_name, bytes_value, as_number_json, nested_json_value);
						SET field_json_value = JSON_ARRAY_APPEND(field_json_value, '$', nested_json_value);
						SET element_index = element_index + 1;
					END WHILE;
				ELSE
					-- Handle singular message fields
					SET bytes_value = pb_wire_json_get_message_field(wire_json, field_number, NULL);
					CALL _pb_message_to_json(descriptor_set_json, field_type_name, bytes_value, as_number_json, field_json_value);
				END IF;

			WHEN 14 THEN -- TYPE_ENUM
				IF is_repeated THEN
					SET elements = pb_wire_json_get_repeated_enum_field_as_json_array(wire_json, field_number);
					SET element_count = JSON_LENGTH(elements);
					SET element_index = 0;
					SET field_json_value = JSON_ARRAY();

					WHILE element_index < element_count DO
						SET element = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
						IF as_number_json THEN
							SET field_json_value = JSON_ARRAY_APPEND(field_json_value, '$', CAST(element AS JSON));
						ELSE
							CALL _pb_enum_to_json(descriptor_set_json, field_type_name, element, nested_json_value);
							SET field_json_value = JSON_ARRAY_APPEND(field_json_value, '$', nested_json_value);
						END IF;
						SET element_index = element_index + 1;
					END WHILE;
				ELSE
					IF as_number_json THEN
						SET field_json_value = CAST(pb_wire_json_get_enum_field(wire_json, field_number, IF(has_field_presence, NULL, 0)) AS JSON);
					ELSE
						CALL _pb_enum_to_json(descriptor_set_json, field_type_name, pb_wire_json_get_enum_field(wire_json, field_number, IF(has_field_presence, NULL, 0)), field_json_value);
					END IF;
				END IF;

			ELSE
				-- Handle primitive types using existing function
				CALL _pb_wire_json_get_primitive_field_as_json(wire_json, field_number, field_type, is_repeated, has_field_presence, as_number_json, field_json_value);
			END CASE;

			-- Add field to result if it has a value
			IF field_json_value IS NOT NULL THEN
				IF as_number_json THEN
					SET json_field_name = CAST(field_number AS CHAR);
				ELSE
					SET json_field_name = IF(json_name IS NOT NULL, json_name, _pb_util_snake_to_lower_camel(field_name));
				END IF;

				IF oneof_index IS NOT NULL AND NOT proto3_optional THEN
					-- Handle oneof fields
					SET elements = JSON_EXTRACT(wire_json, CONCAT('$."', field_number, '"'));
					SET oneof_priority = JSON_EXTRACT(elements, CONCAT('$[', JSON_LENGTH(elements)-1, '].i'));
					SET oneof_priority_prev = JSON_EXTRACT(oneofs, CONCAT('$."', oneof_index, '".i'));

					IF oneof_priority_prev IS NULL OR oneof_priority_prev < oneof_priority THEN
						SET oneofs = JSON_SET(oneofs, CONCAT('$."', oneof_index, '"'), JSON_OBJECT('i', oneof_priority, 'v', JSON_OBJECT(json_field_name, field_json_value)));
					END IF;
				ELSE
					-- Regular field
					IF as_number_json THEN
						-- For number JSON format, field names are numeric and need to be quoted in JSON paths
						SET result = JSON_SET(result, CONCAT('$."', json_field_name, '"'), field_json_value);
					ELSE
						SET result = JSON_SET(result, CONCAT('$.', json_field_name), field_json_value);
					END IF;
				END IF;
			END IF;

			SET field_index = field_index + 1;
		END WHILE;
	END IF;

	-- Add oneof fields to result
	SET elements = JSON_EXTRACT(oneofs, '$.*.v');
	SET element_count = JSON_LENGTH(elements);
	SET element_index = 0;

	WHILE element_index < element_count DO
		SET field_json_value = JSON_EXTRACT(elements, CONCAT('$[', element_index, ']'));
		SET result = JSON_MERGE(result, field_json_value);
		SET element_index = element_index + 1;
	END WHILE;
END $$

-- Wrapper procedure that converts LONGBLOB to wire_json and delegates
DROP PROCEDURE IF EXISTS _pb_message_to_json $$
CREATE PROCEDURE _pb_message_to_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN message LONGBLOB, IN as_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE message_text TEXT;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_message_to_json: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF message IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_wire_json_to_json_proc(descriptor_set_json, full_type_name, pb_message_to_wire_json(message), as_number_json, result);
	END IF;
END $$

DROP PROCEDURE IF EXISTS _pb_wire_json_to_json $$
CREATE PROCEDURE _pb_wire_json_to_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN wire_json JSON, IN as_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE message_text TEXT;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_wire_json_to_json: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF wire_json IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_wire_json_to_json_proc(descriptor_set_json, full_type_name, wire_json, as_number_json, result);
	END IF;
END $$

-- Public function interface
DROP FUNCTION IF EXISTS pb_message_to_json $$
CREATE FUNCTION pb_message_to_json(descriptor_set_json JSON, type_name TEXT, message LONGBLOB) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_message_to_json(descriptor_set_json, type_name, message, FALSE, result);
	RETURN result;
END $$

-- Private function interface for protonumberjson format
DROP FUNCTION IF EXISTS _pb_message_to_number_json $$
CREATE FUNCTION _pb_message_to_number_json(descriptor_set_json JSON, type_name TEXT, message LONGBLOB) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_message_to_json(descriptor_set_json, type_name, message, TRUE, result);
	RETURN result;
END $$

-- Public function interface for wire_json input
DROP FUNCTION IF EXISTS pb_wire_json_to_json $$
CREATE FUNCTION pb_wire_json_to_json(descriptor_set_json JSON, type_name TEXT, wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wire_json_to_json(descriptor_set_json, type_name, wire_json, FALSE, result);
	RETURN result;
END $$

-- Private function interface for wire_json input with number JSON format
DROP FUNCTION IF EXISTS _pb_wire_json_to_number_json $$
CREATE FUNCTION _pb_wire_json_to_number_json(descriptor_set_json JSON, type_name TEXT, wire_json JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_wire_json_to_json(descriptor_set_json, type_name, wire_json, TRUE, result);
	RETURN result;
END $$

DELIMITER $$

-- Helper procedure to convert JSON object to Struct wire_json (allows recursion)
DROP PROCEDURE IF EXISTS _pb_json_encode_wkt_struct_as_wire_json $$
CREATE PROCEDURE _pb_json_encode_wkt_struct_as_wire_json(IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE struct_keys JSON;
	DECLARE struct_key_count INT;
	DECLARE struct_key_index INT;
	DECLARE struct_key_name TEXT;
	DECLARE struct_value_json JSON;
	DECLARE struct_value_wire_json JSON;
	DECLARE struct_entry_wire_json JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;
	SET result = JSON_OBJECT();

	IF JSON_TYPE(json_value) = 'OBJECT' THEN
		SET struct_keys = JSON_KEYS(json_value);
		SET struct_key_count = JSON_LENGTH(struct_keys);
		SET struct_key_index = 0;

		WHILE struct_key_index < struct_key_count DO
			SET struct_key_name = JSON_UNQUOTE(JSON_EXTRACT(struct_keys, CONCAT('$[', struct_key_index, ']')));
			SET struct_value_json = JSON_EXTRACT(json_value, CONCAT('$."', struct_key_name, '"'));

			-- Create map entry with key=1, value=2
			SET struct_entry_wire_json = JSON_OBJECT();
			SET struct_entry_wire_json = pb_wire_json_set_string_field(struct_entry_wire_json, 1, struct_key_name);

			-- Convert value to Value type (recursive call)
			CALL _pb_json_encode_wkt_value_as_wire_json(struct_value_json, from_number_json, struct_value_wire_json);
			IF struct_value_wire_json IS NOT NULL THEN
				SET struct_entry_wire_json = pb_wire_json_set_message_field(struct_entry_wire_json, 2, pb_wire_json_to_message(struct_value_wire_json));
				SET result = pb_wire_json_add_repeated_message_field_element(result, 1, pb_wire_json_to_message(struct_entry_wire_json));
			END IF;

			SET struct_key_index = struct_key_index + 1;
		END WHILE;
	END IF;
END $$

-- Helper procedure to convert JSON array to ListValue wire_json (allows recursion)
DROP PROCEDURE IF EXISTS _pb_json_encode_wkt_listvalue_as_wire_json $$
CREATE PROCEDURE _pb_json_encode_wkt_listvalue_as_wire_json(IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE list_element_count INT;
	DECLARE list_element_index INT;
	DECLARE list_element JSON;
	DECLARE list_value_wire_json JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;
	SET result = JSON_OBJECT();

	IF JSON_TYPE(json_value) = 'ARRAY' THEN
		SET list_element_count = JSON_LENGTH(json_value);
		SET list_element_index = 0;

		WHILE list_element_index < list_element_count DO
			SET list_element = JSON_EXTRACT(json_value, CONCAT('$[', list_element_index, ']'));

			-- Convert element to Value type (recursive call)
			CALL _pb_json_encode_wkt_value_as_wire_json(list_element, from_number_json, list_value_wire_json);
			IF list_value_wire_json IS NOT NULL THEN
				SET result = pb_wire_json_add_repeated_message_field_element(result, 1, pb_wire_json_to_message(list_value_wire_json));
			END IF;

			SET list_element_index = list_element_index + 1;
		END WHILE;
	END IF;
END $$

-- Helper function to convert Timestamp string to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_timestamp_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_timestamp_as_wire_json(timestamp_str TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE seconds BIGINT;
	DECLARE nanos INT;
	DECLARE dot_pos INT;
	DECLARE nanos_str TEXT;

	SET result = JSON_OBJECT();
	-- Extract seconds part - treat input as UTC
	-- Parse datetime and convert from UTC to session timezone for UNIX_TIMESTAMP
	SET seconds = UNIX_TIMESTAMP(CONVERT_TZ(STR_TO_DATE(LEFT(timestamp_str, 19), '%Y-%m-%dT%H:%i:%s'), '+00:00', @@session.time_zone));

	-- Extract nanoseconds if present
	SET nanos = 0;
	SET dot_pos = LOCATE('.', timestamp_str);
	IF dot_pos > 0 THEN
		SET nanos_str = SUBSTRING(timestamp_str, dot_pos + 1);
		SET nanos_str = LEFT(nanos_str, LOCATE('Z', nanos_str) - 1);
		-- Pad or truncate to 9 digits for nanoseconds
		WHILE LENGTH(nanos_str) < 9 DO
			SET nanos_str = CONCAT(nanos_str, '0');
		END WHILE;
		SET nanos_str = LEFT(nanos_str, 9);
		SET nanos = CAST(nanos_str AS UNSIGNED);
	END IF;

	-- For proto3 semantics, omit default values (seconds=0 and nanos=0)
	IF seconds = 0 AND nanos = 0 THEN
		RETURN result; -- Return empty wire_json
	END IF;

	-- Add non-default values
	IF seconds <> 0 THEN
		SET result = pb_wire_json_set_int64_field(result, 1, seconds);
	END IF;

	IF nanos <> 0 THEN
		SET result = pb_wire_json_set_int32_field(result, 2, nanos);
	END IF;

	RETURN result;
END $$

-- Helper function to convert Duration string to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_duration_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_duration_as_wire_json(duration_str TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE seconds BIGINT;
	DECLARE nanos INT;
	DECLARE dot_pos INT;
	DECLARE s_pos INT;
	DECLARE nanos_str TEXT;

	SET result = JSON_OBJECT();

	-- Find 's' suffix
	SET s_pos = LOCATE('s', duration_str);
	IF s_pos > 0 THEN
		SET duration_str = LEFT(duration_str, s_pos - 1);
		SET dot_pos = LOCATE('.', duration_str);

		IF dot_pos > 0 THEN
			-- Has fractional seconds
			SET seconds = CAST(LEFT(duration_str, dot_pos - 1) AS SIGNED);
			SET nanos_str = SUBSTRING(duration_str, dot_pos + 1);
			-- Pad to 9 digits for nanoseconds
			WHILE LENGTH(nanos_str) < 9 DO
				SET nanos_str = CONCAT(nanos_str, '0');
			END WHILE;
			SET nanos_str = LEFT(nanos_str, 9);
			SET nanos = CAST(nanos_str AS UNSIGNED);
		ELSE
			-- Whole seconds only
			SET seconds = CAST(duration_str AS SIGNED);
			SET nanos = 0;
		END IF;

		-- For proto3 semantics, omit default values (seconds=0 and nanos=0)
		IF seconds = 0 AND nanos = 0 THEN
			RETURN result; -- Return empty wire_json
		END IF;

		-- Add non-default values
		IF seconds <> 0 THEN
			SET result = pb_wire_json_set_int64_field(result, 1, seconds);
		END IF;

		IF nanos <> 0 THEN
			SET result = pb_wire_json_set_int32_field(result, 2, nanos);
		END IF;
	END IF;

	RETURN result;
END $$

-- Helper function to convert FieldMask string to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_fieldmask_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_fieldmask_as_wire_json(field_mask_str TEXT) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE comma_pos INT;
	DECLARE path TEXT;
	DECLARE remaining TEXT;

	SET result = JSON_OBJECT();
	SET remaining = field_mask_str;

	WHILE remaining IS NOT NULL AND LENGTH(remaining) > 0 DO
		SET comma_pos = LOCATE(',', remaining);
		IF comma_pos > 0 THEN
			SET path = TRIM(LEFT(remaining, comma_pos - 1));
			SET remaining = SUBSTRING(remaining, comma_pos + 1);
		ELSE
			SET path = TRIM(remaining);
			SET remaining = NULL;
		END IF;

		IF LENGTH(path) > 0 THEN
			-- Use add_repeated_string_field_element for repeated field
			SET result = pb_wire_json_add_repeated_string_field_element(result, 1, path);
		END IF;
	END WHILE;

	RETURN result;
END $$

-- Helper procedure to convert JSON to google.protobuf.Value wire_json (allows recursion)
DROP PROCEDURE IF EXISTS _pb_json_encode_wkt_value_as_wire_json $$
CREATE PROCEDURE _pb_json_encode_wkt_value_as_wire_json(IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE struct_wire_json JSON;
	DECLARE list_wire_json JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;
	SET result = JSON_OBJECT();

	CASE JSON_TYPE(json_value)
	WHEN 'NULL' THEN
		-- null_value = 0 (field 1, enum)
		SET result = pb_wire_json_set_enum_field(result, 1, 0);
	WHEN 'BOOLEAN' THEN
		-- bool_value (field 4)
		SET result = pb_wire_json_set_bool_field(result, 4, IF(json_value, TRUE, FALSE));
	WHEN 'INTEGER' THEN
		-- number_value (field 2)
		SET result = pb_wire_json_set_double_field(result, 2, CAST(json_value AS DOUBLE));
	WHEN 'DECIMAL' THEN
		-- number_value (field 2)
		SET result = pb_wire_json_set_double_field(result, 2, CAST(json_value AS DOUBLE));
	WHEN 'STRING' THEN
		-- string_value (field 3)
		SET result = pb_wire_json_set_string_field(result, 3, JSON_UNQUOTE(json_value));
	WHEN 'OBJECT' THEN
		-- struct_value (field 5) - convert to Struct
		CALL _pb_json_encode_wkt_struct_as_wire_json(json_value, from_number_json, struct_wire_json);
		IF struct_wire_json IS NOT NULL THEN
			SET result = pb_wire_json_set_message_field(result, 5, pb_wire_json_to_message(struct_wire_json));
		END IF;
	WHEN 'ARRAY' THEN
		-- list_value (field 6) - convert to ListValue
		CALL _pb_json_encode_wkt_listvalue_as_wire_json(json_value, from_number_json, list_wire_json);
		IF list_wire_json IS NOT NULL THEN
			SET result = pb_wire_json_set_message_field(result, 6, pb_wire_json_to_message(list_wire_json));
		END IF;
	END CASE;
END $$

-- Helper function to convert JSON value to BIGINT SIGNED, handling both numbers and strings
DROP FUNCTION IF EXISTS _pb_json_to_signed_int $$
CREATE FUNCTION _pb_json_to_signed_int(json_value JSON) RETURNS BIGINT DETERMINISTIC
BEGIN
	IF JSON_TYPE(json_value) = 'STRING' THEN
		RETURN CAST(JSON_UNQUOTE(json_value) AS SIGNED);
	ELSE
		RETURN CAST(json_value AS SIGNED);
	END IF;
END $$

-- Helper function to convert JSON value to BIGINT UNSIGNED, handling both numbers and strings
DROP FUNCTION IF EXISTS _pb_json_to_unsigned_int $$
CREATE FUNCTION _pb_json_to_unsigned_int(json_value JSON) RETURNS BIGINT UNSIGNED DETERMINISTIC
BEGIN
	IF JSON_TYPE(json_value) = 'STRING' THEN
		RETURN CAST(JSON_UNQUOTE(json_value) AS UNSIGNED);
	ELSE
		RETURN CAST(json_value AS UNSIGNED);
	END IF;
END $$

-- Helper function to encode well-known types from JSON to wire_json
DROP FUNCTION IF EXISTS _pb_json_encode_wkt_as_wire_json $$
CREATE FUNCTION _pb_json_encode_wkt_as_wire_json(json_value JSON, full_type_name TEXT, from_number_json BOOLEAN) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	DECLARE float_value FLOAT;
	DECLARE double_value DOUBLE;

	CASE full_type_name
	WHEN '.google.protobuf.Timestamp' THEN
		-- Parse RFC 3339 timestamp string like "1996-12-19T16:39:57.000340012Z"
		IF JSON_TYPE(json_value) = 'STRING' THEN
			RETURN _pb_json_encode_wkt_timestamp_as_wire_json(JSON_UNQUOTE(json_value));
		END IF;

	WHEN '.google.protobuf.Duration' THEN
		-- Parse duration string like "1.000340012s" or "3600s"
		IF JSON_TYPE(json_value) = 'STRING' THEN
			RETURN _pb_json_encode_wkt_duration_as_wire_json(JSON_UNQUOTE(json_value));
		END IF;

	WHEN '.google.protobuf.FieldMask' THEN
		-- Parse comma-separated field names like "path1,path2"
		IF JSON_TYPE(json_value) = 'STRING' THEN
			RETURN _pb_json_encode_wkt_fieldmask_as_wire_json(JSON_UNQUOTE(json_value));
		END IF;

	WHEN '.google.protobuf.Empty' THEN
		-- Always return empty wire_json
		RETURN JSON_OBJECT();

	WHEN '.google.protobuf.Struct' THEN
		-- Convert JSON object to Struct with repeated fields map
		CALL _pb_json_encode_wkt_struct_as_wire_json(json_value, from_number_json, result);
		IF result IS NOT NULL THEN
			RETURN result;
		END IF;

	WHEN '.google.protobuf.Value' THEN
		-- Handle different JSON value types
		CALL _pb_json_encode_wkt_value_as_wire_json(json_value, from_number_json, result);
		IF result IS NOT NULL THEN
			RETURN result;
		END IF;

	WHEN '.google.protobuf.ListValue' THEN
		-- Convert JSON array to ListValue with repeated Value fields
		CALL _pb_json_encode_wkt_listvalue_as_wire_json(json_value, from_number_json, result);
		IF result IS NOT NULL THEN
			RETURN result;
		END IF;

	-- Wrapper types
	WHEN '.google.protobuf.Int32Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_signed_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_int32_field(result, 1, _pb_json_to_signed_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.UInt32Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_unsigned_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_uint32_field(result, 1, _pb_json_to_unsigned_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.Int64Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_signed_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_int64_field(result, 1, _pb_json_to_signed_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.UInt64Value' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'STRING') THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF _pb_json_to_unsigned_int(json_value) <> 0 THEN
				SET result = pb_wire_json_set_uint64_field(result, 1, _pb_json_to_unsigned_int(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.FloatValue' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'DOUBLE', 'STRING') THEN
			SET result = JSON_OBJECT();
			IF JSON_TYPE(json_value) = 'STRING' THEN
				SET float_value = CAST(JSON_UNQUOTE(json_value) AS FLOAT);
			ELSE
				SET float_value = CAST(json_value AS FLOAT);
			END IF;
			-- Only encode non-default values (proto3 behavior)
			IF float_value <> 0.0 THEN
				SET result = pb_wire_json_set_float_field(result, 1, float_value);
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.DoubleValue' THEN
		IF JSON_TYPE(json_value) IN ('INTEGER', 'DECIMAL', 'DOUBLE', 'STRING') THEN
			SET result = JSON_OBJECT();
			IF JSON_TYPE(json_value) = 'STRING' THEN
				SET double_value = CAST(JSON_UNQUOTE(json_value) AS DOUBLE);
			ELSE
				SET double_value = CAST(json_value AS DOUBLE);
			END IF;
			-- Only encode non-default values (proto3 behavior)
			IF double_value <> 0.0 THEN
				SET result = pb_wire_json_set_double_field(result, 1, double_value);
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.BoolValue' THEN
		IF JSON_TYPE(json_value) = 'BOOLEAN' THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF json_value THEN
				SET result = pb_wire_json_set_bool_field(result, 1, TRUE);
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.StringValue' THEN
		IF JSON_TYPE(json_value) = 'STRING' THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF JSON_UNQUOTE(json_value) <> '' THEN
				SET result = pb_wire_json_set_string_field(result, 1, JSON_UNQUOTE(json_value));
			END IF;
			RETURN result;
		END IF;

	WHEN '.google.protobuf.BytesValue' THEN
		IF JSON_TYPE(json_value) = 'STRING' THEN
			SET result = JSON_OBJECT();
			-- Only encode non-default values (proto3 behavior)
			IF JSON_UNQUOTE(json_value) <> '' THEN
				SET result = pb_wire_json_set_bytes_field(result, 1, FROM_BASE64(JSON_UNQUOTE(json_value)));
			END IF;
			RETURN result;
		END IF;
	END CASE;

	-- Return NULL to fall back to normal message handling
	RETURN NULL;
END $$

-- Helper procedure to convert JSON enum value to number using descriptor set
DROP PROCEDURE IF EXISTS _pb_enum_from_json $$
CREATE PROCEDURE _pb_enum_from_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN enum_value_json JSON, OUT result INT)
proc: BEGIN
	DECLARE enum_descriptor JSON;
	DECLARE enum_values JSON;
	DECLARE enum_value JSON;
	DECLARE enum_count INT;
	DECLARE enum_index INT;
	DECLARE current_number INT;
	DECLARE current_name TEXT;
	DECLARE input_value TEXT;

	SET enum_descriptor = _pb_get_enum_descriptor(descriptor_set_json, full_type_name);

	IF enum_descriptor IS NULL THEN
		SET result = NULL;
		LEAVE proc;
	END IF;

	-- Get enum values array (field 2 in EnumDescriptorProto)
	SET enum_values = JSON_EXTRACT(enum_descriptor, '$."2"');

	IF enum_values IS NULL THEN
		SET result = NULL;
		LEAVE proc;
	END IF;

	-- Handle both string and number inputs
	IF JSON_TYPE(enum_value_json) = 'STRING' THEN
		SET input_value = JSON_UNQUOTE(enum_value_json);

		-- Find enum value by name
		SET enum_count = JSON_LENGTH(enum_values);
		SET enum_index = 0;

		WHILE enum_index < enum_count DO
			SET enum_value = JSON_EXTRACT(enum_values, CONCAT('$[', enum_index, ']'));
			SET current_name = JSON_UNQUOTE(JSON_EXTRACT(enum_value, '$."1"')); -- name field

			IF current_name = input_value THEN
				SET current_number = JSON_EXTRACT(enum_value, '$."2"'); -- number field
				SET result = current_number;
				LEAVE proc;
			END IF;

			SET enum_index = enum_index + 1;
		END WHILE;

		-- If not found by name, return null
		SET result = NULL;
	ELSEIF JSON_TYPE(enum_value_json) = 'INTEGER' THEN
		-- Input is a number, use directly
		SET result = CAST(enum_value_json AS SIGNED);
	ELSE
		SET result = NULL;
	END IF;
END $$

-- Helper function to check if a value is a proto3 default value
DROP FUNCTION IF EXISTS _pb_is_proto3_default_value $$
CREATE FUNCTION _pb_is_proto3_default_value(field_type INT, json_value JSON) RETURNS BOOLEAN DETERMINISTIC
BEGIN
	DECLARE message_text TEXT;
	CASE field_type
	WHEN 1 THEN -- TYPE_DOUBLE
		RETURN CAST(json_value AS DOUBLE) = 0.0;
	WHEN 2 THEN -- TYPE_FLOAT
		RETURN CAST(json_value AS FLOAT) = 0.0;
	WHEN 3 THEN -- TYPE_INT64
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 4 THEN -- TYPE_UINT64
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 5 THEN -- TYPE_INT32
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 6 THEN -- TYPE_FIXED64
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 7 THEN -- TYPE_FIXED32
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 8 THEN -- TYPE_BOOL
		RETURN json_value = CAST(false AS JSON);
	WHEN 9 THEN -- TYPE_STRING
		RETURN JSON_UNQUOTE(json_value) = '';
	WHEN 12 THEN -- TYPE_BYTES
		RETURN JSON_UNQUOTE(json_value) = '';
	WHEN 13 THEN -- TYPE_UINT32
		RETURN _pb_json_to_unsigned_int(json_value) = 0;
	WHEN 15 THEN -- TYPE_SFIXED32
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 16 THEN -- TYPE_SFIXED64
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 17 THEN -- TYPE_SINT32
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 18 THEN -- TYPE_SINT64
		RETURN _pb_json_to_signed_int(json_value) = 0;
	WHEN 14 THEN -- TYPE_ENUM
		-- Expects numeric enum value (conversion should be done elsewhere)
		RETURN CAST(json_value AS SIGNED) = 0;
	ELSE
		-- For unknown types, raise error
		SET message_text = CONCAT('_pb_is_proto3_default_value: unsupported field_type ', field_type);
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END CASE;
END $$

-- Helper procedure to set primitive field values in wire_json format
DROP PROCEDURE IF EXISTS _pb_json_set_primitive_field_as_wire_json $$
CREATE PROCEDURE _pb_json_set_primitive_field_as_wire_json(IN wire_json JSON, IN field_number INT, IN field_type INT, IN is_repeated BOOLEAN, IN json_value JSON, IN use_packed BOOLEAN, IN syntax TEXT, IN has_field_presence BOOLEAN, OUT result JSON)
proc: BEGIN
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE element JSON;
	DECLARE temp_wire_json JSON;

	SET result = wire_json;

	-- Skip encoding proto3 default values for fields without explicit presence
	IF NOT is_repeated AND syntax = 'proto3' AND NOT has_field_presence AND _pb_is_proto3_default_value(field_type, json_value) THEN
		-- Do not encode default values in proto3 for fields without explicit presence
		LEAVE proc;
	END IF;

	IF is_repeated THEN
		-- Handle repeated primitive fields
		SET element_count = JSON_LENGTH(json_value);
		SET element_index = 0;

		WHILE element_index < element_count DO
			SET element = JSON_EXTRACT(json_value, CONCAT('$[', element_index, ']'));

			CASE field_type
			WHEN 1 THEN -- TYPE_DOUBLE
				SET result = pb_wire_json_add_repeated_double_field_element(result, field_number, CAST(element AS DOUBLE), use_packed);
			WHEN 2 THEN -- TYPE_FLOAT
				SET result = pb_wire_json_add_repeated_float_field_element(result, field_number, CAST(element AS FLOAT), use_packed);
			WHEN 3 THEN -- TYPE_INT64
				SET result = pb_wire_json_add_repeated_int64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 4 THEN -- TYPE_UINT64
				SET result = pb_wire_json_add_repeated_uint64_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 5 THEN -- TYPE_INT32
				SET result = pb_wire_json_add_repeated_int32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 6 THEN -- TYPE_FIXED64
				SET result = pb_wire_json_add_repeated_fixed64_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 7 THEN -- TYPE_FIXED32
				SET result = pb_wire_json_add_repeated_fixed32_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 8 THEN -- TYPE_BOOL
				SET result = pb_wire_json_add_repeated_bool_field_element(result, field_number, IF(element, TRUE, FALSE), use_packed);
			WHEN 9 THEN -- TYPE_STRING
				SET result = pb_wire_json_add_repeated_string_field_element(result, field_number, JSON_UNQUOTE(element));
			WHEN 10 THEN -- TYPE_SFIXED64
				SET result = pb_wire_json_add_repeated_sfixed64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 11 THEN -- TYPE_SFIXED32
				SET result = pb_wire_json_add_repeated_sfixed32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 12 THEN -- TYPE_BYTES
				SET result = pb_wire_json_add_repeated_bytes_field_element(result, field_number, FROM_BASE64(JSON_UNQUOTE(element)));
			WHEN 13 THEN -- TYPE_UINT32
				SET result = pb_wire_json_add_repeated_uint32_field_element(result, field_number, _pb_json_to_unsigned_int(element), use_packed);
			WHEN 15 THEN -- TYPE_SFIXED32 (duplicate, but keeping for completeness)
				SET result = pb_wire_json_add_repeated_sfixed32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 16 THEN -- TYPE_SFIXED64 (duplicate, but keeping for completeness)
				SET result = pb_wire_json_add_repeated_sfixed64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 17 THEN -- TYPE_SINT32
				SET result = pb_wire_json_add_repeated_sint32_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			WHEN 18 THEN -- TYPE_SINT64
				SET result = pb_wire_json_add_repeated_sint64_field_element(result, field_number, _pb_json_to_signed_int(element), use_packed);
			END CASE;

			SET element_index = element_index + 1;
		END WHILE;
	ELSE
		-- Handle singular primitive fields
		CASE field_type
		WHEN 1 THEN -- TYPE_DOUBLE
			SET result = pb_wire_json_set_double_field(result, field_number, CAST(json_value AS DOUBLE));
		WHEN 2 THEN -- TYPE_FLOAT
			SET result = pb_wire_json_set_float_field(result, field_number, CAST(json_value AS FLOAT));
		WHEN 3 THEN -- TYPE_INT64
			SET result = pb_wire_json_set_int64_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 4 THEN -- TYPE_UINT64
			SET result = pb_wire_json_set_uint64_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 5 THEN -- TYPE_INT32
			SET result = pb_wire_json_set_int32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 6 THEN -- TYPE_FIXED64
			SET result = pb_wire_json_set_fixed64_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 7 THEN -- TYPE_FIXED32
			SET result = pb_wire_json_set_fixed32_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 8 THEN -- TYPE_BOOL
			SET result = pb_wire_json_set_bool_field(result, field_number, IF(json_value, TRUE, FALSE));
		WHEN 9 THEN -- TYPE_STRING
			SET result = pb_wire_json_set_string_field(result, field_number, JSON_UNQUOTE(json_value));
		WHEN 10 THEN -- TYPE_SFIXED64
			SET result = pb_wire_json_set_sfixed64_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 11 THEN -- TYPE_SFIXED32
			SET result = pb_wire_json_set_sfixed32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 12 THEN -- TYPE_BYTES
			SET result = pb_wire_json_set_bytes_field(result, field_number, FROM_BASE64(JSON_UNQUOTE(json_value)));
		WHEN 13 THEN -- TYPE_UINT32
			SET result = pb_wire_json_set_uint32_field(result, field_number, _pb_json_to_unsigned_int(json_value));
		WHEN 15 THEN -- TYPE_SFIXED32 (duplicate, but keeping for completeness)
			SET result = pb_wire_json_set_sfixed32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 16 THEN -- TYPE_SFIXED64 (duplicate, but keeping for completeness)
			SET result = pb_wire_json_set_sfixed64_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 17 THEN -- TYPE_SINT32
			SET result = pb_wire_json_set_sint32_field(result, field_number, _pb_json_to_signed_int(json_value));
		WHEN 18 THEN -- TYPE_SINT64
			SET result = pb_wire_json_set_sint64_field(result, field_number, _pb_json_to_signed_int(json_value));
		END CASE;
	END IF;
END $$

-- Main procedure for converting JSON to protobuf wire_json using descriptor set
DROP PROCEDURE IF EXISTS _pb_json_to_wire_json_proc $$
CREATE PROCEDURE _pb_json_to_wire_json_proc(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
proc: BEGIN
	DECLARE CUSTOM_EXCEPTION CONDITION FOR SQLSTATE '45000';

	DECLARE message_text TEXT;
	DECLARE message_descriptor JSON;
	DECLARE file_descriptor JSON;
	DECLARE syntax TEXT;
	DECLARE fields JSON;
	DECLARE field_count INT;
	DECLARE field_index INT;
	DECLARE field_descriptor JSON;

	-- Field properties
	DECLARE field_number INT;
	DECLARE field_name TEXT;
	DECLARE field_label INT;
	DECLARE field_type INT;
	DECLARE field_type_name TEXT;
	DECLARE json_name TEXT;
	DECLARE proto3_optional BOOLEAN;
	DECLARE oneof_index INT;
	DECLARE default_value TEXT;

	-- Processing variables
	DECLARE is_repeated BOOLEAN;
	DECLARE has_field_presence BOOLEAN;
	DECLARE use_packed BOOLEAN;
	DECLARE field_json_value JSON;
	DECLARE json_field_name TEXT;
	DECLARE element JSON;
	DECLARE element_count INT;
	DECLARE element_index INT;
	DECLARE nested_wire_json JSON;
	DECLARE enum_number INT;

	-- Map handling
	DECLARE is_map BOOLEAN;
	DECLARE map_entry_descriptor JSON;
	DECLARE map_key_field JSON;
	DECLARE map_value_field JSON;
	DECLARE map_key_type INT;
	DECLARE map_value_type INT;
	DECLARE map_value_type_name TEXT;
	DECLARE map_keys JSON;
	DECLARE map_key_count INT;
	DECLARE map_key_index INT;
	DECLARE map_key_name TEXT;
	DECLARE map_entry_wire_json JSON;
	DECLARE map_value_json JSON;
	DECLARE map_value_wire_json JSON;

	SET @@SESSION.max_sp_recursion_depth = 255;

	-- Handle well-known types first
	IF full_type_name LIKE '.google.protobuf.%' THEN
		SET result = _pb_json_encode_wkt_as_wire_json(json_value, full_type_name, from_number_json);
		IF result IS NOT NULL THEN
			LEAVE proc;
		END IF;
	END IF;

	IF JSON_TYPE(json_value) = 'NULL' THEN
		-- Null value should not produce any field in protobuf
		SET result = NULL;
		LEAVE proc;
	END IF;

	-- Get message descriptor
	SET message_descriptor = _pb_get_message_descriptor(descriptor_set_json, full_type_name);

	IF message_descriptor IS NULL THEN
		SET message_text = CONCAT('_pb_json_to_wire_json: message type `', full_type_name, '` not found in descriptor set');
		SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;
	END IF;

	-- Get file descriptor to determine syntax
	SET file_descriptor = _pb_get_file_descriptor(descriptor_set_json, full_type_name);
	SET syntax = JSON_UNQUOTE(JSON_EXTRACT(file_descriptor, '$."12"')); -- syntax field
	IF syntax IS NULL THEN
		SET syntax = 'proto2'; -- default
	END IF;

	SET result = JSON_OBJECT();

	-- Get fields array (field 2 in DescriptorProto)
	SET fields = JSON_EXTRACT(message_descriptor, '$."2"');

	IF fields IS NOT NULL THEN
		SET field_count = JSON_LENGTH(fields);
		SET field_index = 0;

		WHILE field_index < field_count DO
			SET field_descriptor = JSON_EXTRACT(fields, CONCAT('$[', field_index, ']'));

			-- Extract field properties from FieldDescriptorProto
			SET field_number = JSON_EXTRACT(field_descriptor, '$."3"'); -- number
			SET field_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."1"')); -- name
			SET field_label = JSON_EXTRACT(field_descriptor, '$."4"'); -- label
			SET field_type = JSON_EXTRACT(field_descriptor, '$."5"'); -- type
			SET field_type_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."6"')); -- type_name
			SET json_name = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."10"')); -- json_name
			SET proto3_optional = COALESCE(CAST(JSON_EXTRACT(field_descriptor, '$."17"') AS UNSIGNED), FALSE); -- proto3_optional
			SET oneof_index = JSON_EXTRACT(field_descriptor, '$."9"'); -- oneof_index
			SET default_value = JSON_UNQUOTE(JSON_EXTRACT(field_descriptor, '$."7"')); -- default_value

			SET is_repeated = (field_label = 3); -- LABEL_REPEATED

			-- Check if this is a map field
			SET is_map = FALSE;
			IF field_type = 11 AND field_type_name IS NOT NULL THEN -- TYPE_MESSAGE
				SET map_entry_descriptor = _pb_get_message_descriptor(descriptor_set_json, field_type_name);
				SET is_map = COALESCE(CAST(JSON_EXTRACT(map_entry_descriptor, '$."7"."7"') AS UNSIGNED), FALSE); -- map_entry
			END IF;

			-- Determine field presence
			SET has_field_presence =
				(syntax = 'proto2' AND field_label <> 3) -- proto2: all non-repeated fields
				OR (syntax = 'proto3'
					AND (
						(field_label = 1 AND proto3_optional) -- proto3 optional
						OR (field_label <> 3 AND field_type = 11) -- message fields
						OR (oneof_index IS NOT NULL) -- oneof fields
					));

			-- Determine packed encoding for repeated fields
			-- Check field options for explicit packed setting (field 8.2 in FieldDescriptorProto)
			SET use_packed = CAST(JSON_EXTRACT(field_descriptor, '$."8"."2"') AS UNSIGNED);

			-- Use syntax default if field option not set
			IF use_packed IS NULL THEN
				-- Proto3: packed by default, Proto2: unpacked by default
				SET use_packed = (syntax = 'proto3');
			END IF;

			-- Determine JSON field name to look for
			IF from_number_json THEN
				SET json_field_name = CAST(field_number AS CHAR);
			ELSE
				SET json_field_name = IF(json_name IS NOT NULL, json_name, _pb_util_snake_to_lower_camel(field_name));
			END IF;

			-- Extract field value from JSON
			SET field_json_value = JSON_EXTRACT(json_value, CONCAT('$."', json_field_name, '"'));

			-- Process field if it exists in JSON
			IF field_json_value IS NOT NULL THEN
				CASE field_type
				WHEN 10 THEN -- TYPE_GROUP (unsupported)
					SET message_text = CONCAT('_pb_json_to_wire_json: unsupported field_type `', field_type, '` for field `', field_name, '` (', field_number, ').');
					SIGNAL CUSTOM_EXCEPTION SET MESSAGE_TEXT = message_text;

				WHEN 11 THEN -- TYPE_MESSAGE
					IF is_map THEN
						-- Handle map fields - convert JSON object to repeated message entries
						SET map_keys = JSON_KEYS(field_json_value);
						SET map_key_count = JSON_LENGTH(map_keys);
						SET map_key_index = 0;

						-- Get map key/value field descriptors
						SET map_key_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[0]'); -- first field (key)
						SET map_value_field = JSON_EXTRACT(map_entry_descriptor, '$."2"[1]'); -- second field (value)
						SET map_key_type = JSON_EXTRACT(map_key_field, '$."5"');
						SET map_value_type = JSON_EXTRACT(map_value_field, '$."5"');
						SET map_value_type_name = JSON_UNQUOTE(JSON_EXTRACT(map_value_field, '$."6"'));

						WHILE map_key_index < map_key_count DO
							SET map_key_name = JSON_UNQUOTE(JSON_EXTRACT(map_keys, CONCAT('$[', map_key_index, ']')));
							SET map_value_json = JSON_EXTRACT(field_json_value, CONCAT('$."', map_key_name, '"'));

							-- Create map entry with key=1, value=2
							SET map_entry_wire_json = JSON_OBJECT();

							-- Add key field (always field 1)
							-- Convert map key to proper JSON type based on key type
							-- Map keys always have presence and should always be encoded
							CASE map_key_type
							WHEN 8 THEN -- bool
								CALL _pb_json_set_primitive_field_as_wire_json(map_entry_wire_json, 1, map_key_type, FALSE, CAST((map_key_name = 'true') AS JSON), FALSE, syntax, TRUE, map_entry_wire_json);
							ELSE
								CALL _pb_json_set_primitive_field_as_wire_json(map_entry_wire_json, 1, map_key_type, FALSE, JSON_QUOTE(map_key_name), FALSE, syntax, TRUE, map_entry_wire_json);
							END CASE;

							-- Add value field (always field 2)
							IF map_value_type = 11 THEN -- message
								CALL _pb_json_to_wire_json_proc(descriptor_set_json, map_value_type_name, map_value_json, from_number_json, map_value_wire_json);
								SET map_entry_wire_json = pb_wire_json_set_message_field(map_entry_wire_json, 2, pb_wire_json_to_message(map_value_wire_json));
							ELSEIF map_value_type = 14 THEN -- enum
								CALL _pb_enum_from_json(descriptor_set_json, map_value_type_name, map_value_json, enum_number);
								SET map_entry_wire_json = pb_wire_json_set_enum_field(map_entry_wire_json, 2, enum_number);
							ELSE
								-- Map values also always have presence in map entries
								CALL _pb_json_set_primitive_field_as_wire_json(map_entry_wire_json, 2, map_value_type, FALSE, map_value_json, FALSE, syntax, TRUE, map_entry_wire_json);
							END IF;

							-- Add map entry to result
							SET result = pb_wire_json_add_repeated_message_field_element(result, field_number, pb_wire_json_to_message(map_entry_wire_json));
							SET map_key_index = map_key_index + 1;
						END WHILE;

					ELSEIF is_repeated THEN
						-- Handle repeated message fields
						SET element_count = JSON_LENGTH(field_json_value);
						SET element_index = 0;

						WHILE element_index < element_count DO
							SET element = JSON_EXTRACT(field_json_value, CONCAT('$[', element_index, ']'));
							CALL _pb_json_to_wire_json_proc(descriptor_set_json, field_type_name, element, from_number_json, nested_wire_json);
							SET result = pb_wire_json_add_repeated_message_field_element(result, field_number, pb_wire_json_to_message(nested_wire_json));
							SET element_index = element_index + 1;
						END WHILE;
					ELSE
						-- Handle singular message fields
						CALL _pb_json_to_wire_json_proc(descriptor_set_json, field_type_name, field_json_value, from_number_json, nested_wire_json);
						IF nested_wire_json IS NOT NULL THEN
							SET result = pb_wire_json_set_message_field(result, field_number, pb_wire_json_to_message(nested_wire_json));
						END IF;
					END IF;

				WHEN 14 THEN -- TYPE_ENUM
					IF is_repeated THEN
						SET element_count = JSON_LENGTH(field_json_value);
						SET element_index = 0;

						WHILE element_index < element_count DO
							SET element = JSON_EXTRACT(field_json_value, CONCAT('$[', element_index, ']'));
							CALL _pb_enum_from_json(descriptor_set_json, field_type_name, element, enum_number);
							SET result = pb_wire_json_add_repeated_enum_field_element(result, field_number, enum_number, use_packed);
							SET element_index = element_index + 1;
						END WHILE;
					ELSE
						CALL _pb_enum_from_json(descriptor_set_json, field_type_name, field_json_value, enum_number);
						-- Skip encoding proto3 default values for fields without explicit presence
						IF NOT (syntax = 'proto3' AND NOT has_field_presence AND enum_number = 0) THEN
							SET result = pb_wire_json_set_enum_field(result, field_number, enum_number);
						END IF;
					END IF;

				ELSE
					-- Handle primitive types
					CALL _pb_json_set_primitive_field_as_wire_json(result, field_number, field_type, is_repeated, field_json_value, use_packed, syntax, has_field_presence, result);
				END CASE;
			END IF;

			SET field_index = field_index + 1;
		END WHILE;
	END IF;
END $$

-- Wrapper procedure for JSON to wire_json conversion
DROP PROCEDURE IF EXISTS _pb_json_to_wire_json $$
CREATE PROCEDURE _pb_json_to_wire_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, IN from_number_json BOOLEAN, OUT result JSON)
BEGIN
	DECLARE message_text TEXT;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_json_to_wire_json: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF json_value IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_json_to_wire_json_proc(descriptor_set_json, full_type_name, json_value, from_number_json, result);
	END IF;
END $$

-- Wrapper procedure for number JSON to wire_json conversion
DROP PROCEDURE IF EXISTS _pb_number_json_to_wire_json $$
CREATE PROCEDURE _pb_number_json_to_wire_json(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, OUT result JSON)
BEGIN
	CALL _pb_json_to_wire_json(descriptor_set_json, full_type_name, json_value, TRUE, result);
END $$

-- Wrapper procedure for JSON to message conversion
DROP PROCEDURE IF EXISTS _pb_json_to_message $$
CREATE PROCEDURE _pb_json_to_message(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, IN from_number_json BOOLEAN, OUT result LONGBLOB)
BEGIN
	DECLARE message_text TEXT;
	DECLARE wire_json JSON;

	-- Validate type name starts with dot
	IF full_type_name NOT LIKE '.%' THEN
		SET message_text = CONCAT('_pb_json_to_message: type name `', full_type_name, '` must start with a dot');
		SIGNAL SQLSTATE '45000' SET MESSAGE_TEXT = message_text;
	END IF;

	IF json_value IS NULL THEN
		SET result = NULL;
	ELSE
		CALL _pb_json_to_wire_json_proc(descriptor_set_json, full_type_name, json_value, from_number_json, wire_json);
		SET result = pb_wire_json_to_message(wire_json);
	END IF;
END $$

-- Wrapper procedure for number JSON to message conversion
DROP PROCEDURE IF EXISTS _pb_number_json_to_message $$
CREATE PROCEDURE _pb_number_json_to_message(IN descriptor_set_json JSON, IN full_type_name TEXT, IN json_value JSON, OUT result LONGBLOB)
BEGIN
	CALL _pb_json_to_message(descriptor_set_json, full_type_name, json_value, TRUE, result);
END $$

-- Public function interface for JSON to wire_json conversion
DROP FUNCTION IF EXISTS pb_json_to_wire_json $$
CREATE FUNCTION pb_json_to_wire_json(descriptor_set_json JSON, type_name TEXT, json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_json_to_wire_json(descriptor_set_json, type_name, json_value, FALSE, result);
	RETURN result;
END $$

-- Private function interface for number JSON to wire_json conversion
DROP FUNCTION IF EXISTS _pb_number_json_to_wire_json_func $$
CREATE FUNCTION _pb_number_json_to_wire_json_func(descriptor_set_json JSON, type_name TEXT, json_value JSON) RETURNS JSON DETERMINISTIC
BEGIN
	DECLARE result JSON;
	CALL _pb_number_json_to_wire_json(descriptor_set_json, type_name, json_value, result);
	RETURN result;
END $$

-- Public function interface for JSON to message conversion
DROP FUNCTION IF EXISTS pb_json_to_message $$
CREATE FUNCTION pb_json_to_message(descriptor_set_json JSON, type_name TEXT, json_value JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
	DECLARE result LONGBLOB;
	CALL _pb_json_to_message(descriptor_set_json, type_name, json_value, FALSE, result);
	RETURN result;
END $$

-- Private function interface for number JSON to message conversion
DROP FUNCTION IF EXISTS _pb_number_json_to_message_func $$
CREATE FUNCTION _pb_number_json_to_message_func(descriptor_set_json JSON, type_name TEXT, json_value JSON) RETURNS LONGBLOB DETERMINISTIC
BEGIN
	DECLARE result LONGBLOB;
	CALL _pb_number_json_to_message(descriptor_set_json, type_name, json_value, result);
	RETURN result;
END $$
