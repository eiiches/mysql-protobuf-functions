# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a MySQL Protocol Buffers (protobuf) functions library that provides comprehensive MySQL stored functions and procedures for working with protobuf encoded data directly within MySQL databases. The project enables parsing and querying protobuf messages without requiring external applications.

## Core Architecture

### SQL Functions Layer
- **protobuf.sql**: Core protobuf wire format parsing functions
- **protobuf-accessors.sql**: Generated accessor functions for different protobuf types (auto-generated by Go code)
- **protobuf-descriptor.sql**: Schema loading and descriptor management
- **protobuf-json.sql**: JSON conversion functionality

### Go Development Tools
- **cmd/protobuf-accessors/**: Code generator for MySQL accessor functions
- **cmd/mysql-profiler/**: Performance profiling tool that generates flamegraphs from MySQL performance schema
- **cmd/mysql-coverage/**: SQL code coverage analysis tool with LCOV report generation
- **cmd/mysql-ftrace/**: Function tracing tool for SQL execution analysis
- **internal/**: Supporting Go packages for protobuf reflection, MySQL utilities, and testing

### Key Components
- **Wire format parsing**: Low-level protobuf wire format decoding in pure MySQL
- **Type system**: Comprehensive support for all protobuf types (varint, fixed32/64, length-delimited)
- **JSON conversion**: Protobuf to JSON transformation with schema awareness
- **Performance profiling**: MySQL performance analysis and flamegraph generation
- **Coverage analysis**: SQL code coverage tracking with LCOV report generation
- **Function tracing**: Detailed SQL function execution tracing and analysis

## Development Commands

### Build System
```bash
# Build generated SQL files and tools
make build

# Reload all SQL functions into database
make reload

# Run tests (requires running MySQL)
make test

# Full rebuild and test cycle
make purge reload test
```

### MySQL Management
```bash
# Start local MySQL instance
make start-mysql

# Stop MySQL instance
make stop-mysql

# Open MySQL shell
make mysql-shell

# Run a specific MySQL command
make mysql-run COMMAND='SELECT _pb_util_reinterpret_double_as_uint64(3.14)'
```

### Testing
```bash
# Run Go tests against MySQL
go test ./tests -database "root@tcp(127.0.0.100:13306)/test"

# Run specific test
go test ./tests -run TestSomething -database "root@tcp(127.0.0.100:13306)/test"
```

### Performance Analysis
```bash
# Start profiling
make start-profiling

# Stop profiling and generate report
make stop-profiling

# Generate flamegraph from MySQL performance data
make flamegraph
```

### Coverage Analysis
```bash
# Run full coverage analysis with HTML report
make coverage

# Generate instrumented SQL files
make coverage-instrument

# Load instrumented functions into database
make coverage-load

# Run tests with coverage tracking
make coverage-run

# Generate LCOV coverage report
make coverage-report-lcov

# Generate HTML coverage report
make coverage-report-html
```

### Function Tracing
```bash
# Instrument SQL files for tracing
make ftrace-instrument

# Initialize tracing schema
make ftrace-init

# Load instrumented functions for tracing
make ftrace-load

# Generate trace report after running tests
make ftrace-report
```

#### Tracing Example

Complete workflow for tracing SQL function execution:

```bash
# 1. Load instrumented functions into database (ftrace-instrument and ftrace-init is run automatically)
make ftrace-load

# 2. Execute some SQL functions to generate trace data
make mysql-run COMMAND='SELECT _pb_util_reinterpret_double_as_uint64(3.14)'

# 3. Generate and view trace report
make ftrace-report
```

For a quick single-command trace:

```bash
make ftrace-load mysql-run ftrace-report COMMAND='SELECT _pb_util_reinterpret_double_as_uint64(3.14)'
```

The trace report will show detailed execution flow including:
- Function call hierarchy
- Execution times
- Parameter values
- Return values
- SQL statement execution paths

### Code Formatting
```bash
# Format Go code (run after modifying Go code)
make format

# Run Go linting (check code quality and style)
make lint
```

## Development Workflow

1. **SQL Development**: Core protobuf functionality is implemented in MySQL stored functions/procedures
2. **Go Tools**: Supporting tools for code generation, testing, profiling, coverage analysis, and tracing
3. **Code Formatting**: Always run `make format` after modifying Go code to ensure consistent formatting
4. **Test-Driven**: Tests run against live MySQL instance to verify SQL function behavior
5. **Performance Focus**: Built-in profiling and flamegraph generation for performance analysis
6. **Coverage Analysis**: Code coverage tracking for SQL functions with LCOV and HTML reports
7. **Function Tracing**: Detailed execution tracing for debugging and performance analysis

## Database Schema

The project creates:
- Stored functions and procedures prefixed with `pb_` (Public API) or `_pb_` (Private) for protobuf operations
- `__CoverageEvent` table for SQL code coverage tracking (when using coverage analysis)
- `__FtraceEvent` table for function tracing data (when using function tracing)

## Testing Requirements

- Tests require a running MySQL instance (started with `make start-mysql`)
- Database connection string must be provided via `-database` flag
- Tests use Gomega for assertions and custom MySQL matchers

## Development Best Practices

- Always run `make format` after editing SQL files
