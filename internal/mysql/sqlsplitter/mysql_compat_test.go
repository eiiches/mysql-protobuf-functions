package sqlsplitter

import (
	"testing"

	. "github.com/onsi/gomega"
)

func TestMySQLClientCompatibility(t *testing.T) {
	t.Run("DELIMITER after comment on new line", func(t *testing.T) {
		g := NewWithT(t)

		input := []byte(`-- Comment
DELIMITER //
SELECT 1//
DELIMITER ;`)

		parser := NewParser(input)
		statements, err := parser.Parse()

		g.Expect(err).ToNot(HaveOccurred())
		g.Expect(statements).To(HaveLen(4))

		g.Expect(statements[0].Text).To(Equal("-- Comment"))
		g.Expect(statements[0].Type).To(Equal("COMMENT"))

		g.Expect(statements[1].Text).To(Equal("DELIMITER //"))
		g.Expect(statements[1].Type).To(Equal("DELIMITER"))

		g.Expect(statements[2].Text).To(Equal("SELECT 1"))
		g.Expect(statements[2].Type).To(Equal("SQL"))

		g.Expect(statements[3].Text).To(Equal("DELIMITER ;"))
		g.Expect(statements[3].Type).To(Equal("DELIMITER"))
	})

	t.Run("DELIMITER in middle of line not recognized", func(t *testing.T) {
		g := NewWithT(t)

		input := []byte(`SELECT 1; DELIMITER //
SELECT 2;`)

		parser := NewParser(input)
		statements, err := parser.Parse()

		g.Expect(err).ToNot(HaveOccurred())
		g.Expect(statements).To(HaveLen(2))

		g.Expect(statements[0].Text).To(Equal("SELECT 1"))
		g.Expect(statements[0].Type).To(Equal("SQL"))

		// The remaining text " DELIMITER //\nSELECT 2;" becomes one statement
		g.Expect(statements[1].Text).To(Equal("DELIMITER //\nSELECT 2"))
		g.Expect(statements[1].Type).To(Equal("SQL"))
	})

	t.Run("DELIMITER inside string literal", func(t *testing.T) {
		g := NewWithT(t)

		input := []byte(`SELECT 'test
DELIMITER //
more';`)

		parser := NewParser(input)
		statements, err := parser.Parse()

		g.Expect(err).ToNot(HaveOccurred())
		g.Expect(statements).To(HaveLen(1))

		g.Expect(statements[0].Text).To(Equal("SELECT 'test\nDELIMITER //\nmore'"))
		g.Expect(statements[0].Type).To(Equal("SQL"))
	})

	t.Run("DELIMITER inside block comment", func(t *testing.T) {
		g := NewWithT(t)

		input := []byte(`/* comment
DELIMITER //
end */ SELECT 1;`)

		parser := NewParser(input)
		statements, err := parser.Parse()

		g.Expect(err).ToNot(HaveOccurred())
		g.Expect(statements).To(HaveLen(1))

		g.Expect(statements[0].Text).To(Equal("/* comment\nDELIMITER //\nend */ SELECT 1"))
		g.Expect(statements[0].Type).To(Equal("SQL"))
	})

	t.Run("Instrumented SQL file pattern", func(t *testing.T) {
		g := NewWithT(t)

		input := []byte(`-- INSTRUMENTED SQL FILE
-- Original: protobuf.sql
-- Generated by MySQL Coverage Instrumentor

-- Coverage tracking table
SELECT 1;

-- Coverage recording procedure
DELIMITER //
SELECT 2 //
DELIMITER ;

DELIMITER $$`)

		parser := NewParser(input)
		statements, err := parser.Parse()

		g.Expect(err).ToNot(HaveOccurred())
		g.Expect(statements).To(HaveLen(6))

		// First SQL statement with comments
		g.Expect(statements[0].Type).To(Equal("SQL"))
		g.Expect(statements[0].Text).To(ContainSubstring("INSTRUMENTED SQL FILE"))
		g.Expect(statements[0].Text).To(ContainSubstring("SELECT 1"))

		// Comment before DELIMITER
		g.Expect(statements[1].Type).To(Equal("COMMENT"))
		g.Expect(statements[1].Text).To(Equal("-- Coverage recording procedure"))

		// DELIMITER change
		g.Expect(statements[2].Type).To(Equal("DELIMITER"))
		g.Expect(statements[2].Text).To(Equal("DELIMITER //"))

		// SQL with new delimiter
		g.Expect(statements[3].Type).To(Equal("SQL"))
		g.Expect(statements[3].Text).To(Equal("SELECT 2"))

		// DELIMITER change back
		g.Expect(statements[4].Type).To(Equal("DELIMITER"))
		g.Expect(statements[4].Text).To(Equal("DELIMITER ;"))

		// Final DELIMITER
		g.Expect(statements[5].Type).To(Equal("DELIMITER"))
		g.Expect(statements[5].Text).To(Equal("DELIMITER $$"))
	})

	t.Run("DELIMITER with leading whitespace", func(t *testing.T) {
		g := NewWithT(t)

		input := []byte(`SELECT 1;
    DELIMITER //
SELECT 2//`)

		parser := NewParser(input)
		statements, err := parser.Parse()

		g.Expect(err).ToNot(HaveOccurred())
		g.Expect(statements).To(HaveLen(3))

		g.Expect(statements[0].Type).To(Equal("SQL"))
		g.Expect(statements[0].Text).To(Equal("SELECT 1"))

		g.Expect(statements[1].Type).To(Equal("DELIMITER"))
		g.Expect(statements[1].Text).To(Equal("DELIMITER //"))

		g.Expect(statements[2].Type).To(Equal("SQL"))
		g.Expect(statements[2].Text).To(Equal("SELECT 2"))
	})
}
