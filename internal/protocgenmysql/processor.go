package protocgenmysql

import (
	"fmt"
	"strings"

	"github.com/eiiches/mysql-protobuf-functions/internal/moremaps"
	"google.golang.org/protobuf/reflect/protodesc"
	"google.golang.org/protobuf/reflect/protoreflect"

	"github.com/eiiches/mysql-protobuf-functions/internal/descriptorsetjson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// FilterDecision represents what to do with a generated function
type FilterDecision int

const (
	DecisionInclude    FilterDecision = iota // Generate the function normally
	DecisionExclude                          // Don't generate the function at all
	DecisionCommentOut                       // Generate the function but comment it out
)

// FieldFilterFunc is called for each function to determine how it should be generated
type FieldFilterFunc func(field protoreflect.FieldDescriptor, functionName string) FilterDecision

type GenerateConfig struct {
	DescriptorSetName string
	IncludeSourceInfo bool
	GenerateMethods   bool
	IncludeWkt        bool
	FileNameFunc      FileNameFunc
	TypePrefixFunc    TypePrefixFunc
	FieldFilterFunc   FieldFilterFunc // Callback to determine how functions should be generated
}

func Generate(fileDescriptorSet *descriptorpb.FileDescriptorSet, config GenerateConfig) (*pluginpb.CodeGeneratorResponse, error) {
	fileDescriptorSet = proto.CloneOf(fileDescriptorSet) // Defensive copy to avoid modifying the original

	// Filter out well-known types if not requested
	if !config.IncludeWkt {
		var filteredFiles []*descriptorpb.FileDescriptorProto
		for _, file := range fileDescriptorSet.File {
			if !isWellKnownType(file.GetName()) {
				filteredFiles = append(filteredFiles, file)
			}
		}
		fileDescriptorSet.File = filteredFiles
	}

	// Process the descriptor set
	if !config.IncludeSourceInfo {
		// Strip source code info by default to reduce size
		files := make([]*descriptorpb.FileDescriptorProto, len(fileDescriptorSet.File))
		for i, file := range fileDescriptorSet.File {
			strippedFile := proto.CloneOf(file)
			strippedFile.SourceCodeInfo = nil
			files[i] = strippedFile
		}
		fileDescriptorSet.File = files
	}

	// Convert to JSON using descriptorsetjson
	jsonStr, err := descriptorsetjson.ToJson(fileDescriptorSet)
	if err != nil {
		return nil, fmt.Errorf("failed to convert FileDescriptorSet to JSON: %w", err)
	}

	// Generate descriptor set SQL function content (without header)
	descriptorSetContent := fmt.Sprintf(`DROP FUNCTION IF EXISTS %s $$
CREATE FUNCTION %s() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('%s' AS JSON);
END $$

`, config.DescriptorSetName, config.DescriptorSetName, EscapeSQLString(jsonStr))

	// Collect all content fragments by filename
	fileFragments := make(map[string][]string)

	// Add descriptor set function fragment
	descriptorSetFileName := config.DescriptorSetName + ".pb.sql"
	fileFragments[descriptorSetFileName] = append(fileFragments[descriptorSetFileName], descriptorSetContent)

	// Generate method fragments if requested
	if config.GenerateMethods {
		files, err := protodesc.NewFiles(fileDescriptorSet)
		if err != nil {
			return nil, fmt.Errorf("failed to create protoregistry.Files from FileDescriptorSet: %w", err)
		}

		methodFragments, err := GenerateMethodFragments(files, config.FileNameFunc, config.TypePrefixFunc, config.DescriptorSetName, config.FieldFilterFunc)
		if err != nil {
			return nil, err
		}
		for filename, fragments := range moremaps.SortedEntries(methodFragments) {
			if filename == "" {
				filename = descriptorSetFileName
			}
			fileFragments[filename] = append(fileFragments[filename], fragments...)
		}
	}

	// Merge fragments and create final files
	var allFiles []*pluginpb.CodeGeneratorResponse_File
	for filename, fragments := range moremaps.SortedEntries(fileFragments) {
		var content strings.Builder
		content.WriteString("-- Code generated by protoc-gen-mysql. DO NOT EDIT.\n\n")
		content.WriteString("DELIMITER $$\n\n")

		for _, fragment := range fragments {
			content.WriteString(fragment)
		}

		allFiles = append(allFiles, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(filename),
			Content: proto.String(content.String()),
		})
	}

	return &pluginpb.CodeGeneratorResponse{
		SupportedFeatures: proto.Uint64(uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)),
		File:              allFiles,
	}, nil
}

// wellKnownTypes contains the set of well-known type files
// This list matches the files in cmd/generate-descriptorsets/main.go
var wellKnownTypes = map[string]struct{}{
	"google/protobuf/descriptor.proto": {},
	"google/protobuf/struct.proto":     {},
	"google/protobuf/field_mask.proto": {},
	"google/protobuf/wrappers.proto":   {},
	"google/protobuf/timestamp.proto":  {},
	"google/protobuf/duration.proto":   {},
	"google/protobuf/any.proto":        {},
	"google/protobuf/empty.proto":      {},
}

// isWellKnownType checks if a proto file is a well-known type
func isWellKnownType(filename string) bool {
	_, exists := wellKnownTypes[filename]
	return exists
}
