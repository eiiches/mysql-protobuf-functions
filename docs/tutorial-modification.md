> ⚠️ This document was generated by AI and has not yet been thoroughly reviewed. Some information may be wrong or incomplete.

# Tutorial: Message Modification

*Creating and modifying protobuf messages using low-level functions*

This tutorial shows how to create new protobuf messages and modify existing ones using **low-level functions**. These operations work with field numbers and don't require schema information.

> **Prerequisites:** Complete [Tutorial: Basics](tutorial-basics.md) first to understand field access patterns.

## Creating New Messages

Start with an empty message and build it up field by field:

```sql
-- Create a new empty message
> SET @new_person = pb_message_new();

-- Add fields one by one
> SET @new_person = pb_message_set_string_field(@new_person, 1, 'John Doe');      -- name
> SET @new_person = pb_message_set_int32_field(@new_person, 2, 42);               -- id  
> SET @new_person = pb_message_set_string_field(@new_person, 3, 'john@email.com'); -- email

-- Verify the result
> SELECT pb_message_get_string_field(@new_person, 1, '') AS name;
John Doe
```

## Chained Operations

You can chain operations together for more compact code:

```sql
-- Create and populate in one statement
> SELECT pb_message_set_string_field(
    pb_message_set_int32_field(
      pb_message_set_string_field(pb_message_new(), 1, 'Jane Smith'), 
      2, 25
    ),
    3, 'jane@email.com'
  ) AS new_message;
```

## Modifying Existing Messages

Modify fields in existing messages while preserving other data:

```sql
-- Using the sample data from tutorial-basics.md
CREATE TABLE Example (pb_data BLOB);
INSERT INTO Example (pb_data) VALUES (_binary X'0a0b4167656e7420536d69746810011a11736d697468406578616d706c652e636f6d22140a102b38312d30302d303030302d3030303010032a0c08f091f1c10610c0de9cf802');

-- Update individual fields
> SELECT pb_message_set_string_field(pb_data, 1, 'New Name') AS updated_person FROM Example LIMIT 1;

-- Update multiple fields  
> SELECT pb_message_set_int32_field(
    pb_message_set_string_field(pb_data, 1, 'Updated Name'),
    2, 99
  ) AS multi_updated FROM Example LIMIT 1;
```

## Working with Repeated Fields

### Adding Elements

```sql
-- Add a new phone number to the phones field (field 4)
> SELECT pb_message_add_repeated_message_field_element(
    pb_data,
    4, -- phones field
    pb_message_set_enum_field(
      pb_message_set_string_field(pb_message_new(), 1, '+1-555-0123'), -- number field (1)
      2, 1 -- type field (2) = PHONE_TYPE_MOBILE
    )
  ) AS person_with_new_phone FROM Example LIMIT 1;
```

### Modifying Existing Elements

```sql
-- Change the type of the first phone number from WORK (3) to MOBILE (1)
> SELECT pb_message_set_repeated_message_field_element(
    pb_data,
    4, 0, -- phones[0]
    pb_message_set_enum_field(
      pb_message_get_repeated_message_field_element(pb_data, 4, 0), -- get existing phone
      2, 1 -- set type = PHONE_TYPE_MOBILE
    )
  ) AS person_mobile_phone FROM Example LIMIT 1;
```

### Bulk Operations with Repeated Fields

```sql
-- Add multiple string elements at once
> SELECT pb_message_add_all_repeated_string_field_elements(
    pb_message_new(), 
    5, -- some string list field
    '["item1", "item2", "item3"]'
  ) AS bulk_strings;

-- Add multiple integers with packed encoding
> SELECT pb_message_add_all_repeated_int32_field_elements(
    pb_message_new(),
    6, -- some number list field  
    '[1, 2, 3, 4, 5]',
    TRUE -- use packed encoding for efficiency
  ) AS packed_numbers;
```

## Clearing Fields

Remove fields while keeping the rest of the message intact:

```sql
-- Clear the email field (field 3)
> SELECT pb_message_clear_string_field(pb_data, 3) AS person_no_email FROM Example LIMIT 1;

-- Clear entire repeated field
> SELECT pb_message_clear_repeated_message_field(pb_data, 4) AS person_no_phones FROM Example LIMIT 1;

-- Clear all fields (returns empty message)
> SELECT pb_message_clear(pb_data) AS empty_message FROM Example LIMIT 1;
```

## Nested Messages

Work with nested messages by extracting, modifying, and setting them back:

```sql
-- Get the existing phone number
> SET @phone = pb_message_get_repeated_message_field_element(pb_data, 4, 0);

-- Modify the phone number 
> SET @phone = pb_message_set_string_field(@phone, 1, '+1-555-NEW-NUMBER');

-- Put it back into the main message
> SELECT pb_message_set_repeated_message_field_element(pb_data, 4, 0, @phone) AS updated_phone FROM Example LIMIT 1;
```

## Practical Example: User Profile Updates

```sql
-- Create a table for user profiles
CREATE TABLE UserProfiles (
  user_id INT PRIMARY KEY,
  profile_data LONGBLOB
);

-- Insert initial profile
INSERT INTO UserProfiles VALUES (
  1, 
  pb_message_set_string_field(
    pb_message_set_int32_field(pb_message_new(), 2, 25), 
    1, 'Initial Name'
  )
);

-- Update user's name and age in one operation
UPDATE UserProfiles 
SET profile_data = pb_message_set_int32_field(
  pb_message_set_string_field(profile_data, 1, 'Updated Name'),
  2, 26
)
WHERE user_id = 1;

-- Verify the update
SELECT 
  pb_message_get_string_field(profile_data, 1, '') AS name,
  pb_message_get_int32_field(profile_data, 2, 0) AS age
FROM UserProfiles 
WHERE user_id = 1;
```

## Performance Tips for Modifications

### Use Wire JSON for Multiple Operations

When performing 2+ operations on the same message, Wire JSON is more efficient:

```sql
-- ❌ Slow: Multiple parse/serialize cycles
UPDATE UserProfiles 
SET profile_data = pb_message_set_string_field(
  pb_message_set_int32_field(
    pb_message_add_repeated_string_field_element(profile_data, 4, 'hobby'),
    2, 30
  ),
  1, 'New Name'
)
WHERE user_id = 1;

-- ✅ Fast: Parse once, serialize once
UPDATE UserProfiles 
SET profile_data = pb_wire_json_to_message(
  pb_wire_json_set_string_field(
    pb_wire_json_set_int32_field(
      pb_wire_json_add_repeated_string_field_element(
        pb_message_to_wire_json(profile_data), -- Parse once here
        4, 'hobby'
      ),
      2, 30
    ),
    1, 'New Name'
  ) -- Serialize once here
)
WHERE user_id = 1;
```

## Next Steps

You now know how to create and modify protobuf messages with low-level functions. Next:

- **Learn schema-aware features** → [Tutorial: JSON Integration](tutorial-json.md)
- **See real-world patterns** → [User Guide](user-guide.md)
- **Explore all functions** → [Function Reference](function-reference.md)

Low-level modification functions give you complete control over your protobuf data structure while maintaining compatibility with any protobuf implementation.