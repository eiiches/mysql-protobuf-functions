package main

import (
	"context"
	"fmt"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/eiiches/mysql-protobuf-functions/internal/descriptorsetjson"
	"github.com/urfave/cli/v3"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	// Check if running in standalone mode (any command line arguments)
	if len(os.Args) > 1 {
		runStandalone()
		return
	}

	// Original protoc plugin mode
	runAsProtocPlugin()
}

func runStandalone() {
	app := &cli.Command{
		Name:  "protoc-gen-descriptor_set_json",
		Usage: "Generate MySQL stored functions containing descriptor set JSON for protobuf schemas",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:     "descriptor_set_in",
				Usage:    "Path to binary FileDescriptorSet file",
				Required: true,
			},
			&cli.StringFlag{
				Name:     "name",
				Usage:    "Name of the generated SQL function",
				Required: true,
			},
			&cli.BoolFlag{
				Name:  "include_source_info",
				Usage: "Include source code info in output (increases output size significantly)",
				Value: false,
			},
			&cli.StringFlag{
				Name:  "descriptor_set_json_out",
				Usage: "Output directory for generated SQL file",
				Value: ".",
			},
		},
		Action: func(ctx context.Context, cmd *cli.Command) error {
			descriptorSetIn := cmd.String("descriptor_set_in")
			name := cmd.String("name")
			includeSourceInfo := cmd.Bool("include_source_info")
			descriptorSetJSONOut := cmd.String("descriptor_set_json_out")

			// Read binary FileDescriptorSet from file
			data, err := os.ReadFile(descriptorSetIn)
			if err != nil {
				return fmt.Errorf("failed to read descriptor set file: %w", err)
			}

			var fileDescriptorSet descriptorpb.FileDescriptorSet
			if unmarshalErr := proto.Unmarshal(data, &fileDescriptorSet); unmarshalErr != nil {
				return fmt.Errorf("failed to unmarshal FileDescriptorSet: %w", unmarshalErr)
			}

			// Process the descriptor set
			if !includeSourceInfo {
				// Strip source code info by default to reduce size
				files := make([]*descriptorpb.FileDescriptorProto, len(fileDescriptorSet.File))
				for i, file := range fileDescriptorSet.File {
					strippedFile := proto.CloneOf(file)
					strippedFile.SourceCodeInfo = nil
					files[i] = strippedFile
				}
				fileDescriptorSet.File = files
			}

			// Convert to JSON using descriptorsetjson
			jsonStr, err := descriptorsetjson.ToJson(&fileDescriptorSet)
			if err != nil {
				return fmt.Errorf("failed to convert FileDescriptorSet to JSON: %w", err)
			}

			// Generate SQL function
			sqlContent := fmt.Sprintf(`-- Code generated by protoc-gen-descriptor_set_json. DO NOT EDIT.

DELIMITER $$

DROP FUNCTION IF EXISTS %s $$
CREATE FUNCTION %s() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('%s' AS JSON);
END $$
`, name, name, escapeSQLString(jsonStr))

			// Write to output file
			outputFile := filepath.Join(descriptorSetJSONOut, name+".sql")
			//nolint:gosec // 0o644 permissions are intentional for generated SQL files
			if err := os.WriteFile(outputFile, []byte(sqlContent), 0o644); err != nil {
				return fmt.Errorf("failed to write output file: %w", err)
			}

			fmt.Fprintf(os.Stderr, "Generated %s\n", outputFile)
			return nil
		},
	}

	if err := app.Run(context.Background(), os.Args); err != nil {
		log.Fatal(err)
	}
}

func runAsProtocPlugin() {
	// Read CodeGeneratorRequest from stdin
	input, err := io.ReadAll(os.Stdin)
	if err != nil {
		log.Fatalf("Failed to read input: %v", err)
	}

	var req pluginpb.CodeGeneratorRequest
	if unmarshalErr := proto.Unmarshal(input, &req); unmarshalErr != nil {
		log.Fatalf("Failed to unmarshal CodeGeneratorRequest: %v", unmarshalErr)
	}

	// Parse plugin options
	var functionName string
	includeSourceInfo := false
	if req.Parameter != nil && *req.Parameter != "" {
		params := parseParameters(*req.Parameter)
		if name, ok := params["name"]; ok {
			functionName = name
		}
		if include, ok := params["include_source_info"]; ok {
			includeSourceInfo = include == "true"
		}
	}

	if functionName == "" {
		sendError("name parameter is required. Use --descriptor_set_json_opt=name=your_function_name")
		return
	}

	// Build FileDescriptorSet from the request
	files := req.ProtoFile
	if !includeSourceInfo {
		// Strip source code info by default to reduce size
		files = make([]*descriptorpb.FileDescriptorProto, len(req.ProtoFile))
		for i, file := range req.ProtoFile {
			strippedFile := proto.CloneOf(file)
			strippedFile.SourceCodeInfo = nil
			files[i] = strippedFile
		}
	}

	fileDescriptorSet := &descriptorpb.FileDescriptorSet{
		File: files,
	}

	// Convert to JSON using descriptorsetjson
	jsonStr, err := descriptorsetjson.ToJson(fileDescriptorSet)
	if err != nil {
		sendError(fmt.Sprintf("Failed to convert FileDescriptorSet to JSON: %v", err))
		return
	}

	// Generate SQL function
	sqlContent := fmt.Sprintf(`-- Code generated by protoc-gen-descriptor_set_json. DO NOT EDIT.

DELIMITER $$

DROP FUNCTION IF EXISTS %s $$
CREATE FUNCTION %s() RETURNS JSON DETERMINISTIC
BEGIN
	RETURN CAST('%s' AS JSON);
END $$
`, functionName, functionName, escapeSQLString(jsonStr))

	// Create response
	response := &pluginpb.CodeGeneratorResponse{
		File: []*pluginpb.CodeGeneratorResponse_File{
			{
				Name:    proto.String(functionName + ".sql"),
				Content: proto.String(sqlContent),
			},
		},
	}

	// Marshal and write response
	output, err := proto.Marshal(response)
	if err != nil {
		log.Fatalf("Failed to marshal response: %v", err)
	}

	if _, err := os.Stdout.Write(output); err != nil {
		log.Fatalf("Failed to write output: %v", err)
	}
}

func parseParameters(paramStr string) map[string]string {
	params := make(map[string]string)
	pairs := strings.Split(paramStr, ",")
	for _, pair := range pairs {
		kv := strings.SplitN(pair, "=", 2)
		if len(kv) == 2 {
			params[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
		}
	}
	return params
}

func escapeSQLString(s string) string {
	// Escape single quotes and backslashes for SQL string literals
	result := ""
	for _, char := range s {
		switch char {
		case '\'':
			result += "''"
		case '\\':
			result += "\\\\"
		default:
			result += string(char)
		}
	}
	return result
}

func sendError(message string) {
	response := &pluginpb.CodeGeneratorResponse{
		Error: proto.String(message),
	}

	output, err := proto.Marshal(response)
	if err != nil {
		log.Fatalf("Failed to marshal error response: %v", err)
	}

	if _, err := os.Stdout.Write(output); err != nil {
		log.Fatalf("Failed to write error output: %v", err)
	}
}
